diff -uNr w32api-3.5/include/iphlpapi.h w32api-3.5-xorp/include/iphlpapi.h
--- w32api-3.5/include/iphlpapi.h	Tue Apr  9 22:17:17 2002
+++ w32api-3.5-xorp/include/iphlpapi.h	Wed Dec  7 15:52:32 2005
@@ -21,6 +21,7 @@
 DWORD WINAPI EnableRouter(HANDLE*,OVERLAPPED*);
 DWORD WINAPI FlushIpNetTable(DWORD);
 DWORD WINAPI GetAdapterIndex(LPWSTR,PULONG);
+DWORD WINAPI GetAdaptersAddresses(ULONG,DWORD,PVOID,PIP_ADAPTER_ADDRESSES,PULONG);
 DWORD WINAPI GetAdaptersInfo(PIP_ADAPTER_INFO,PULONG);
 DWORD WINAPI GetBestInterface(IPAddr,PDWORD);
 DWORD WINAPI GetBestRoute(DWORD,DWORD,PMIB_IPFORWARDROW);
diff -uNr w32api-3.5/include/ipifcons.h w32api-3.5-xorp/include/ipifcons.h
--- w32api-3.5/include/ipifcons.h	Tue Apr  9 22:17:17 2002
+++ w32api-3.5-xorp/include/ipifcons.h	Wed Dec  7 15:46:22 2005
@@ -4,6 +4,172 @@
 #pragma GCC system_header
 #endif
 
+#define MIN_IF_TYPE 1
+#define IF_TYPE_OTHER 1
+#define IF_TYPE_REGULAR_1822 2
+#define IF_TYPE_HDH_1822 3
+#define IF_TYPE_DDN_X25 4
+#define IF_TYPE_RFC877_X25 5
+#define IF_TYPE_ETHERNET_CSMACD 6
+#define IF_TYPE_IS088023_CSMACD 7
+#define IF_TYPE_ISO88024_TOKENBUS 8
+#define IF_TYPE_ISO88025_TOKENRING 9
+#define IF_TYPE_ISO88026_MAN 10
+#define IF_TYPE_STARLAN 11
+#define IF_TYPE_PROTEON_10MBIT 12
+#define IF_TYPE_PROTEON_80MBIT 13
+#define IF_TYPE_HYPERCHANNEL 14
+#define IF_TYPE_FDDI 15
+#define IF_TYPE_LAP_B 16
+#define IF_TYPE_SDLC 17
+#define IF_TYPE_DS1 18
+#define IF_TYPE_E1 19
+#define IF_TYPE_BASIC_ISDN 20
+#define IF_TYPE_PRIMARY_ISDN 21
+#define IF_TYPE_PROP_POINT2POINT_SERIAL 22
+#define IF_TYPE_PPP 23
+#define IF_TYPE_SOFTWARE_LOOPBACK 24
+#define IF_TYPE_EON 25
+#define IF_TYPE_ETHERNET_3MBIT 26
+#define IF_TYPE_NSIP 27
+#define IF_TYPE_SLIP 28
+#define IF_TYPE_ULTRA 29
+#define IF_TYPE_DS3 30
+#define IF_TYPE_SIP 31
+#define IF_TYPE_FRAMERELAY 32
+#define IF_TYPE_RS232 33
+#define IF_TYPE_PARA 34
+#define IF_TYPE_ARCNET 35
+#define IF_TYPE_ARCNET_PLUS 36
+#define IF_TYPE_ATM 37
+#define IF_TYPE_MIO_X25 38
+#define IF_TYPE_SONET 39
+#define IF_TYPE_X25_PLE 40
+#define IF_TYPE_ISO88022_LLC 41
+#define IF_TYPE_LOCALTALK 42
+#define IF_TYPE_SMDS_DXI 43
+#define IF_TYPE_FRAMERELAY_SERVICE 44
+#define IF_TYPE_V35 45
+#define IF_TYPE_HSSI 46
+#define IF_TYPE_HIPPI 47
+#define IF_TYPE_MODEM 48
+#define IF_TYPE_AAL5 49
+#define IF_TYPE_SONET_PATH 50
+#define IF_TYPE_SONET_VT 51
+#define IF_TYPE_SMDS_ICIP 52
+#define IF_TYPE_PROP_VIRTUAL 53
+#define IF_TYPE_PROP_MULTIPLEXOR 54
+#define IF_TYPE_IEEE80212 55
+#define IF_TYPE_FIBRECHANNEL 56
+#define IF_TYPE_HIPPIINTERFACE 57
+#define IF_TYPE_FRAMERELAY_INTERCONNECT 58
+#define IF_TYPE_AFLANE_8023 59
+#define IF_TYPE_AFLANE_8025 60
+#define IF_TYPE_CCTEMUL 61
+#define IF_TYPE_FASTETHER 62
+#define IF_TYPE_ISDN 63
+#define IF_TYPE_V11 64
+#define IF_TYPE_V36 65
+#define IF_TYPE_G703_64K 66
+#define IF_TYPE_G703_2MB 67
+#define IF_TYPE_QLLC 68
+#define IF_TYPE_FASTETHER_FX 69
+#define IF_TYPE_CHANNEL 70
+#define IF_TYPE_IEEE80211 71
+#define IF_TYPE_IBM370PARCHAN 72
+#define IF_TYPE_ESCON 73
+#define IF_TYPE_DLSW 74
+#define IF_TYPE_ISDN_S 75
+#define IF_TYPE_ISDN_U 76
+#define IF_TYPE_LAP_D 77
+#define IF_TYPE_IPSWITCH 78
+#define IF_TYPE_RSRB 79
+#define IF_TYPE_ATM_LOGICAL 80
+#define IF_TYPE_DS0 81
+#define IF_TYPE_DS0_BUNDLE 82
+#define IF_TYPE_BSC 83
+#define IF_TYPE_ASYNC 84
+#define IF_TYPE_CNR 85
+#define IF_TYPE_ISO88025R_DTR 86
+#define IF_TYPE_EPLRS 87
+#define IF_TYPE_ARAP 88
+#define IF_TYPE_PROP_CNLS 89
+#define IF_TYPE_HOSTPAD 90
+#define IF_TYPE_TERMPAD 91
+#define IF_TYPE_FRAMERELAY_MPI 92
+#define IF_TYPE_X213 93
+#define IF_TYPE_ADSL 94
+#define IF_TYPE_RADSL 95
+#define IF_TYPE_SDSL 96
+#define IF_TYPE_VDSL 97
+#define IF_TYPE_ISO88025_CRFPRINT 98
+#define IF_TYPE_MYRINET 99
+#define IF_TYPE_VOICE_EM 100
+#define IF_TYPE_VOICE_FXO 101
+#define IF_TYPE_VOICE_FXS 102
+#define IF_TYPE_VOICE_ENCAP 103
+#define IF_TYPE_VOICE_OVERIP 104
+#define IF_TYPE_ATM_DXI 105
+#define IF_TYPE_ATM_FUNI 106
+#define IF_TYPE_ATM_IMA 107
+#define IF_TYPE_PPPMULTILINKBUNDLE 108
+#define IF_TYPE_IPOVER_CDLC 109
+#define IF_TYPE_IPOVER_CLAW 110
+#define IF_TYPE_STACKTOSTACK 111
+#define IF_TYPE_VIRTUALIPADDRESS 112
+#define IF_TYPE_MPC 113
+#define IF_TYPE_IPOVER_ATM 114
+#define IF_TYPE_ISO88025_FIBER 115
+#define IF_TYPE_TDLC 116
+#define IF_TYPE_GIGABITETHERNET 117
+#define IF_TYPE_HDLC 118
+#define IF_TYPE_LAP_F 119
+#define IF_TYPE_V37 120
+#define IF_TYPE_X25_MLP 121
+#define IF_TYPE_X25_HUNTGROUP 122
+#define IF_TYPE_TRANSPHDLC 123
+#define IF_TYPE_INTERLEAVE 124
+#define IF_TYPE_FAST 125
+#define IF_TYPE_IP 126
+#define IF_TYPE_DOCSCABLE_MACLAYER 127
+#define IF_TYPE_DOCSCABLE_DOWNSTREAM 128
+#define IF_TYPE_DOCSCABLE_UPSTREAM 129
+#define IF_TYPE_A12MPPSWITCH 130
+#define IF_TYPE_TUNNEL 131
+#define IF_TYPE_COFFEE 132
+#define IF_TYPE_CES 133
+#define IF_TYPE_ATM_SUBINTERFACE 134
+#define IF_TYPE_L2_VLAN 135
+#define IF_TYPE_L3_IPVLAN 136
+#define IF_TYPE_L3_IPXVLAN 137
+#define IF_TYPE_DIGITALPOWERLINE 138
+#define IF_TYPE_MEDIAMAILOVERIP 139
+#define IF_TYPE_DTM 140
+#define IF_TYPE_DCN 141
+#define IF_TYPE_IPFORWARD 142
+#define IF_TYPE_MSDSL 143
+#define IF_TYPE_IEEE1394 144
+#define IF_TYPE_RECEIVE_ONLY 145
+#define MAX_IF_TYPE 145
+#define IF_ACCESS_LOOPBACK 1
+#define IF_ACCESS_BROADCAST 2
+#define IF_ACCESS_POINTTOPOINT 3
+#define IF_ACCESS_POINTTOMULTIPOINT 4
+#define IF_CHECK_NONE 0x00
+#define IF_CHECK_MCAST 0x01
+#define IF_CHECK_SEND 0x02
+#define IF_CONNECTION_DEDICATED 1
+#define IF_CONNECTION_PASSIVE 2
+#define IF_CONNECTION_DEMAND 3
+#define IF_ADMIN_STATUS_UP 1
+#define IF_ADMIN_STATUS_DOWN 2
+#define IF_ADMIN_STATUS_TESTING 3
+#define IF_OPER_STATUS_NON_OPERATIONAL 0
+#define IF_OPER_STATUS_UNREACHABLE 1
+#define IF_OPER_STATUS_DISCONNECTED 2
+#define IF_OPER_STATUS_CONNECTING 3
+#define IF_OPER_STATUS_CONNECTED 4
+#define IF_OPER_STATUS_OPERATIONAL 5
 #define MIB_IF_ADMIN_STATUS_UP 1
 #define MIB_IF_ADMIN_STATUS_DOWN 2
 #define MIB_IF_ADMIN_STATUS_TESTING 3
diff -uNr w32api-3.5/include/iprtrmib.h w32api-3.5-xorp/include/iprtrmib.h
--- w32api-3.5/include/iprtrmib.h	Tue Apr  9 22:17:17 2002
+++ w32api-3.5-xorp/include/iprtrmib.h	Wed Dec  7 18:42:27 2005
@@ -4,108 +4,68 @@
 #pragma GCC system_header
 #endif
 
+#include <mprapi.h>
 #include <ipifcons.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
+
+#define IPRTRMGR_PID 10000
 #ifndef ANY_SIZE
 #define ANY_SIZE 1
 #endif
-#define MAXLEN_PHYSADDR 8
+#define TCPIP_OWNING_MODULE_SIZE 16
+#define IF_NUMBER 0
+#define IF_TABLE (IF_NUMBER + 1)
+#define IF_ROW (IF_TABLE + 1)
+#define IP_STATS (IF_ROW + 1)
+#define IP_ADDRTABLE (IP_STATS + 1)
+#define IP_ADDRROW (IP_ADDRTABLE + 1)
+#define IP_FORWARDNUMBER (IP_ADDRROW + 1)
+#define IP_FORWARDTABLE (IP_FORWARDNUMBER + 1)
+#define IP_FORWARDROW (IP_FORWARDTABLE + 1)
+#define IP_NETTABLE (IP_FORWARDROW + 1)
+#define IP_NETROW (IP_NETTABLE + 1)
+#define ICMP_STATS (IP_NETROW + 1)
+#define TCP_STATS (ICMP_STATS + 1)
+#define TCP_TABLE (TCP_STATS + 1)
+#define TCP_ROW (TCP_TABLE + 1)
+#define UDP_STATS (TCP_ROW + 1)
+#define UDP_TABLE (UDP_STATS + 1)
+#define UDP_ROW (UDP_TABLE + 1)
+#define MCAST_MFE (UDP_ROW + 1)
+#define MCAST_MFE_STATS (MCAST_MFE + 1)
+#define BEST_IF (MCAST_MFE_STATS + 1)
+#define BEST_ROUTE (BEST_IF + 1)
+#define PROXY_ARP (BEST_ROUTE + 1)
+#define MCAST_IF_ENTRY (PROXY_ARP + 1)
+#define MCAST_GLOBAL (MCAST_IF_ENTRY + 1)
+#define IF_STATUS (MCAST_GLOBAL + 1)
+#define MCAST_BOUNDARY (IF_STATUS + 1)
+#define MCAST_SCOPE (MCAST_BOUNDARY + 1)
+#define DEST_MATCHING (MCAST_SCOPE + 1)
+#define DEST_LONGER (DEST_MATCHING + 1)
+#define DEST_SHORTER (DEST_LONGER + 1)
+#define ROUTE_MATCHING (DEST_SHORTER + 1)
+#define ROUTE_LONGER (ROUTE_MATCHING + 1)
+#define ROUTE_SHORTER (ROUTE_LONGER + 1)
+#define ROUTE_STATE (ROUTE_SHORTER + 1)
+#define MCAST_MFE_STATS_EX (ROUTE_STATE + 1)
+#define IP6_STATS (MCAST_MFE_STATS_EX + 1)
+#define UDP6_STATS (IP6_STATS + 1)
+#define TCP6_STATS (UDP6_STATS + 1)
+#define NUMBER_OF_EXPORTED_VARIABLES (TCP6_STATS + 1)
+typedef struct _MIB_OPAQUE_QUERY {
+  DWORD dwVarId;
+  DWORD rgdwVarIndex[ANY_SIZE];
+} MIB_OPAQUE_QUERY, *PMIB_OPAQUE_QUERY;
+typedef struct _MIB_IFNUMBER {
+  DWORD dwValue;
+} MIB_IFNUMBER, *PMIB_IFNUMBER;
 #define MAXLEN_IFDESCR 256
-#ifndef MAX_INTERFACE_NAME_LEN
-#define MAX_INTERFACE_NAME_LEN 256
-#endif
-#define MIB_IPNET_TYPE_OTHER 1
-#define MIB_IPNET_TYPE_INVALID 2
-#define MIB_IPNET_TYPE_DYNAMIC 3
-#define MIB_IPNET_TYPE_STATIC 4
-#define MIB_TCP_RTO_OTHER 1
-#define MIB_TCP_RTO_CONSTANT 2
-#define MIB_TCP_RTO_RSRE 3
-#define MIB_TCP_RTO_VANJ 4
-#define MIB_TCP_STATE_CLOSED 1                 
-#define MIB_TCP_STATE_LISTEN 2                 
-#define MIB_TCP_STATE_SYN_SENT 3                 
-#define MIB_TCP_STATE_SYN_RCVD 4                 
-#define MIB_TCP_STATE_ESTAB 5                 
-#define MIB_TCP_STATE_FIN_WAIT1 6                 
-#define MIB_TCP_STATE_FIN_WAIT2 7                 
-#define MIB_TCP_STATE_CLOSE_WAIT 8                 
-#define MIB_TCP_STATE_CLOSING 9                
-#define MIB_TCP_STATE_LAST_ACK 10                
-#define MIB_TCP_STATE_TIME_WAIT 11                
-#define MIB_TCP_STATE_DELETE_TCB 12                
-#define MIB_USE_CURRENT_TTL ((DWORD)-1)
-#define MIB_USE_CURRENT_FORWARDING ((DWORD)-1)
-#define MIB_TCP_MAXCONN_DYNAMIC ((DWORD)-1)
-typedef struct {
-  DWORD dwAddr;
-  DWORD dwIndex;
-  DWORD dwMask;
-  DWORD dwBCastAddr;
-  DWORD dwReasmSize;
-  unsigned short unused1;
-  unsigned short unused2;
-} MIB_IPADDRROW, *PMIB_IPADDRROW;
-typedef struct {
-  DWORD dwNumEntries;
-  MIB_IPADDRROW table[ANY_SIZE];
-} MIB_IPADDRTABLE, *PMIB_IPADDRTABLE;
-typedef struct {
-  DWORD dwForwardDest;
-  DWORD dwForwardMask;
-  DWORD dwForwardPolicy;
-  DWORD dwForwardNextHop;
-  DWORD dwForwardIfIndex;
-  DWORD dwForwardType;
-  DWORD dwForwardProto;
-  DWORD dwForwardAge;
-  DWORD dwForwardNextHopAS;
-  DWORD dwForwardMetric1;
-  DWORD dwForwardMetric2;
-  DWORD dwForwardMetric3;
-  DWORD dwForwardMetric4;
-  DWORD dwForwardMetric5;
-} MIB_IPFORWARDROW, *PMIB_IPFORWARDROW;
-typedef struct {
-  DWORD dwNumEntries;
-  MIB_IPFORWARDROW table[ANY_SIZE];
-} MIB_IPFORWARDTABLE, *PMIB_IPFORWARDTABLE;
-typedef struct {
-  DWORD dwIndex;
-  DWORD dwPhysAddrLen;
-  BYTE bPhysAddr[MAXLEN_PHYSADDR];
-  DWORD dwAddr;
-  DWORD dwType;
-} MIB_IPNETROW, *PMIB_IPNETROW;
-typedef struct {
-  DWORD dwNumEntries;
-  MIB_IPNETROW table[ANY_SIZE];
-} MIB_IPNETTABLE, *PMIB_IPNETTABLE;
-typedef struct {
-  DWORD dwMsgs;
-  DWORD dwErrors;
-  DWORD dwDestUnreachs;
-  DWORD dwTimeExcds;
-  DWORD dwParmProbs;
-  DWORD dwSrcQuenchs;
-  DWORD dwRedirects;
-  DWORD dwEchos;
-  DWORD dwEchoReps;
-  DWORD dwTimestamps;
-  DWORD dwTimestampReps;
-  DWORD dwAddrMasks;
-  DWORD dwAddrMaskReps;
-} MIBICMPSTATS, *PMIBICMPSTATS;
-typedef struct {
-  MIBICMPSTATS icmpInStats;
-  MIBICMPSTATS icmpOutStats;
-} MIBICMPINFO, *PMIBICMPINFO;
-typedef struct {
-  MIBICMPINFO stats;
-} MIB_ICMP, *PMIB_ICMP;
-typedef struct {
+#define MAXLEN_PHYSADDR 8
+typedef struct _MIB_IFROW {
   WCHAR wszName[MAX_INTERFACE_NAME_LEN];
   DWORD dwIndex;
   DWORD dwType;
@@ -129,38 +89,153 @@
   DWORD dwOutErrors;
   DWORD dwOutQLen;
   DWORD dwDescrLen;
-  BYTE  bDescr[MAXLEN_IFDESCR];
+  BYTE bDescr[MAXLEN_IFDESCR];
 } MIB_IFROW, *PMIB_IFROW;
-typedef struct {
+typedef struct _MIB_IFTABLE {
   DWORD dwNumEntries;
   MIB_IFROW table[ANY_SIZE];
 } MIB_IFTABLE, *PMIB_IFTABLE;
-typedef struct {
-  DWORD dwForwarding;
-  DWORD dwDefaultTTL;
-  DWORD dwInReceives;
-  DWORD dwInHdrErrors;
-  DWORD dwInAddrErrors;
-  DWORD dwForwDatagrams;
-  DWORD dwInUnknownProtos;
-  DWORD dwInDiscards;
-  DWORD dwInDelivers;
-  DWORD dwOutRequests;
-  DWORD dwRoutingDiscards;
-  DWORD dwOutDiscards;
-  DWORD dwOutNoRoutes;
-  DWORD dwReasmTimeout;
-  DWORD dwReasmReqds;
-  DWORD dwReasmOks;
-  DWORD dwReasmFails;
-  DWORD dwFragOks;
-  DWORD dwFragFails;
-  DWORD dwFragCreates;
-  DWORD dwNumIf;
-  DWORD dwNumAddr;
-  DWORD dwNumRoutes;
-} MIB_IPSTATS, *PMIB_IPSTATS;
-typedef struct {
+#define SIZEOF_IFTABLE(X) (FIELD_OFFSET(MIB_IFTABLE,table[0]) + ((X) * sizeof(MIB_IFROW)) + ALIGN_SIZE)
+typedef struct _MIBICMPSTATS {
+  DWORD dwMsgs;
+  DWORD dwErrors;
+  DWORD dwDestUnreachs;
+  DWORD dwTimeExcds;
+  DWORD dwParmProbs;
+  DWORD dwSrcQuenchs;
+  DWORD dwRedirects;
+  DWORD dwEchos;
+  DWORD dwEchoReps;
+  DWORD dwTimestamps;
+  DWORD dwTimestampReps;
+  DWORD dwAddrMasks;
+  DWORD dwAddrMaskReps;
+} MIBICMPSTATS, *PMIBICMPSTATS;
+typedef struct _MIBICMPINFO {
+  MIBICMPSTATS icmpInStats;
+  MIBICMPSTATS icmpOutStats;
+} MIBICMPINFO;
+typedef struct _MIB_ICMP {
+  MIBICMPINFO stats;
+} MIB_ICMP, *PMIB_ICMP;
+typedef enum {
+  ICMP6_DST_UNREACH = 1,
+  ICMP6_PACKET_TOO_BIG = 2,
+  ICMP6_TIME_EXCEEDED = 3,
+  ICMP6_PARAM_PROB = 4,
+  ICMP6_ECHO_REQUEST = 128,
+  ICMP6_ECHO_REPLY = 129,
+  ICMP6_MEMBERSHIP_QUERY = 130,
+  ICMP6_MEMBERSHIP_REPORT = 131,
+  ICMP6_MEMBERSHIP_REDUCTION = 132,
+  ND_ROUTER_SOLICIT = 133,
+  ND_ROUTER_ADVERT = 134,
+  ND_NEIGHBOR_SOLICIT = 135,
+  ND_NEIGHBOR_ADVERT = 136,
+  ND_REDIRECT = 137,
+} ICMP6_TYPE, *PICMP6_TYPE;
+typedef enum {
+  ICMP4_ECHO_REPLY = 0,
+  ICMP4_DST_UNREACH = 3,
+  ICMP4_SOURCE_QUENCH = 4,
+  ICMP4_REDIRECT = 5,
+  ICMP4_ECHO_REQUEST = 8,
+  ICMP4_ROUTER_ADVERT = 9,
+  ICMP4_ROUTER_SOLICIT = 10,
+  ICMP4_TIME_EXCEEDED = 11,
+  ICMP4_PARAM_PROB = 12,
+  ICMP4_TIMESTAMP_REQUEST = 13,
+  ICMP4_TIMESTAMP_REPLY = 14,
+  ICMP4_MASK_REQUEST = 17,
+  ICMP4_MASK_REPLY = 18,
+} ICMP4_TYPE, *PICMP4_TYPE;
+typedef struct _MIBICMPSTATS_EX {
+  DWORD dwMsgs;
+  DWORD dwErrors;
+  DWORD rgdwTypeCount[256];
+} MIBICMPSTATS_EX, *PMIBICMPSTATS_EX;
+typedef struct _MIB_ICMP_EX {
+  MIBICMPSTATS_EX icmpInStats;
+  MIBICMPSTATS_EX icmpOutStats;
+} MIB_ICMP_EX, *PMIB_ICMP_EX;
+typedef struct _MIB_UDPSTATS {
+  DWORD dwInDatagrams;
+  DWORD dwNoPorts;
+  DWORD dwInErrors;
+  DWORD dwOutDatagrams;
+  DWORD dwNumAddrs;
+} MIB_UDPSTATS, *PMIB_UDPSTATS;
+typedef struct _MIB_UDPROW {
+  DWORD dwLocalAddr;
+  DWORD dwLocalPort;
+} MIB_UDPROW, *PMIB_UDPROW;
+typedef MIB_UDPROW MIB_UDPROW_BASIC, *PMIB_UDPROW_BASIC;
+typedef struct _MIB_UDPROW_OWNER_PID {
+  DWORD dwLocalAddr;
+  DWORD dwLocalPort;
+  DWORD dwOwningPid;
+} MIB_UDPROW_OWNER_PID, *PMIB_UDPROW_OWNER_PID;
+typedef struct _MIB_UDPROW_OWNER_MODULE {
+  DWORD dwLocalAddr;
+  DWORD dwLocalPort;
+  DWORD dwOwningPid;
+  LARGE_INTEGER liCreateTimestamp;
+  union {
+    struct {
+      DWORD SpecificPortBind:1;
+    };
+    DWORD dwFlags;
+  };
+  ULONGLONG OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
+} MIB_UDPROW_OWNER_MODULE, *PMIB_UDPROW_OWNER_MODULE;
+typedef struct _MIB_UDP6ROW_OWNER_PID {
+  UCHAR ucLocalAddr[16];
+  DWORD dwLocalScopeId;
+  DWORD dwLocalPort;
+  DWORD dwOwningPid;
+} MIB_UDP6ROW_OWNER_PID, *PMIB_UDP6ROW_OWNER_PID;
+typedef struct _MIB_UDP6ROW_OWNER_MODULE {
+  UCHAR ucLocalAddr[16];
+  DWORD dwLocalScopeId;
+  DWORD dwLocalPort;
+  DWORD dwOwningPid;
+  LARGE_INTEGER liCreateTimestamp;
+  union {
+    struct {
+      DWORD SpecificPortBind:1;
+    };
+    DWORD dwFlags;
+  };
+  ULONGLONG OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
+} MIB_UDP6ROW_OWNER_MODULE, *PMIB_UDP6ROW_OWNER_MODULE;
+typedef struct _MIB_UDPTABLE {
+  DWORD dwNumEntries;
+  MIB_UDPROW table[ANY_SIZE];
+} MIB_UDPTABLE, *PMIB_UDPTABLE;
+typedef MIB_UDPTABLE MIB_UDPTABLE_BASIC, *PMIB_UDPTABLE_BASIC;
+#define SIZEOF_UDPTABLE(X) (FIELD_OFFSET(MIB_UDPTABLE, table[0]) + ((X) * sizeof(MIB_UDPROW)) + ALIGN_SIZE)
+#define SIZEOF_UDPTABLE_BASIC(X) SIZEOF_UDPTABLE(X)
+typedef struct _MIB_UDPTABLE_OWNER_PID {
+  DWORD dwNumEntries;
+  MIB_UDPROW_OWNER_PID table[ANY_SIZE];
+} MIB_UDPTABLE_OWNER_PID, *PMIB_UDPTABLE_OWNER_PID;
+#define SIZEOF_UDPTABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_UDPTABLE_OWNER_PID, table[0]) + ((X) * sizeof(MIB_UDPROW_OWNER_PID)) + ALIGN_SIZE)
+typedef struct _MIB_UDPTABLE_OWNER_MODULE {
+  DWORD dwNumEntries;
+  MIB_UDPROW_OWNER_MODULE table[ANY_SIZE];
+} MIB_UDPTABLE_OWNER_MODULE, *PMIB_UDPTABLE_OWNER_MODULE;
+#define SIZEOF_UDPTABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_UDPTABLE_OWNER_MODULE, table[0]) + ((X) * sizeof(MIB_UDPROW_OWNER_MODULE)) + ALIGN_SIZE)
+typedef struct _MIB_UDP6TABLE_OWNER_PID {
+  DWORD dwNumEntries;
+  MIB_UDP6ROW_OWNER_PID table[ANY_SIZE];
+} MIB_UDP6TABLE_OWNER_PID, *PMIB_UDP6TABLE_OWNER_PID;
+#define SIZEOF_UDP6TABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_UDP6TABLE_OWNER_PID, table[0]) + ((X) * sizeof(MIB_UDP6ROW_OWNER_PID)) + ALIGN_SIZE)
+typedef struct _MIB_UDP6TABLE_OWNER_MODULE {
+  DWORD dwNumEntries;
+  MIB_UDP6ROW_OWNER_MODULE table[ANY_SIZE];
+} MIB_UDP6TABLE_OWNER_MODULE, *PMIB_UDP6TABLE_OWNER_MODULE;
+#define SIZEOF_UDP6TABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_UDP6TABLE_OWNER_MODULE, table[0]) + ((X) * sizeof(MIB_UDP6ROW_OWNER_MODULE)) + ALIGN_SIZE)
+typedef struct _MIB_TCPSTATS {
   DWORD dwRtoAlgorithm;
   DWORD dwRtoMin;
   DWORD dwRtoMax;
@@ -177,32 +252,392 @@
   DWORD dwOutRsts;
   DWORD dwNumConns;
 } MIB_TCPSTATS, *PMIB_TCPSTATS;
-typedef struct {
+#define MIB_TCP_RTO_OTHER 1
+#define MIB_TCP_RTO_CONSTANT 2
+#define MIB_TCP_RTO_RSRE 3
+#define MIB_TCP_RTO_VANJ 4
+#define MIB_TCP_MAXCONN_DYNAMIC (DWORD)-1
+typedef struct _MIB_TCPROW {
   DWORD dwState;
   DWORD dwLocalAddr;
   DWORD dwLocalPort;
   DWORD dwRemoteAddr;
   DWORD dwRemotePort;
 } MIB_TCPROW, *PMIB_TCPROW;
-typedef struct {
+typedef MIB_TCPROW MIB_TCPROW_BASIC, *PMIB_TCPROW_BASIC;
+typedef struct _MIB_TCPROW_OWNER_PID {
+  DWORD dwState;
+  DWORD dwLocalAddr;
+  DWORD dwLocalPort;
+  DWORD dwRemoteAddr;
+  DWORD dwRemotePort;
+  DWORD dwOwningPid;
+} MIB_TCPROW_OWNER_PID, *PMIB_TCPROW_OWNER_PID;
+typedef struct _MIB_TCPROW_OWNER_MODULE {
+  DWORD dwState;
+  DWORD dwLocalAddr;
+  DWORD dwLocalPort;
+  DWORD dwRemoteAddr;
+  DWORD dwRemotePort;
+  DWORD dwOwningPid;
+  LARGE_INTEGER liCreateTimestamp;
+  ULONGLONG OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
+} MIB_TCPROW_OWNER_MODULE, *PMIB_TCPROW_OWNER_MODULE;
+typedef struct _MIB_TCP6ROW_OWNER_PID {
+  UCHAR ucLocalAddr[16];
+  DWORD dwLocalScopeId;
+  DWORD dwLocalPort;
+  UCHAR ucRemoteAddr[16];
+  DWORD dwRemoteScopeId;
+  DWORD dwRemotePort;
+  DWORD dwState;
+  DWORD dwOwningPid;
+} MIB_TCP6ROW_OWNER_PID, *PMIB_TCP6ROW_OWNER_PID;
+typedef struct _MIB_TCP6ROW_OWNER_MODULE {
+  UCHAR ucLocalAddr[16];
+  DWORD dwLocalScopeId;
+  DWORD dwLocalPort;
+  UCHAR ucRemoteAddr[16];
+  DWORD dwRemoteScopeId;
+  DWORD dwRemotePort;
+  DWORD dwState;
+  DWORD dwOwningPid;
+  LARGE_INTEGER liCreateTimestamp;
+  ULONGLONG OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
+} MIB_TCP6ROW_OWNER_MODULE, *PMIB_TCP6ROW_OWNER_MODULE;
+#define MIB_TCP_STATE_CLOSED 1
+#define MIB_TCP_STATE_LISTEN 2
+#define MIB_TCP_STATE_SYN_SENT 3
+#define MIB_TCP_STATE_SYN_RCVD 4
+#define MIB_TCP_STATE_ESTAB 5
+#define MIB_TCP_STATE_FIN_WAIT1 6
+#define MIB_TCP_STATE_FIN_WAIT2 7
+#define MIB_TCP_STATE_CLOSE_WAIT 8
+#define MIB_TCP_STATE_CLOSING 9
+#define MIB_TCP_STATE_LAST_ACK 10
+#define MIB_TCP_STATE_TIME_WAIT 11
+#define MIB_TCP_STATE_DELETE_TCB 12
+typedef struct _MIB_TCPTABLE {
   DWORD dwNumEntries;
   MIB_TCPROW table[ANY_SIZE];
 } MIB_TCPTABLE, *PMIB_TCPTABLE;
-typedef struct {
-  DWORD dwInDatagrams;
-  DWORD dwNoPorts;
-  DWORD dwInErrors;
-  DWORD dwOutDatagrams;
-  DWORD dwNumAddrs;
-} MIB_UDPSTATS, *PMIB_UDPSTATS;
-typedef struct {
-  DWORD dwLocalAddr;
-  DWORD dwLocalPort;
-} MIB_UDPROW, *PMIB_UDPROW;
-typedef struct {
+typedef MIB_TCPTABLE MIB_TCPTABLE_BASIC, *PMIB_TCPTABLE_BASIC;
+#define SIZEOF_TCPTABLE(X) (FIELD_OFFSET(MIB_TCPTABLE,table[0]) + ((X) * sizeof(MIB_TCPROW)) + ALIGN_SIZE)
+#define SIZEOF_TCPTABLE_BASIC(X) SIZEOF_TCPTABLE(X)
+typedef struct _MIB_TCPTABLE_OWNER_PID {
   DWORD dwNumEntries;
-  MIB_UDPROW table[ANY_SIZE];
-} MIB_UDPTABLE, *PMIB_UDPTABLE;
+  MIB_TCPROW_OWNER_PID table[ANY_SIZE];
+} MIB_TCPTABLE_OWNER_PID, *PMIB_TCPTABLE_OWNER_PID;
+#define SIZEOF_TCPTABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_TCPTABLE_OWNER_PID, table[0]) + ((X) * sizeof(MIB_TCPROW_OWNER_PID)) + ALIGN_SIZE)
+typedef struct _MIB_TCPTABLE_OWNER_MODULE {
+  DWORD dwNumEntries;
+  MIB_TCPROW_OWNER_MODULE table[ANY_SIZE];
+} MIB_TCPTABLE_OWNER_MODULE, *PMIB_TCPTABLE_OWNER_MODULE;
+#define SIZEOF_TCPTABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_TCPTABLE_OWNER_MODULE, table[0]) + ((X) * sizeof(MIB_TCPROW_OWNER_MODULE)) + ALIGN_SIZE)
+typedef struct _MIB_TCP6TABLE_OWNER_PID {
+  DWORD dwNumEntries;
+  MIB_TCP6ROW_OWNER_PID table[ANY_SIZE];
+} MIB_TCP6TABLE_OWNER_PID, *PMIB_TCP6TABLE_OWNER_PID;
+#define SIZEOF_TCP6TABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_TCP6TABLE_OWNER_PID, table[0]) + ((X) * sizeof(MIB_TCP6ROW_OWNER_PID)) + ALIGN_SIZE)
+typedef struct _MIB_TCP6TABLE_OWNER_MODULE {
+  DWORD dwNumEntries;
+  MIB_TCP6ROW_OWNER_MODULE table[ANY_SIZE];
+} MIB_TCP6TABLE_OWNER_MODULE, *PMIB_TCP6TABLE_OWNER_MODULE;
+#define SIZEOF_TCP6TABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_TCP6TABLE_OWNER_MODULE, table[0]) + ((X) * sizeof(MIB_TCP6ROW_OWNER_PID)) + ALIGN_SIZE)
+#define MIB_SECURITY_TCP_SYN_ATTACK 0x00000001
+#define MIB_USE_CURRENT_TTL ((DWORD)-1)
+#define MIB_USE_CURRENT_FORWARDING ((DWORD)-1)
+typedef struct _MIB_IPSTATS {
+  DWORD dwForwarding;
+  DWORD dwDefaultTTL;
+  DWORD dwInReceives;
+  DWORD dwInHdrErrors;
+  DWORD dwInAddrErrors;
+  DWORD dwForwDatagrams;
+  DWORD dwInUnknownProtos;
+  DWORD dwInDiscards;
+  DWORD dwInDelivers;
+  DWORD dwOutRequests;
+  DWORD dwRoutingDiscards;
+  DWORD dwOutDiscards;
+  DWORD dwOutNoRoutes;
+  DWORD dwReasmTimeout;
+  DWORD dwReasmReqds;
+  DWORD dwReasmOks;
+  DWORD dwReasmFails;
+  DWORD dwFragOks;
+  DWORD dwFragFails;
+  DWORD dwFragCreates;
+  DWORD dwNumIf;
+  DWORD dwNumAddr;
+  DWORD dwNumRoutes;
+} MIB_IPSTATS, *PMIB_IPSTATS;
+#define MIB_IP_FORWARDING 1
+#define MIB_IP_NOT_FORWARDING 2
+#define MIB_IPADDR_PRIMARY 0x0001
+#define MIB_IPADDR_DYNAMIC 0x0004
+#define MIB_IPADDR_DISCONNECTED 0x0008
+#define MIB_IPADDR_DELETED 0x0040
+#define MIB_IPADDR_TRANSIENT 0x0080
+typedef struct _MIB_IPADDRROW {
+  DWORD dwAddr;
+  DWORD dwIndex;
+  DWORD dwMask;
+  DWORD dwBCastAddr;
+  DWORD dwReasmSize;
+  unsigned short unused1;
+  unsigned short wType;
+} MIB_IPADDRROW, *PMIB_IPADDRROW;
+typedef struct _MIB_IPADDRTABLE {
+  DWORD dwNumEntries;
+  MIB_IPADDRROW table[ANY_SIZE];
+} MIB_IPADDRTABLE, *PMIB_IPADDRTABLE;
+#define SIZEOF_IPADDRTABLE(X) (FIELD_OFFSET(MIB_IPADDRTABLE,table[0]) + ((X) * sizeof(MIB_IPADDRROW)) + ALIGN_SIZE)
+typedef struct _MIB_IPFORWARDNUMBER {
+  DWORD dwValue;
+} MIB_IPFORWARDNUMBER, *PMIB_IPFORWARDNUMBER;
+typedef struct _MIB_IPFORWARDROW {
+  DWORD dwForwardDest;
+  DWORD dwForwardMask;
+  DWORD dwForwardPolicy;
+  DWORD dwForwardNextHop;
+  DWORD dwForwardIfIndex;
+  DWORD dwForwardType;
+  DWORD dwForwardProto;
+  DWORD dwForwardAge;
+  DWORD dwForwardNextHopAS;
+  DWORD dwForwardMetric1;
+  DWORD dwForwardMetric2;
+  DWORD dwForwardMetric3;
+  DWORD dwForwardMetric4;
+  DWORD dwForwardMetric5;
+} MIB_IPFORWARDROW, *PMIB_IPFORWARDROW;
+#define MIB_IPROUTE_TYPE_OTHER 1
+#define MIB_IPROUTE_TYPE_INVALID 2
+#define MIB_IPROUTE_TYPE_DIRECT 3
+#define MIB_IPROUTE_TYPE_INDIRECT 4
+#define MIB_IPROUTE_METRIC_UNUSED (DWORD)-1
+#define MIB_IPPROTO_OTHER 1
+#define MIB_IPPROTO_LOCAL 2
+#define MIB_IPPROTO_NETMGMT 3
+#define MIB_IPPROTO_ICMP 4
+#define MIB_IPPROTO_EGP 5
+#define MIB_IPPROTO_GGP 6
+#define MIB_IPPROTO_HELLO 7
+#define MIB_IPPROTO_RIP 8
+#define MIB_IPPROTO_IS_IS 9
+#define MIB_IPPROTO_ES_IS 10
+#define MIB_IPPROTO_CISCO 11
+#define MIB_IPPROTO_BBN 12
+#define MIB_IPPROTO_OSPF 13
+#define MIB_IPPROTO_BGP 14
+#define MIB_IPPROTO_NT_AUTOSTATIC 10002
+#define MIB_IPPROTO_NT_STATIC 10006
+#define MIB_IPPROTO_NT_STATIC_NON_DOD 10007
+typedef struct _MIB_IPFORWARDTABLE {
+  DWORD dwNumEntries;
+  MIB_IPFORWARDROW table[ANY_SIZE];
+} MIB_IPFORWARDTABLE, *PMIB_IPFORWARDTABLE;
+#define SIZEOF_IPFORWARDTABLE(X) (FIELD_OFFSET(MIB_IPFORWARDTABLE,table[0]) + ((X) * sizeof(MIB_IPFORWARDROW)) + ALIGN_SIZE)
+typedef struct _MIB_IPNETROW {
+  DWORD dwIndex;
+  DWORD dwPhysAddrLen;
+  BYTE bPhysAddr[MAXLEN_PHYSADDR];
+  DWORD dwAddr;
+  DWORD dwType;
+} MIB_IPNETROW, *PMIB_IPNETROW;
+#define MIB_IPNET_TYPE_OTHER 1
+#define MIB_IPNET_TYPE_INVALID 2
+#define MIB_IPNET_TYPE_DYNAMIC 3
+#define MIB_IPNET_TYPE_STATIC 4
+typedef struct _MIB_IPNETTABLE {
+  DWORD dwNumEntries;
+  MIB_IPNETROW table[ANY_SIZE];
+} MIB_IPNETTABLE, *PMIB_IPNETTABLE;
+#define SIZEOF_IPNETTABLE(X) (FIELD_OFFSET(MIB_IPNETTABLE, table[0]) + ((X) * sizeof(MIB_IPNETROW)) + ALIGN_SIZE)
+typedef struct _MIB_IPMCAST_OIF {
+  DWORD dwOutIfIndex;
+  DWORD dwNextHopAddr;
+  DWORD dwReserved;
+  DWORD dwReserved1;
+} MIB_IPMCAST_OIF, *PMIB_IPMCAST_OIF;
+typedef struct _MIB_IPMCAST_MFE {
+  DWORD dwGroup;
+  DWORD dwSource;
+  DWORD dwSrcMask;
+  DWORD dwUpStrmNgbr;
+  DWORD dwInIfIndex;
+  DWORD dwInIfProtocol;
+  DWORD dwRouteProtocol;
+  DWORD dwRouteNetwork;
+  DWORD dwRouteMask;
+  ULONG ulUpTime;
+  ULONG ulExpiryTime;
+  ULONG ulTimeOut;
+  ULONG ulNumOutIf;
+  DWORD fFlags;
+  DWORD dwReserved;
+  MIB_IPMCAST_OIF rgmioOutInfo[ANY_SIZE];
+} MIB_IPMCAST_MFE, *PMIB_IPMCAST_MFE;
+typedef struct _MIB_MFE_TABLE {
+  DWORD dwNumEntries;
+  MIB_IPMCAST_MFE table[ANY_SIZE];
+} MIB_MFE_TABLE, *PMIB_MFE_TABLE;
+#define SIZEOF_BASIC_MIB_MFE (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE, rgmioOutInfo[0]))
+#define SIZEOF_MIB_MFE(X) (SIZEOF_BASIC_MIB_MFE + ((X) * sizeof(MIB_IPMCAST_OIF)))
+typedef struct _MIB_IPMCAST_OIF_STATS {
+  DWORD dwOutIfIndex;
+  DWORD dwNextHopAddr;
+  DWORD dwDialContext;
+  ULONG ulTtlTooLow;
+  ULONG ulFragNeeded;
+  ULONG ulOutPackets;
+  ULONG ulOutDiscards;
+} MIB_IPMCAST_OIF_STATS, *PMIB_IPMCAST_OIF_STATS;
+typedef struct _MIB_IPMCAST_MFE_STATS {
+  DWORD dwGroup;
+  DWORD dwSource;
+  DWORD dwSrcMask;
+  DWORD dwUpStrmNgbr;
+  DWORD dwInIfIndex;
+  DWORD dwInIfProtocol;
+  DWORD dwRouteProtocol;
+  DWORD dwRouteNetwork;
+  DWORD dwRouteMask;
+  ULONG ulUpTime;
+  ULONG ulExpiryTime;
+  ULONG ulNumOutIf;
+  ULONG ulInPkts;
+  ULONG ulInOctets;
+  ULONG ulPktsDifferentIf;
+  ULONG ulQueueOverflow;
+  MIB_IPMCAST_OIF_STATS rgmiosOutStats[ANY_SIZE];
+} MIB_IPMCAST_MFE_STATS, *PMIB_IPMCAST_MFE_STATS;
+typedef struct _MIB_MFE_STATS_TABLE {
+  DWORD dwNumEntries;
+  MIB_IPMCAST_MFE_STATS table[ANY_SIZE];
+} MIB_MFE_STATS_TABLE, *PMIB_MFE_STATS_TABLE;
+#define SIZEOF_BASIC_MIB_MFE_STATS (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE_STATS, rgmiosOutStats[0]))
+#define SIZEOF_MIB_MFE_STATS(X) (SIZEOF_BASIC_MIB_MFE_STATS + ((X) * sizeof(MIB_IPMCAST_OIF_STATS)))
+typedef struct _MIB_IPMCAST_MFE_STATS_EX {
+  DWORD dwGroup;
+  DWORD dwSource;
+  DWORD dwSrcMask;
+  DWORD dwUpStrmNgbr;
+  DWORD dwInIfIndex;
+  DWORD dwInIfProtocol;
+  DWORD dwRouteProtocol;
+  DWORD dwRouteNetwork;
+  DWORD dwRouteMask;
+  ULONG ulUpTime;
+  ULONG ulExpiryTime;
+  ULONG ulNumOutIf;
+  ULONG ulInPkts;
+  ULONG ulInOctets;
+  ULONG ulPktsDifferentIf;
+  ULONG ulQueueOverflow;
+  ULONG ulUninitMfe;
+  ULONG ulNegativeMfe;
+  ULONG ulInDiscards;
+  ULONG ulInHdrErrors;
+  ULONG ulTotalOutPackets;
+  MIB_IPMCAST_OIF_STATS rgmiosOutStats[ANY_SIZE];
+} MIB_IPMCAST_MFE_STATS_EX, *PMIB_IPMCAST_MFE_STATS_EX;
+typedef struct _MIB_MFE_STATS_TABLE_EX {
+  DWORD dwNumEntries;
+  MIB_IPMCAST_MFE_STATS_EX table[ANY_SIZE];
+} MIB_MFE_STATS_TABLE_EX, *PMIB_MFE_STATS_TABLE_EX;
+#define SIZEOF_BASIC_MIB_MFE_STATS_EX (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE_STATS_EX, rgmiosOutStats[0]))
+#define SIZEOF_MIB_MFE_STATS_EX(X) (SIZEOF_BASIC_MIB_MFE_STATS_EX + ((X) * sizeof(MIB_IPMCAST_OIF_STATS)))
+typedef struct _MIB_IPMCAST_GLOBAL {
+  DWORD dwEnable;
+} MIB_IPMCAST_GLOBAL, *PMIB_IPMCAST_GLOBAL;
+typedef struct _MIB_IPMCAST_IF_ENTRY {
+  DWORD dwIfIndex;
+  DWORD dwTtl;
+  DWORD dwProtocol;
+  DWORD dwRateLimit;
+  ULONG ulInMcastOctets;
+  ULONG ulOutMcastOctets;
+} MIB_IPMCAST_IF_ENTRY, *PMIB_IPMCAST_IF_ENTRY;
+typedef struct _MIB_IPMCAST_IF_TABLE {
+  DWORD dwNumEntries;
+  MIB_IPMCAST_IF_ENTRY table[ANY_SIZE];
+} MIB_IPMCAST_IF_TABLE, *PMIB_IPMCAST_IF_TABLE;
+#define SIZEOF_MCAST_IF_TABLE(X) (FIELD_OFFSET(MIB_IPMCAST_IF_TABLE,table[0]) + ((X) * sizeof(MIB_IPMCAST_IF_ENTRY)) + ALIGN_SIZE)
+typedef struct _MIB_IPMCAST_BOUNDARY {
+  DWORD dwIfIndex;
+  DWORD dwGroupAddress;
+  DWORD dwGroupMask;
+  DWORD dwStatus;
+} MIB_IPMCAST_BOUNDARY, *PMIB_IPMCAST_BOUNDARY;
+typedef struct _MIB_IPMCAST_BOUNDARY_TABLE {
+  DWORD dwNumEntries;
+  MIB_IPMCAST_BOUNDARY table[ANY_SIZE];
+} MIB_IPMCAST_BOUNDARY_TABLE, *PMIB_IPMCAST_BOUNDARY_TABLE;
+#define SIZEOF_BOUNDARY_TABLE(X) (FIELD_OFFSET(MIB_IPMCAST_BOUNDARY_TABLE,table[0]) + ((X) * sizeof(MIB_IPMCAST_BOUNDARY)) + ALIGN_SIZE)
+typedef struct {
+  DWORD dwGroupAddress;
+  DWORD dwGroupMask;
+} MIB_BOUNDARYROW, *PMIB_BOUNDARYROW;
+typedef struct {
+  DWORD dwTtl;
+  DWORD dwRateLimit;
+} MIB_MCAST_LIMIT_ROW, *PMIB_MCAST_LIMIT_ROW;
+#define MAX_SCOPE_NAME_LEN 255
+#define SN_UNICODE
+typedef WCHAR SN_CHAR;
+typedef SN_CHAR SCOPE_NAME_BUFFER[MAX_SCOPE_NAME_LEN + 1], *SCOPE_NAME;
+typedef struct _MIB_IPMCAST_SCOPE {
+  DWORD dwGroupAddress;
+  DWORD dwGroupMask;
+  SCOPE_NAME_BUFFER snNameBuffer;
+  DWORD dwStatus;
+} MIB_IPMCAST_SCOPE, *PMIB_IPMCAST_SCOPE;
+typedef struct _MIB_IPDESTROW {
+#ifdef __cplusplus
+  MIB_IPFORWARDROW ForwardRow;
+#else
+    MIB_IPFORWARDROW;
+#endif
+  DWORD dwForwardPreference;
+  DWORD dwForwardViewSet;
+} MIB_IPDESTROW, *PMIB_IPDESTROW;
+typedef struct _MIB_IPDESTTABLE {
+  DWORD dwNumEntries;
+  MIB_IPDESTROW table[ANY_SIZE];
+} MIB_IPDESTTABLE, *PMIB_IPDESTTABLE;
+typedef struct _MIB_BEST_IF {
+  DWORD dwDestAddr;
+  DWORD dwIfIndex;
+} MIB_BEST_IF, *PMIB_BEST_IF;
+typedef struct _MIB_PROXYARP {
+  DWORD dwAddress;
+  DWORD dwMask;
+  DWORD dwIfIndex;
+} MIB_PROXYARP, *PMIB_PROXYARP;
+typedef struct _MIB_IFSTATUS {
+  DWORD dwIfIndex;
+  DWORD dwAdminStatus;
+  DWORD dwOperationalStatus;
+  BOOL bMHbeatActive;
+  BOOL bMHbeatAlive;
+} MIB_IFSTATUS, *PMIB_IFSTATUS;
+typedef struct _MIB_ROUTESTATE {
+  BOOL bRoutesSetToStack;
+} MIB_ROUTESTATE, *PMIB_ROUTESTATE;
+typedef struct _MIB_OPAQUE_INFO {
+  DWORD dwId;
+  union {
+    ULONGLONG ullAlign;
+    BYTE rgbyData[1];
+  };
+} MIB_OPAQUE_INFO, *PMIB_OPAQUE_INFO;
+#define MAX_MIB_OFFSET 8
+#define MIB_INFO_SIZE(S) (MAX_MIB_OFFSET + sizeof(S))
+#define MIB_INFO_SIZE_IN_DWORDS(S) ((MIB_INFO_SIZE(S))/sizeof(DWORD) + 1)
+#define DEFINE_MIB_BUFFER(X,Y,Z) DWORD __rgdwBuff[MIB_INFO_SIZE_IN_DWORDS(Y)]; PMIB_OPAQUE_INFO X = (PMIB_OPAQUE_INFO)__rgdwBuff; Y * Z = (Y *)(X->rgbyData)
+#define CAST_MIB_INFO(X,Y,Z) Z = (Y)(X->rgbyData)
 #ifdef __cplusplus
 }
 #endif
diff -uNr w32api-3.5/include/iptypes.h w32api-3.5-xorp/include/iptypes.h
--- w32api-3.5/include/iptypes.h	Tue Apr  9 22:17:17 2002
+++ w32api-3.5-xorp/include/iptypes.h	Wed Dec  7 15:51:18 2005
@@ -71,6 +71,150 @@
   UINT EnableProxy;
   UINT EnableDns;
 } FIXED_INFO, *PFIXED_INFO;
+typedef enum {
+  IpPrefixOriginOther = 0,
+  IpPrefixOriginManual,
+  IpPrefixOriginWellKnown,
+  IpPrefixOriginDhcp,
+  IpPrefixOriginRouterAdvertisement,
+} IP_PREFIX_ORIGIN;
+typedef enum {
+  IpSuffixOriginOther = 0,
+  IpSuffixOriginManual,
+  IpSuffixOriginWellKnown,
+  IpSuffixOriginDhcp,
+  IpSuffixOriginLinkLayerAddress,
+  IpSuffixOriginRandom,
+} IP_SUFFIX_ORIGIN;
+typedef enum {
+  IpDadStateInvalid = 0,
+  IpDadStateTentative,
+  IpDadStateDuplicate,
+  IpDadStateDeprecated,
+  IpDadStatePreferred,
+} IP_DAD_STATE;
+#define IP_ADAPTER_DDNS_ENABLED 0x01
+#define IP_ADAPTER_REGISTER_ADAPTER_SUFFIX 0x02
+#define IP_ADAPTER_DHCP_ENABLED 0x04
+#define IP_ADAPTER_RECEIVE_ONLY 0x08
+#define IP_ADAPTER_NO_MULTICAST 0x10
+#define IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG 0x20
+typedef enum {
+  IfOperStatusUp = 1,
+  IfOperStatusDown,
+  IfOperStatusTesting,
+  IfOperStatusUnknown,
+  IfOperStatusDormant,
+  IfOperStatusNotPresent,
+  IfOperStatusLowerLayerDown
+} IF_OPER_STATUS;
+typedef enum {
+  ScopeLevelInterface = 1,
+  ScopeLevelLink = 2,
+  ScopeLevelSubnet = 3,
+  ScopeLevelAdmin = 4,
+  ScopeLevelSite = 5,
+  ScopeLevelOrganization = 8,
+  ScopeLevelGlobal = 14
+} SCOPE_LEVEL;
+typedef struct _IP_ADAPTER_UNICAST_ADDRESS {
+  union {
+    ULONGLONG Alignment;
+    struct {
+	ULONG Length;
+	DWORD Flags;
+    };
+  };
+  struct _IP_ADAPTER_UNICAST_ADDRESS* Next;
+  SOCKET_ADDRESS Address;
+  IP_PREFIX_ORIGIN PrefixOrigin;
+  IP_SUFFIX_ORIGIN SuffixOrigin;
+  IP_DAD_STATE DadState;
+  ULONG ValidLifetime;
+  ULONG PreferredLifetime;
+  ULONG LeaseLifetime;
+} IP_ADAPTER_UNICAST_ADDRESS, *PIP_ADAPTER_UNICAST_ADDRESS;
+typedef struct _IP_ADAPTER_ANYCAST_ADDRESS {
+  union {
+    ULONGLONG Alignment;
+    struct {
+	ULONG Length;
+	DWORD Flags;
+    };
+  };
+  struct _IP_ADAPTER_ANYCAST_ADDRESS* Next;
+  SOCKET_ADDRESS Address;
+} IP_ADAPTER_ANYCAST_ADDRESS, *PIP_ADAPTER_ANYCAST_ADDRESS;
+typedef struct _IP_ADAPTER_MULTICAST_ADDRESS {
+  union {
+    ULONGLONG Alignment;
+    struct {
+	ULONG Length;
+	DWORD Flags;
+    };
+  };
+  struct _IP_ADAPTER_MULTICAST_ADDRESS* Next;
+  SOCKET_ADDRESS Address;
+} IP_ADAPTER_MULTICAST_ADDRESS, *PIP_ADAPTER_MULTICAST_ADDRESS;
+typedef struct _IP_ADAPTER_DNS_SERVER_ADDRESS {
+  union {
+    ULONGLONG Alignment;
+    struct {
+	ULONG Length;
+	DWORD Reserved;
+    };
+  };
+  struct _IP_ADAPTER_DNS_SERVER_ADDRESS* Next;
+  SOCKET_ADDRESS Address;
+} IP_ADAPTER_DNS_SERVER_ADDRESS, *PIP_ADAPTER_DNS_SERVER_ADDRESS;
+typedef struct _IP_ADAPTER_PREFIX {
+  union {
+    ULONGLONG Alignment;
+    struct {
+	ULONG Length;
+	DWORD Flags;
+    };
+  };
+  struct _IP_ADAPTER_PREFIX* Next;
+  SOCKET_ADDRESS Address;
+  ULONG PrefixLength;
+} IP_ADAPTER_PREFIX, *PIP_ADAPTER_PREFIX;
+typedef struct _IP_ADAPTER_ADDRESSES {
+  union {
+    ULONGLONG Alignment;
+    struct {
+	ULONG Length;
+	DWORD IfIndex;
+    };
+  };
+  struct _IP_ADAPTER_ADDRESSES* Next;
+  PCHAR AdapterName;
+  PIP_ADAPTER_UNICAST_ADDRESS FirstUnicastAddress;
+  PIP_ADAPTER_ANYCAST_ADDRESS FirstAnycastAddress;
+  PIP_ADAPTER_MULTICAST_ADDRESS FirstMulticastAddress;
+  PIP_ADAPTER_DNS_SERVER_ADDRESS FirstDnsServerAddress;
+  PWCHAR DnsSuffix;
+  PWCHAR Description;
+  PWCHAR FriendlyName;
+  BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];
+  DWORD PhysicalAddressLength;
+  DWORD Flags;
+  DWORD Mtu;
+  DWORD IfType;
+  IF_OPER_STATUS OperStatus;
+  DWORD Ipv6IfIndex;
+  DWORD ZoneIndices[16];
+  PIP_ADAPTER_PREFIX FirstPrefix;
+} IP_ADAPTER_ADDRESSES, *PIP_ADAPTER_ADDRESSES;
+#define IP_ADAPTER_ADDRESS_DNS_ELIGIBLE 0x01
+#define IP_ADAPTER_ADDRESS_TRANSIENT 0x02
+#define IP_ADAPTER_ADDRESS_PRIMARY 0x04
+#define GAA_FLAG_SKIP_UNICAST 0x0001
+#define GAA_FLAG_SKIP_ANYCAST 0x0002
+#define GAA_FLAG_SKIP_MULTICAST 0x0004
+#define GAA_FLAG_SKIP_DNS_SERVER 0x0008
+#define GAA_FLAG_INCLUDE_PREFIX 0x0010
+#define GAA_FLAG_SKIP_FRIENDLY_NAME 0x0020
 
 #ifdef __cplusplus
 }
diff -uNr w32api-3.5/include/mgm.h w32api-3.5-xorp/include/mgm.h
--- w32api-3.5/include/mgm.h	Wed Dec  7 15:42:20 2005
+++ w32api-3.5-xorp/include/mgm.h	Wed Dec  7 15:45:49 2005
@@ -0,0 +1,65 @@
+#ifndef _MGM_H_
+#define _MGM_H_
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+typedef struct _MGM_IF_ENTRY
+{
+  DWORD dwIfIndex;
+  DWORD dwIfNextHopAddr;
+  BOOL bIGMP;
+  BOOL bIsEnabled;
+} MGM_IF_ENTRY, *PMGM_IF_ENTRY;
+typedef DWORD (*PMGM_RPF_CALLBACK) (IN DWORD dwSourceAddr, IN DWORD dwSourceMask, IN DWORD dwGroupAddr, IN DWORD dwGroupMask, IN OUT PDWORD pdwInIfIndex, IN OUT PDWORD pdwInIfNextHopAddr, IN OUT PDWORD pdwUpStreamNbr, IN DWORD dwHdrSize, IN PBYTE pbPacketHdr, IN OUT PBYTE pbRoute);
+typedef DWORD (*PMGM_CREATION_ALERT_CALLBACK) (IN DWORD dwSourceAddr, IN DWORD dwSourceMask, IN DWORD dwGroupAddr, IN DWORD dwGroupMask, IN DWORD dwInIfIndex, IN DWORD dwInIfNextHopAddr, IN DWORD dwIfCount, IN OUT PMGM_IF_ENTRY pmieOutIfList);
+typedef DWORD (*PMGM_PRUNE_ALERT_CALLBACK) (IN DWORD dwSourceAddr, IN DWORD dwSourceMask, IN DWORD dwGroupAddr, IN DWORD dwGroupMask, IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr, IN BOOL bMemberDelete, IN OUT PDWORD pdwTimeout);
+typedef DWORD (*PMGM_JOIN_ALERT_CALLBACK) (IN DWORD dwSourceAddr, IN DWORD dwSourceMask, IN DWORD dwGroupAddr, IN DWORD dwGroupMask, IN BOOL bMemberUpdate);
+typedef DWORD (*PMGM_WRONG_IF_CALLBACK) (IN DWORD dwSourceAddr, IN DWORD dwGroupAddr, IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr, IN DWORD dwHdrSize, IN PBYTE pbPacketHdr);
+typedef DWORD (*PMGM_LOCAL_JOIN_CALLBACK) (IN DWORD dwSourceAddr, IN DWORD dwSourceMask, IN DWORD dwGroupAddr, IN DWORD dwGroupMask, IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr);
+typedef DWORD (*PMGM_LOCAL_LEAVE_CALLBACK) (IN DWORD dwSourceAddr, IN DWORD dwSourceMask, IN DWORD dwGroupAddr, IN DWORD dwGroupMask, IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr);
+typedef DWORD (*PMGM_DISABLE_IGMP_CALLBACK) (IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr);
+typedef DWORD (*PMGM_ENABLE_IGMP_CALLBACK) (IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr);
+typedef struct _ROUTING_PROTOCOL_CONFIG
+{
+  DWORD dwCallbackFlags;
+  PMGM_RPF_CALLBACK pfnRpfCallback;
+  PMGM_CREATION_ALERT_CALLBACK pfnCreationAlertCallback;
+  PMGM_PRUNE_ALERT_CALLBACK pfnPruneAlertCallback;
+  PMGM_JOIN_ALERT_CALLBACK pfnJoinAlertCallback;
+  PMGM_WRONG_IF_CALLBACK pfnWrongIfCallback;
+  PMGM_LOCAL_JOIN_CALLBACK pfnLocalJoinCallback;
+  PMGM_LOCAL_LEAVE_CALLBACK pfnLocalLeaveCallback;
+  PMGM_DISABLE_IGMP_CALLBACK pfnDisableIgmpCallback;
+  PMGM_ENABLE_IGMP_CALLBACK pfnEnableIgmpCallback;
+} ROUTING_PROTOCOL_CONFIG, *PROUTING_PROTOCOL_CONFIG;
+typedef enum _MGM_ENUM_TYPES
+{ ANY_SOURCE = 0, ALL_SOURCES } MGM_ENUM_TYPES;
+typedef struct _SOURCE_GROUP_ENTRY
+{
+  DWORD dwSourceAddr;
+  DWORD dwSourceMask;
+  DWORD dwGroupAddr;
+  DWORD dwGroupMask;
+} SOURCE_GROUP_ENTRY, *PSOURCE_GROUP_ENTRY;
+DWORD MgmRegisterMProtocol (IN PROUTING_PROTOCOL_CONFIG prpiInfo, IN DWORD dwProtocolId, IN DWORD dwComponentId, OUT HANDLE * phProtocol);
+DWORD MgmDeRegisterMProtocol (IN HANDLE hProtocol);
+DWORD MgmTakeInterfaceOwnership (IN HANDLE hProtocol, IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr);
+DWORD MgmReleaseInterfaceOwnership (IN HANDLE hProtocol, IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr);
+DWORD MgmGetProtocolOnInterface (IN DWORD dwIfIndex, IN DWORD dwIfNextHopAddr, IN OUT PDWORD pdwIfProtocolId, IN OUT PDWORD pdwIfComponentId);
+#define MGM_JOIN_STATE_FLAG 0x00000001
+#define MGM_FORWARD_STATE_FLAG 0x00000002
+DWORD MgmAddGroupMembershipEntry (IN HANDLE hProtocol, IN DWORD dwSourceAddr, IN DWORD dwSourceMask, IN DWORD dwGroupAddr, IN DWORD dwGroupMask, IN DWORD dwIfIndex, IN DWORD dwIfNextHopIPAddr, IN DWORD dwFlags);
+DWORD MgmDeleteGroupMembershipEntry (IN HANDLE hProtocol, IN DWORD dwSourceAddr, IN DWORD dwSourceMask, IN DWORD dwGroupAddr, IN DWORD dwGroupMask, IN DWORD dwIfIndex, IN DWORD dwIfNextHopIPAddr, IN DWORD dwFlags);
+DWORD MgmGetMfe (IN PMIB_IPMCAST_MFE pimm, IN OUT PDWORD pdwBufferSize, IN OUT PBYTE pbBuffer);
+DWORD MgmGetFirstMfe (IN OUT PDWORD pdwBufferSize, IN OUT PBYTE pbBuffer, IN OUT PDWORD pdwNumEntries);
+DWORD MgmGetNextMfe (IN PMIB_IPMCAST_MFE pimmStart, IN OUT PDWORD pdwBufferSize, IN OUT PBYTE pbBuffer, IN OUT PDWORD pdwNumEntries);
+#define MGM_MFE_STATS_0 0x00000001
+#define MGM_MFE_STATS_1 0x00000002
+DWORD MgmGetMfeStats (IN PMIB_IPMCAST_MFE pimm, IN OUT PDWORD pdwBufferSize, IN OUT PBYTE pbBuffer, IN DWORD dwFlags);
+DWORD MgmGetFirstMfeStats (IN OUT PDWORD pdwBufferSize, IN OUT PBYTE pbBuffer, IN OUT PDWORD pdwNumEntries, IN DWORD dwFlags);
+DWORD MgmGetNextMfeStats (IN PMIB_IPMCAST_MFE pimmStart, IN OUT PDWORD pdwBufferSize, IN OUT PBYTE pbBuffer, IN OUT PDWORD pdwNumEntries, IN DWORD dwFlags);
+DWORD MgmGroupEnumerationStart (IN HANDLE hProtocol, IN MGM_ENUM_TYPES metEnumType, OUT HANDLE * phEnumHandle);
+DWORD MgmGroupEnumerationGetNext (IN HANDLE hEnum, IN OUT PDWORD pdwBufferSize, IN OUT PBYTE pbBuffer, IN OUT PDWORD pdwNumEntries);
+DWORD MgmGroupEnumerationEnd (IN HANDLE hEnum);
+DWORD MgmSetMfe (IN HANDLE hProtocol, IN PMIB_IPMCAST_MFE pmimm);
+#endif
diff -uNr w32api-3.5/include/mprapi.h w32api-3.5-xorp/include/mprapi.h
--- w32api-3.5/include/mprapi.h	Wed Dec  7 15:42:37 2005
+++ w32api-3.5-xorp/include/mprapi.h	Wed Dec  7 15:45:49 2005
@@ -0,0 +1,560 @@
+#ifndef _MPRADMIN_H
+#define _MPRADMIN_H
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+#include <lmcons.h>
+#include <ras.h>
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#define RRAS_SERVICE_NAME TEXT("RemoteAccess")
+#define PID_IPX 0x0000002B
+#define PID_IP 0x00000021
+#define PID_NBF 0x0000003F
+#define PID_ATALK 0x00000029
+#define MAX_INTERFACE_NAME_LEN 256
+#define MAX_TRANSPORT_NAME_LEN 40
+#define MAX_MEDIA_NAME 16
+#define MAX_PORT_NAME 16
+#define MAX_DEVICE_NAME 128
+#define MAX_PHONE_NUMBER_LEN 128
+#define MAX_DEVICETYPE_NAME 16
+  typedef enum _ROUTER_INTERFACE_TYPE
+  { ROUTER_IF_TYPE_CLIENT, ROUTER_IF_TYPE_HOME_ROUTER, ROUTER_IF_TYPE_FULL_ROUTER, ROUTER_IF_TYPE_DEDICATED, ROUTER_IF_TYPE_INTERNAL, ROUTER_IF_TYPE_LOOPBACK, ROUTER_IF_TYPE_TUNNEL1, ROUTER_IF_TYPE_DIALOUT } ROUTER_INTERFACE_TYPE;
+  typedef enum _ROUTER_CONNECTION_STATE
+  { ROUTER_IF_STATE_UNREACHABLE, ROUTER_IF_STATE_DISCONNECTED, ROUTER_IF_STATE_CONNECTING, ROUTER_IF_STATE_CONNECTED } ROUTER_CONNECTION_STATE;
+#define MPR_INTERFACE_OUT_OF_RESOURCES 0x00000001
+#define MPR_INTERFACE_ADMIN_DISABLED 0x00000002
+#define MPR_INTERFACE_CONNECTION_FAILURE 0x00000004
+#define MPR_INTERFACE_SERVICE_PAUSED 0x00000008
+#define MPR_INTERFACE_DIALOUT_HOURS_RESTRICTION 0x00000010
+#define MPR_INTERFACE_NO_MEDIA_SENSE 0x00000020
+#define MPR_INTERFACE_NO_DEVICE 0x00000040
+  typedef struct _MPR_INTERFACE_0
+  {
+    IN OUT WCHAR wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
+    OUT HANDLE hInterface;
+    IN OUT BOOL fEnabled;
+    IN OUT ROUTER_INTERFACE_TYPE dwIfType;
+    OUT ROUTER_CONNECTION_STATE dwConnectionState;
+    OUT DWORD fUnReachabilityReasons;
+    OUT DWORD dwLastError;
+  } MPR_INTERFACE_0, *PMPR_INTERFACE_0;
+  typedef struct _MPR_IPINIP_INTERFACE_0
+  {
+    WCHAR wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
+    GUID Guid;
+  } MPR_IPINIP_INTERFACE_0, *PMPR_IPINIP_INTERFACE_0;
+#if(WINVER >= 0x0500)
+  typedef struct _MPR_INTERFACE_1
+  {
+    IN OUT WCHAR wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
+    OUT HANDLE hInterface;
+    IN OUT BOOL fEnabled;
+    IN OUT ROUTER_INTERFACE_TYPE dwIfType;
+    OUT ROUTER_CONNECTION_STATE dwConnectionState;
+    OUT DWORD fUnReachabilityReasons;
+    OUT DWORD dwLastError;
+    OUT LPWSTR lpwsDialoutHoursRestriction;
+  } MPR_INTERFACE_1, *PMPR_INTERFACE_1;
+#define MPR_MaxDeviceType RAS_MaxDeviceType
+#define MPR_MaxPhoneNumber RAS_MaxPhoneNumber
+#define MPR_MaxIpAddress RAS_MaxIpAddress
+#define MPR_MaxIpxAddress RAS_MaxIpxAddress
+#define MPR_MaxEntryName RAS_MaxEntryName
+#define MPR_MaxDeviceName RAS_MaxDeviceName
+#define MPR_MaxCallbackNumber RAS_MaxCallbackNumber
+#define MPR_MaxAreaCode RAS_MaxAreaCode
+#define MPR_MaxPadType RAS_MaxPadType
+#define MPR_MaxX25Address RAS_MaxX25Address
+#define MPR_MaxFacilities RAS_MaxFacilities
+#define MPR_MaxUserData RAS_MaxUserData
+#define MPRIO_SpecificIpAddr RASEO_SpecificIpAddr
+#define MPRIO_SpecificNameServers RASEO_SpecificNameServers
+#define MPRIO_IpHeaderCompression RASEO_IpHeaderCompression
+#define MPRIO_RemoteDefaultGateway RASEO_RemoteDefaultGateway
+#define MPRIO_DisableLcpExtensions RASEO_DisableLcpExtensions
+#define MPRIO_SwCompression RASEO_SwCompression
+#define MPRIO_RequireEncryptedPw RASEO_RequireEncryptedPw
+#define MPRIO_RequireMsEncryptedPw RASEO_RequireMsEncryptedPw
+#define MPRIO_RequireDataEncryption RASEO_RequireDataEncryption
+#define MPRIO_NetworkLogon RASEO_NetworkLogon
+#define MPRIO_PromoteAlternates RASEO_PromoteAlternates
+#define MPRIO_SecureLocalFiles RASEO_SecureLocalFiles
+#define MPRIO_RequireEAP RASEO_RequireEAP
+#define MPRIO_RequirePAP RASEO_RequirePAP
+#define MPRIO_RequireSPAP RASEO_RequireSPAP
+#define MPRIO_SharedPhoneNumbers RASEO_SharedPhoneNumbers
+#define MPRIO_RequireCHAP RASEO_RequireCHAP
+#define MPRIO_RequireMsCHAP RASEO_RequireMsCHAP
+#define MPRIO_RequireMsCHAP2 RASEO_RequireMsCHAP2
+#if (WINVER >= 0x501)
+#define MPRIO_IpSecPreSharedKey 0x80000000
+#endif
+#define MPRNP_Ipx RASNP_Ipx
+#define MPRNP_Ip RASNP_Ip
+#define MPRDT_Modem RASDT_Modem
+#define MPRDT_Isdn RASDT_Isdn
+#define MPRDT_X25 RASDT_X25
+#define MPRDT_Vpn RASDT_Vpn
+#define MPRDT_Pad RASDT_Pad
+#define MPRDT_Generic RASDT_Generic
+#define MPRDT_Serial	RASDT_Serial
+#define MPRDT_FrameRelay RASDT_FrameRelay
+#define MPRDT_Atm RASDT_Atm
+#define MPRDT_Sonet RASDT_Sonet
+#define MPRDT_SW56 RASDT_SW56
+#define MPRDT_Irda RASDT_Irda
+#define MPRDT_Parallel RASDT_Parallel
+#define MPRET_Phone RASET_Phone
+#define MPRET_Vpn RASET_Vpn
+#define MPRET_Direct RASET_Direct
+#define MPRDM_DialFirst 0
+#define MPRDM_DialAll RASEDM_DialAll
+#define MPRDM_DialAsNeeded RASEDM_DialAsNeeded
+#define MPRIDS_Disabled RASIDS_Disabled
+#define MPRIDS_UseGlobalValue RASIDS_UseGlobalValue
+#define MPR_ET_None ET_None
+#define MPR_ET_Require ET_Require
+#define MPR_ET_RequireMax ET_RequireMax
+#define MPR_ET_Optional ET_Optional
+#define MPR_VS_Default	VS_Default
+#define MPR_VS_PptpOnly VS_PptpOnly
+#define MPR_VS_PptpFirst	VS_PptpFirst
+#define MPR_VS_L2tpOnly	VS_L2tpOnly
+#define MPR_VS_L2tpFirst	VS_L2tpFirst
+  typedef struct _MPR_INTERFACE_2
+  {
+    IN OUT WCHAR wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
+    OUT HANDLE hInterface;
+    IN OUT BOOL fEnabled;
+    IN OUT ROUTER_INTERFACE_TYPE dwIfType;
+    OUT ROUTER_CONNECTION_STATE dwConnectionState;
+    OUT DWORD fUnReachabilityReasons;
+    OUT DWORD dwLastError;
+    DWORD dwfOptions;
+    WCHAR szLocalPhoneNumber[RAS_MaxPhoneNumber + 1];
+    PWCHAR szAlternates;
+    DWORD ipaddr;
+    DWORD ipaddrDns;
+    DWORD ipaddrDnsAlt;
+    DWORD ipaddrWins;
+    DWORD ipaddrWinsAlt;
+    DWORD dwfNetProtocols;
+    WCHAR szDeviceType[MPR_MaxDeviceType + 1];
+    WCHAR szDeviceName[MPR_MaxDeviceName + 1];
+    WCHAR szX25PadType[MPR_MaxPadType + 1];
+    WCHAR szX25Address[MPR_MaxX25Address + 1];
+    WCHAR szX25Facilities[MPR_MaxFacilities + 1];
+    WCHAR szX25UserData[MPR_MaxUserData + 1];
+    DWORD dwChannels;
+    DWORD dwSubEntries;
+    DWORD dwDialMode;
+    DWORD dwDialExtraPercent;
+    DWORD dwDialExtraSampleSeconds;
+    DWORD dwHangUpExtraPercent;
+    DWORD dwHangUpExtraSampleSeconds;
+    DWORD dwIdleDisconnectSeconds;
+    DWORD dwType;
+    DWORD dwEncryptionType;
+    DWORD dwCustomAuthKey;
+    DWORD dwCustomAuthDataSize;
+    LPBYTE lpbCustomAuthData;
+    GUID guidId;
+    DWORD dwVpnStrategy;
+  } MPR_INTERFACE_2, *PMPR_INTERFACE_2;
+  typedef struct _MPR_DEVICE_0
+  {
+    WCHAR szDeviceType[MPR_MaxDeviceType + 1];
+    WCHAR szDeviceName[MPR_MaxDeviceName + 1];
+  } MPR_DEVICE_0, *PMPR_DEVICE_0;
+  typedef struct _MPR_DEVICE_1
+  {
+    WCHAR szDeviceType[MPR_MaxDeviceType + 1];
+    WCHAR szDeviceName[MPR_MaxDeviceName + 1];
+    WCHAR szLocalPhoneNumber[MPR_MaxPhoneNumber + 1];
+    PWCHAR szAlternates;
+  } MPR_DEVICE_1, *PMPR_DEVICE_1;
+  typedef struct _MPR_CREDENTIALSEX_0
+  {
+    DWORD dwSize;
+    LPBYTE lpbCredentialsInfo;
+  } MPR_CREDENTIALSEX_0, *PMPR_CREDENTIALSEX_0;
+  typedef struct _MPR_CREDENTIALSEX_1
+  {
+    DWORD dwSize;
+    LPBYTE lpbCredentialsInfo;
+  } MPR_CREDENTIALSEX_1, *PMPR_CREDENTIALSEX_1;
+#endif
+  typedef struct _MPR_TRANSPORT_0
+  {
+    OUT DWORD dwTransportId;
+    OUT HANDLE hTransport;
+    OUT WCHAR wszTransportName[MAX_TRANSPORT_NAME_LEN + 1];
+  } MPR_TRANSPORT_0, *PMPR_TRANSPORT_0;
+  typedef struct _MPR_IFTRANSPORT_0
+  {
+    OUT DWORD dwTransportId;
+    OUT HANDLE hIfTransport;
+    OUT WCHAR wszIfTransportName[MAX_TRANSPORT_NAME_LEN + 1];
+  } MPR_IFTRANSPORT_0, *PMPR_IFTRANSPORT_0;
+  typedef struct _MPR_SERVER_0
+  {
+    OUT BOOL fLanOnlyMode;
+    OUT DWORD dwUpTime;
+    OUT DWORD dwTotalPorts;
+    OUT DWORD dwPortsInUse;
+  } MPR_SERVER_0, *PMPR_SERVER_0;
+#if (WINVER >= 0x501)
+#define MPR_ENABLE_RAS_ON_DEVICE 0x00000001
+#define MPR_ENABLE_ROUTING_ON_DEVICE 0x00000002
+  typedef struct _MPR_SERVER_1
+  {
+    IN OUT DWORD dwNumPptpPorts;
+    IN OUT DWORD dwPptpPortFlags;
+    IN OUT DWORD dwNumL2tpPorts;
+    IN OUT DWORD dwL2tpPortFlags;
+  } MPR_SERVER_1, *PMPR_SERVER_1;
+#endif
+  typedef enum _RAS_PORT_CONDITION
+  { RAS_PORT_NON_OPERATIONAL, RAS_PORT_DISCONNECTED, RAS_PORT_CALLING_BACK, RAS_PORT_LISTENING, RAS_PORT_AUTHENTICATING, RAS_PORT_AUTHENTICATED, RAS_PORT_INITIALIZING } RAS_PORT_CONDITION;
+  typedef enum _RAS_HARDWARE_CONDITION
+  { RAS_HARDWARE_OPERATIONAL, RAS_HARDWARE_FAILURE } RAS_HARDWARE_CONDITION;
+  typedef struct _RAS_PORT_0
+  {
+    OUT HANDLE hPort;
+    OUT HANDLE hConnection;
+    OUT RAS_PORT_CONDITION dwPortCondition;
+    OUT DWORD dwTotalNumberOfCalls;
+    OUT DWORD dwConnectDuration;
+    OUT WCHAR wszPortName[MAX_PORT_NAME + 1];
+    OUT WCHAR wszMediaName[MAX_MEDIA_NAME + 1];
+    OUT WCHAR wszDeviceName[MAX_DEVICE_NAME + 1];
+    OUT WCHAR wszDeviceType[MAX_DEVICETYPE_NAME + 1];
+  } RAS_PORT_0, *PRAS_PORT_0;
+  typedef struct _RAS_PORT_1
+  {
+    OUT HANDLE hPort;
+    OUT HANDLE hConnection;
+    OUT RAS_HARDWARE_CONDITION dwHardwareCondition;
+    OUT DWORD dwLineSpeed;
+    OUT DWORD dwBytesXmited;
+    OUT DWORD dwBytesRcved;
+    OUT DWORD dwFramesXmited;
+    OUT DWORD dwFramesRcved;
+    OUT DWORD dwCrcErr;
+    OUT DWORD dwTimeoutErr;
+    OUT DWORD dwAlignmentErr;
+    OUT DWORD dwHardwareOverrunErr;
+    OUT DWORD dwFramingErr;
+    OUT DWORD dwBufferOverrunErr;
+    OUT DWORD dwCompressionRatioIn;
+    OUT DWORD dwCompressionRatioOut;
+  } RAS_PORT_1, *PRAS_PORT_1;
+#define IPADDRESSLEN 15
+#define IPXADDRESSLEN 22
+#define ATADDRESSLEN 32
+  typedef struct _PPP_NBFCP_INFO
+  {
+    OUT DWORD dwError;
+    OUT WCHAR wszWksta[NETBIOS_NAME_LEN + 1];
+  } PPP_NBFCP_INFO;
+  typedef struct _PPP_IPCP_INFO
+  {
+    OUT DWORD dwError;
+    OUT WCHAR wszAddress[IPADDRESSLEN + 1];
+    OUT WCHAR wszRemoteAddress[IPADDRESSLEN + 1];
+  } PPP_IPCP_INFO;
+#define PPP_IPCP_VJ 0x00000001
+  typedef struct _PPP_IPCP_INFO2
+  {
+    OUT DWORD dwError;
+    OUT WCHAR wszAddress[IPADDRESSLEN + 1];
+    OUT WCHAR wszRemoteAddress[IPADDRESSLEN + 1];
+    OUT DWORD dwOptions;
+    OUT DWORD dwRemoteOptions;
+  } PPP_IPCP_INFO2;
+  typedef struct _PPP_IPXCP_INFO
+  {
+    OUT DWORD dwError;
+    OUT WCHAR wszAddress[IPXADDRESSLEN + 1];
+  } PPP_IPXCP_INFO;
+  typedef struct _PPP_ATCP_INFO
+  {
+    OUT DWORD dwError;
+    OUT WCHAR wszAddress[ATADDRESSLEN + 1];
+  } PPP_ATCP_INFO;
+  typedef struct _PPP_INFO
+  {
+    OUT PPP_NBFCP_INFO nbf;
+    OUT PPP_IPCP_INFO ip;
+    OUT PPP_IPXCP_INFO ipx;
+    OUT PPP_ATCP_INFO at;
+  } PPP_INFO;
+#if(WINVER >= 0x0500)
+#define RASCCPCA_MPPC 0x00000006
+#define RASCCPCA_STAC 0x00000005
+#define PPP_CCP_COMPRESSION 0x00000001
+#define PPP_CCP_ENCRYPTION40BITOLD 0x00000010
+#define PPP_CCP_ENCRYPTION40BIT 0x00000020
+#define PPP_CCP_ENCRYPTION128BIT 0x00000040
+#define PPP_CCP_ENCRYPTION56BIT 0x00000080
+#define PPP_CCP_HISTORYLESS 0x01000000
+  typedef struct _PPP_CCP_INFO
+  {
+    OUT DWORD dwError;
+    OUT DWORD dwCompressionAlgorithm;
+    OUT DWORD dwOptions;
+    OUT DWORD dwRemoteCompressionAlgorithm;
+    OUT DWORD dwRemoteOptions;
+  } PPP_CCP_INFO;
+#define PPP_LCP_PAP 0xC023
+#define PPP_LCP_SPAP 0xC027
+#define PPP_LCP_CHAP 0xC223
+#define PPP_LCP_EAP 0xC227
+#define PPP_LCP_CHAP_MD5 0x05
+#define PPP_LCP_CHAP_MS 0x80
+#define PPP_LCP_CHAP_MSV2 0x81
+#define PPP_LCP_MULTILINK_FRAMING 0x00000001
+#define PPP_LCP_PFC 0x00000002
+#define PPP_LCP_ACFC 0x00000004
+#define PPP_LCP_SSHF 0x00000008
+#define PPP_LCP_DES_56 0x00000010
+#define PPP_LCP_3_DES 0x00000020
+  typedef struct _PPP_LCP_INFO
+  {
+    OUT DWORD dwError;
+    OUT DWORD dwAuthenticationProtocol;
+    OUT DWORD dwAuthenticationData;
+    OUT DWORD dwRemoteAuthenticationProtocol;
+    OUT DWORD dwRemoteAuthenticationData;
+    OUT DWORD dwTerminateReason;
+    OUT DWORD dwRemoteTerminateReason;
+    OUT DWORD dwOptions;
+    OUT DWORD dwRemoteOptions;
+    OUT DWORD dwEapTypeId;
+    OUT DWORD dwRemoteEapTypeId;
+  } PPP_LCP_INFO;
+  typedef struct _PPP_INFO_2
+  {
+    OUT PPP_NBFCP_INFO nbf;
+    OUT PPP_IPCP_INFO2 ip;
+    OUT PPP_IPXCP_INFO ipx;
+    OUT PPP_ATCP_INFO at;
+    OUT PPP_CCP_INFO ccp;
+    OUT PPP_LCP_INFO lcp;
+  } PPP_INFO_2;
+#endif
+#define RAS_FLAGS_PPP_CONNECTION 0x00000001
+#define RAS_FLAGS_MESSENGER_PRESENT 0x00000002
+#if(WINVER < 0x0501)
+#define RAS_FLAGS_RAS_CONNECTION 0x00000004
+#endif
+#define RAS_FLAGS_QUARANTINE_PRESENT 0x00000008
+  typedef struct _RAS_CONNECTION_0
+  {
+    OUT HANDLE hConnection;
+    OUT HANDLE hInterface;
+    OUT DWORD dwConnectDuration;
+    OUT ROUTER_INTERFACE_TYPE dwInterfaceType;
+    OUT DWORD dwConnectionFlags;
+    OUT WCHAR wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
+    OUT WCHAR wszUserName[UNLEN + 1];
+    OUT WCHAR wszLogonDomain[DNLEN + 1];
+    OUT WCHAR wszRemoteComputer[NETBIOS_NAME_LEN + 1];
+  } RAS_CONNECTION_0, *PRAS_CONNECTION_0;
+  typedef struct _RAS_CONNECTION_1
+  {
+    OUT HANDLE hConnection;
+    OUT HANDLE hInterface;
+    OUT PPP_INFO PppInfo;
+    OUT DWORD dwBytesXmited;
+    OUT DWORD dwBytesRcved;
+    OUT DWORD dwFramesXmited;
+    OUT DWORD dwFramesRcved;
+    OUT DWORD dwCrcErr;
+    OUT DWORD dwTimeoutErr;
+    OUT DWORD dwAlignmentErr;
+    OUT DWORD dwHardwareOverrunErr;
+    OUT DWORD dwFramingErr;
+    OUT DWORD dwBufferOverrunErr;
+    OUT DWORD dwCompressionRatioIn;
+    OUT DWORD dwCompressionRatioOut;
+  } RAS_CONNECTION_1, *PRAS_CONNECTION_1;
+#if(WINVER >= 0x0500)
+  typedef struct _RAS_CONNECTION_2
+  {
+    OUT HANDLE hConnection;
+    OUT WCHAR wszUserName[UNLEN + 1];
+    OUT ROUTER_INTERFACE_TYPE dwInterfaceType;
+    OUT GUID guid;
+    OUT PPP_INFO_2 PppInfo2;
+  } RAS_CONNECTION_2, *PRAS_CONNECTION_2;
+#endif
+#define RASPRIV_NoCallback 0x01
+#define RASPRIV_AdminSetCallback 0x02
+#define RASPRIV_CallerSetCallback 0x04
+#define RASPRIV_DialinPrivilege 0x08
+#define RASPRIV2_DialinPolicy 0x1
+#define RASPRIV_CallbackType (RASPRIV_AdminSetCallback | RASPRIV_CallerSetCallback | RASPRIV_NoCallback)
+  typedef struct _RAS_USER_0
+  {
+    OUT BYTE bfPrivilege;
+    OUT WCHAR wszPhoneNumber[MAX_PHONE_NUMBER_LEN + 1];
+  } RAS_USER_0, *PRAS_USER_0;
+  typedef struct _RAS_USER_1
+  {
+    OUT BYTE bfPrivilege;
+    OUT WCHAR wszPhoneNumber[MAX_PHONE_NUMBER_LEN + 1];
+    OUT BYTE bfPrivilege2;
+  } RAS_USER_1, *PRAS_USER_1;
+  typedef HANDLE RAS_SERVER_HANDLE;
+  typedef HANDLE MPR_SERVER_HANDLE;
+  typedef HANDLE MIB_SERVER_HANDLE;
+  DWORD APIENTRY MprAdminConnectionEnum (IN RAS_SERVER_HANDLE hRasServer, IN DWORD dwLevel, OUT LPBYTE * lplpbBuffer, IN DWORD dwPrefMaxLen, OUT LPDWORD lpdwEntriesRead, OUT LPDWORD lpdwTotalEntries, IN LPDWORD lpdwResumeHandle OPTIONAL);
+  DWORD APIENTRY MprAdminPortEnum (IN RAS_SERVER_HANDLE hRasServer, IN DWORD dwLevel, IN HANDLE hConnection, OUT LPBYTE * lplpbBuffer, IN DWORD dwPrefMaxLen, OUT LPDWORD lpdwEntriesRead, OUT LPDWORD lpdwTotalEntries, IN LPDWORD lpdwResumeHandle OPTIONAL);
+  DWORD APIENTRY MprAdminConnectionGetInfo (IN RAS_SERVER_HANDLE hRasServer, IN DWORD dwLevel, IN HANDLE hConnection, OUT LPBYTE * lplpbBuffer);
+  DWORD APIENTRY MprAdminPortGetInfo (IN RAS_SERVER_HANDLE hRasServer, IN DWORD dwLevel, IN HANDLE hPort, OUT LPBYTE * lplpbBuffer);
+  DWORD APIENTRY MprAdminConnectionClearStats (IN RAS_SERVER_HANDLE hRasServer, IN HANDLE hConnection);
+  DWORD APIENTRY MprAdminPortClearStats (IN RAS_SERVER_HANDLE hRasServer, IN HANDLE hPort);
+  DWORD APIENTRY MprAdminPortReset (IN RAS_SERVER_HANDLE hRasServer, IN HANDLE hPort);
+  DWORD APIENTRY MprAdminPortDisconnect (IN RAS_SERVER_HANDLE hRasServer, IN HANDLE hPort);
+  BOOL APIENTRY MprAdminAcceptNewConnection (IN RAS_CONNECTION_0 * pRasConnection0, IN RAS_CONNECTION_1 * pRasConnection1);
+#if(WINVER >= 0x0500)
+  BOOL APIENTRY MprAdminAcceptNewConnection2 (IN RAS_CONNECTION_0 * pRasConnection0, IN RAS_CONNECTION_1 * pRasConnection1, IN RAS_CONNECTION_2 * pRasConnection2);
+#endif
+  BOOL APIENTRY MprAdminAcceptNewLink (IN RAS_PORT_0 * pRasPort0, IN RAS_PORT_1 * pRasPort1);
+  VOID APIENTRY MprAdminConnectionHangupNotification (IN RAS_CONNECTION_0 * pRasConnection0, IN RAS_CONNECTION_1 * pRasConnection1);
+#if(WINVER >= 0x0500)
+  VOID APIENTRY MprAdminConnectionHangupNotification2 (IN RAS_CONNECTION_0 * pRasConnection0, IN RAS_CONNECTION_1 * pRasConnection1, IN RAS_CONNECTION_2 * pRasConnection2);
+#endif
+#if (WINVER >= 0x501)
+  DWORD APIENTRY MprAdminConnectionRemoveQuarantine (IN HANDLE hRasServer, IN HANDLE hRasConnection, IN BOOL fIsIpAddress);
+#endif
+  VOID APIENTRY MprAdminLinkHangupNotification (IN RAS_PORT_0 * pRasPort0, IN RAS_PORT_1 * pRasPort1);
+  DWORD APIENTRY MprAdminGetIpAddressForUser (IN WCHAR * lpwszUserName, IN WCHAR * lpwszPortName, IN OUT DWORD * lpdwIpAddress, OUT BOOL * bNotifyRelease);
+  VOID APIENTRY MprAdminReleaseIpAddress (IN WCHAR * lpszUserName, IN WCHAR * lpszPortName, IN DWORD * lpdwIpAddress);
+#if(WINVER >= 0x0500)
+  DWORD APIENTRY MprAdminInitializeDll (VOID);
+  DWORD APIENTRY MprAdminTerminateDll (VOID);
+#endif
+  DWORD APIENTRY MprAdminUserGetInfo (IN const WCHAR * lpszServer, IN const WCHAR * lpszUser, IN DWORD dwLevel, OUT LPBYTE lpbBuffer);
+  DWORD APIENTRY MprAdminUserSetInfo (IN const WCHAR * lpszServer, IN const WCHAR * lpszUser, IN DWORD dwLevel, IN const LPBYTE lpbBuffer);
+#if(WINVER >= 0x0500)
+  DWORD APIENTRY MprAdminSendUserMessage (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hConnection, IN LPWSTR lpwszMessage);
+#endif
+  DWORD APIENTRY MprAdminGetPDCServer (IN const WCHAR * lpszDomain, IN const WCHAR * lpszServer, OUT LPWSTR lpszPDCServer);
+  BOOL APIENTRY MprAdminIsServiceRunning (IN LPWSTR lpwsServerName);
+  DWORD APIENTRY MprAdminServerConnect (IN LPWSTR lpwsServerName OPTIONAL, OUT MPR_SERVER_HANDLE * phMprServer);
+  VOID APIENTRY MprAdminServerDisconnect (IN MPR_SERVER_HANDLE hMprServer);
+#if (WINVER >= 0x501)
+  DWORD APIENTRY MprAdminServerGetCredentials (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwLevel, IN LPBYTE * lplpbBuffer);
+  DWORD APIENTRY MprAdminServerSetCredentials (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwLevel, IN LPBYTE lpbBuffer);
+#endif
+  DWORD APIENTRY MprAdminBufferFree (IN LPVOID pBuffer);
+  DWORD APIENTRY MprAdminGetErrorString (IN DWORD dwError, OUT LPWSTR * lpwsErrorString);
+  DWORD APIENTRY MprAdminServerGetInfo (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwLevel, OUT LPBYTE * lplpbBuffer);
+#if (WINVER >= 0x501)
+  DWORD APIENTRY MprAdminServerSetInfo (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwLevel, IN LPBYTE lpbBuffer);
+  DWORD APIENTRY MprAdminEstablishDomainRasServer (IN PWCHAR pszDomain, IN PWCHAR pszMachine, IN BOOL bEnable);
+  DWORD APIENTRY MprAdminIsDomainRasServer (IN PWCHAR pszDomain, IN PWCHAR pszMachine, OUT PBOOL pbIsRasServer);
+#endif
+#if(WINVER >= 0x0500)
+  DWORD APIENTRY MprAdminTransportCreate (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwTransportId, IN LPWSTR lpwsTransportName OPTIONAL, IN LPBYTE pGlobalInfo, IN DWORD dwGlobalInfoSize, IN LPBYTE pClientInterfaceInfo OPTIONAL, IN DWORD dwClientInterfaceInfoSize OPTIONAL, IN LPWSTR lpwsDLLPath);
+#endif
+  DWORD APIENTRY MprAdminTransportSetInfo (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwTransportId, IN LPBYTE pGlobalInfo OPTIONAL, IN DWORD dwGlobalInfoSize, IN LPBYTE pClientInterfaceInfo OPTIONAL, IN DWORD dwClientInterfaceInfoSize);
+  DWORD APIENTRY MprAdminTransportGetInfo (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwTransportId, OUT LPBYTE * ppGlobalInfo OPTIONAL, OUT LPDWORD lpdwGlobalInfoSize OPTIONAL, OUT LPBYTE * ppClientInterfaceInfo OPTIONAL, OUT LPDWORD lpdwClientInterfaceInfoSize OPTIONAL);
+#if(WINVER >= 0x0500)
+  DWORD APIENTRY MprAdminDeviceEnum (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwLevel, OUT LPBYTE * lplpbBuffer, OUT LPDWORD lpdwTotalEntries);
+#endif
+  DWORD APIENTRY MprAdminInterfaceGetHandle (IN MPR_SERVER_HANDLE hMprServer, IN LPWSTR lpwsInterfaceName, OUT HANDLE * phInterface, IN BOOL fIncludeClientInterfaces);
+  DWORD APIENTRY MprAdminInterfaceCreate (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwLevel, IN LPBYTE lpbBuffer, OUT HANDLE * phInterface);
+  DWORD APIENTRY MprAdminInterfaceGetInfo (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwLevel, IN LPBYTE * lplpbBuffer);
+  DWORD APIENTRY MprAdminInterfaceSetInfo (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwLevel, IN LPBYTE lpbBuffer);
+  DWORD APIENTRY MprAdminInterfaceDelete (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface);
+#if(WINVER >= 0x0500)
+  DWORD APIENTRY MprAdminInterfaceDeviceGetInfo (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwIndex, IN DWORD dwLevel, OUT LPBYTE * lplpBuffer);
+  DWORD APIENTRY MprAdminInterfaceDeviceSetInfo (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwIndex, IN DWORD dwLevel, IN LPBYTE lplpBuffer);
+#endif
+  DWORD APIENTRY MprAdminInterfaceTransportRemove (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwTransportId);
+  DWORD APIENTRY MprAdminInterfaceTransportAdd (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwTransportId, IN LPBYTE pInterfaceInfo, IN DWORD dwInterfaceInfoSize);
+  DWORD APIENTRY MprAdminInterfaceTransportGetInfo (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwTransportId, OUT LPBYTE * ppInterfaceInfo, OUT LPDWORD lpdwpInterfaceInfoSize OPTIONAL);
+  DWORD APIENTRY MprAdminInterfaceTransportSetInfo (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwTransportId, IN LPBYTE pInterfaceInfo, IN DWORD dwInterfaceInfoSize);
+  DWORD APIENTRY MprAdminInterfaceEnum (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwLevel, OUT LPBYTE * lplpbBuffer, IN DWORD dwPrefMaxLen, OUT LPDWORD lpdwEntriesRead, OUT LPDWORD lpdwTotalEntries, IN LPDWORD lpdwResumeHandle OPTIONAL);
+  DWORD APIENTRY MprSetupIpInIpInterfaceFriendlyNameEnum (IN PWCHAR pwszMachineName, OUT LPBYTE * lplpBuffer, OUT LPDWORD lpdwEntriesRead);
+  DWORD APIENTRY MprSetupIpInIpInterfaceFriendlyNameFree (IN LPVOID lpBuffer);
+  DWORD APIENTRY MprSetupIpInIpInterfaceFriendlyNameCreate (PWCHAR pwszMachineName, PMPR_IPINIP_INTERFACE_0 pNameInformation);
+  DWORD APIENTRY MprSetupIpInIpInterfaceFriendlyNameDelete (IN PWCHAR pwszMachineName, IN GUID * pGuid);
+  DWORD APIENTRY MprAdminInterfaceSetCredentials (IN LPWSTR lpwsServer OPTIONAL, IN LPWSTR lpwsInterfaceName, IN LPWSTR lpwsUserName OPTIONAL, IN LPWSTR lpwsDomainName OPTIONAL, IN LPWSTR lpwsPassword OPTIONAL);
+  DWORD APIENTRY MprAdminInterfaceGetCredentials (IN LPWSTR lpwsServer OPTIONAL, IN LPWSTR lpwsInterfaceName, OUT LPWSTR lpwsUserName OPTIONAL, OUT LPWSTR lpwsPassword OPTIONAL, OUT LPWSTR lpwsDomainName OPTIONAL);
+#if(WINVER >= 0x0500)
+  DWORD APIENTRY MprAdminInterfaceSetCredentialsEx (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwLevel, IN LPBYTE lpbBuffer);
+  DWORD APIENTRY MprAdminInterfaceGetCredentialsEx (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwLevel, OUT LPBYTE * lplpbBuffer);
+#endif
+  DWORD APIENTRY MprAdminInterfaceConnect (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN HANDLE hEvent, IN BOOL fSynchronous);
+  DWORD APIENTRY MprAdminInterfaceDisconnect (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface);
+  DWORD APIENTRY MprAdminInterfaceUpdateRoutes (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwProtocolId, IN HANDLE hEvent);
+  DWORD APIENTRY MprAdminInterfaceQueryUpdateResult (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface, IN DWORD dwProtocolId, OUT LPDWORD lpdwUpdateResult);
+  DWORD APIENTRY MprAdminInterfaceUpdatePhonebookInfo (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hInterface);
+#if(WINVER >= 0x0500)
+  DWORD APIENTRY MprAdminRegisterConnectionNotification (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hEventNotification);
+  DWORD APIENTRY MprAdminDeregisterConnectionNotification (IN MPR_SERVER_HANDLE hMprServer, IN HANDLE hEventNotification);
+#endif
+  DWORD APIENTRY MprAdminMIBServerConnect (IN LPWSTR lpwsServerName OPTIONAL, OUT MIB_SERVER_HANDLE * phMibServer);
+  VOID APIENTRY MprAdminMIBServerDisconnect (IN MIB_SERVER_HANDLE hMibServer);
+  DWORD APIENTRY MprAdminMIBEntryCreate (IN MIB_SERVER_HANDLE hMibServer, IN DWORD dwPid, IN DWORD dwRoutingPid, IN LPVOID lpEntry, IN DWORD dwEntrySize);
+  DWORD APIENTRY MprAdminMIBEntryDelete (IN MIB_SERVER_HANDLE hMibServer, IN DWORD dwProtocolId, IN DWORD dwRoutingPid, IN LPVOID lpEntry, IN DWORD dwEntrySize);
+  DWORD APIENTRY MprAdminMIBEntrySet (IN MIB_SERVER_HANDLE hMibServer, IN DWORD dwProtocolId, IN DWORD dwRoutingPid, IN LPVOID lpEntry, IN DWORD dwEntrySize);
+  DWORD APIENTRY MprAdminMIBEntryGet (IN MIB_SERVER_HANDLE hMibServer, IN DWORD dwProtocolId, IN DWORD dwRoutingPid, IN LPVOID lpInEntry, IN DWORD dwInEntrySize, OUT LPVOID * lplpOutEntry, OUT LPDWORD lpOutEntrySize);
+  DWORD APIENTRY MprAdminMIBEntryGetFirst (IN MIB_SERVER_HANDLE hMibServer, IN DWORD dwProtocolId, IN DWORD dwRoutingPid, IN LPVOID lpInEntry, IN DWORD dwInEntrySize, OUT LPVOID * lplpOutEntry, OUT LPDWORD lpOutEntrySize);
+  DWORD APIENTRY MprAdminMIBEntryGetNext (IN MIB_SERVER_HANDLE hMibServer, IN DWORD dwProtocolId, IN DWORD dwRoutingPid, IN LPVOID lpInEntry, IN DWORD dwInEntrySize, OUT LPVOID * lplpOutEntry, OUT LPDWORD lpOutEntrySize);
+  DWORD APIENTRY MprAdminMIBGetTrapInfo (IN MIB_SERVER_HANDLE hMibServer, IN DWORD dwProtocolId, IN DWORD dwRoutingPid, IN LPVOID lpInData, IN DWORD dwInDataSize, OUT LPVOID * lplpOutData, IN OUT LPDWORD lpOutDataSize);
+  DWORD APIENTRY MprAdminMIBSetTrapInfo (IN DWORD dwProtocolId, IN DWORD dwRoutingPid, IN HANDLE hEvent, IN LPVOID lpInData, IN DWORD dwInDataSize, OUT LPVOID * lplpOutData, IN OUT LPDWORD lpOutDataSize);
+  DWORD APIENTRY MprAdminMIBBufferFree (IN LPVOID pBuffer);
+  DWORD APIENTRY MprConfigServerInstall (IN DWORD dwLevel, IN PVOID pBuffer);
+  DWORD APIENTRY MprConfigServerConnect (IN LPWSTR lpwsServerName, OUT HANDLE * phMprConfig);
+  VOID APIENTRY MprConfigServerDisconnect (IN HANDLE hMprConfig);
+  DWORD APIENTRY MprConfigServerRefresh (IN HANDLE hMprConfig);
+  DWORD APIENTRY MprConfigBufferFree (IN LPVOID pBuffer);
+  DWORD APIENTRY MprConfigServerGetInfo (IN HANDLE hMprConfig, IN DWORD dwLevel, OUT LPBYTE * lplpbBuffer);
+#if (WINVER >= 0x501)
+  DWORD APIENTRY MprConfigServerSetInfo (IN MPR_SERVER_HANDLE hMprServer, IN DWORD dwLevel, IN LPBYTE lpbBuffer);
+#endif
+  DWORD APIENTRY MprConfigServerBackup (IN HANDLE hMprConfig, IN LPWSTR lpwsPath);
+  DWORD APIENTRY MprConfigServerRestore (IN HANDLE hMprConfig, IN LPWSTR lpwsPath);
+  DWORD APIENTRY MprConfigTransportCreate (IN HANDLE hMprConfig, IN DWORD dwTransportId, IN LPWSTR lpwsTransportName OPTIONAL, IN LPBYTE pGlobalInfo, IN DWORD dwGlobalInfoSize, IN LPBYTE pClientInterfaceInfo OPTIONAL, IN DWORD dwClientInterfaceInfoSize OPTIONAL, IN LPWSTR lpwsDLLPath, OUT HANDLE * phRouterTransport);
+  DWORD APIENTRY MprConfigTransportDelete (IN HANDLE hMprConfig, IN HANDLE hRouterTransport);
+  DWORD APIENTRY MprConfigTransportGetHandle (IN HANDLE hMprConfig, IN DWORD dwTransportId, OUT HANDLE * phRouterTransport);
+  DWORD APIENTRY MprConfigTransportSetInfo (IN HANDLE hMprConfig, IN HANDLE hRouterTransport, IN LPBYTE pGlobalInfo OPTIONAL, IN DWORD dwGlobalInfoSize OPTIONAL, IN LPBYTE pClientInterfaceInfo OPTIONAL, IN DWORD dwClientInterfaceInfoSize OPTIONAL, IN LPWSTR lpwsDLLPath OPTIONAL);
+  DWORD APIENTRY MprConfigTransportGetInfo (IN HANDLE hMprConfig, IN HANDLE hRouterTransport, IN OUT LPBYTE * ppGlobalInfo OPTIONAL, OUT LPDWORD lpdwGlobalInfoSize OPTIONAL, IN OUT LPBYTE * ppClientInterfaceInfo OPTIONAL, OUT LPDWORD lpdwClientInterfaceInfoSize OPTIONAL, IN OUT LPWSTR * lplpwsDLLPath OPTIONAL);
+  DWORD APIENTRY MprConfigTransportEnum (IN HANDLE hMprConfig, IN DWORD dwLevel, IN OUT LPBYTE * lplpBuffer, IN DWORD dwPrefMaxLen, OUT LPDWORD lpdwEntriesRead, OUT LPDWORD lpdwTotalEntries, IN OUT LPDWORD lpdwResumeHandle OPTIONAL);
+  DWORD APIENTRY MprConfigInterfaceCreate (IN HANDLE hMprConfig, IN DWORD dwLevel, IN LPBYTE lpbBuffer, OUT HANDLE * phRouterInterface);
+  DWORD APIENTRY MprConfigInterfaceDelete (IN HANDLE hMprConfig, IN HANDLE hRouterInterface);
+  DWORD APIENTRY MprConfigInterfaceGetHandle (IN HANDLE hMprConfig, IN LPWSTR lpwsInterfaceName, OUT HANDLE * phRouterInterface);
+  DWORD APIENTRY MprConfigInterfaceGetInfo (IN HANDLE hMprConfig, IN HANDLE hRouterInterface, IN DWORD dwLevel, IN OUT LPBYTE * lplpBuffer, OUT LPDWORD lpdwBufferSize);
+  DWORD APIENTRY MprConfigInterfaceSetInfo (IN HANDLE hMprConfig, IN HANDLE hRouterInterface, IN DWORD dwLevel, IN LPBYTE lpbBuffer);
+  DWORD APIENTRY MprConfigInterfaceEnum (IN HANDLE hMprConfig, IN DWORD dwLevel, IN OUT LPBYTE * lplpBuffer, IN DWORD dwPrefMaxLen, OUT LPDWORD lpdwEntriesRead, OUT LPDWORD lpdwTotalEntries, IN OUT LPDWORD lpdwResumeHandle OPTIONAL);
+  DWORD APIENTRY MprConfigInterfaceTransportAdd (IN HANDLE hMprConfig, IN HANDLE hRouterInterface, IN DWORD dwTransportId, IN LPWSTR lpwsTransportName OPTIONAL, IN LPBYTE pInterfaceInfo, IN DWORD dwInterfaceInfoSize, OUT HANDLE * phRouterIfTransport);
+  DWORD APIENTRY MprConfigInterfaceTransportRemove (IN HANDLE hMprConfig, IN HANDLE hRouterInterface, IN HANDLE hRouterIfTransport);
+  DWORD APIENTRY MprConfigInterfaceTransportGetHandle (IN HANDLE hMprConfig, IN HANDLE hRouterInterface, IN DWORD dwTransportId, OUT HANDLE * phRouterIfTransport);
+  DWORD APIENTRY MprConfigInterfaceTransportGetInfo (IN HANDLE hMprConfig, IN HANDLE hRouterInterface, IN HANDLE hRouterIfTransport, IN OUT LPBYTE * ppInterfaceInfo OPTIONAL, OUT LPDWORD lpdwInterfaceInfoSize OPTIONAL);
+  DWORD APIENTRY MprConfigInterfaceTransportSetInfo (IN HANDLE hMprConfig, IN HANDLE hRouterInterface, IN HANDLE hRouterIfTransport, IN LPBYTE pInterfaceInfo OPTIONAL, IN DWORD dwInterfaceInfoSize OPTIONAL);
+  DWORD APIENTRY MprConfigInterfaceTransportEnum (IN HANDLE hMprConfig, IN HANDLE hRouterInterface, IN DWORD dwLevel, IN OUT LPBYTE * lplpBuffer, IN DWORD dwPrefMaxLen, OUT LPDWORD lpdwEntriesRead, OUT LPDWORD lpdwTotalEntries, IN OUT LPDWORD lpdwResumeHandle OPTIONAL);
+  DWORD APIENTRY MprConfigGetFriendlyName (IN HANDLE hMprConfig, IN PWCHAR pszGuidName, OUT PWCHAR pszBuffer, IN DWORD dwBufferSize);
+  DWORD APIENTRY MprConfigGetGuidName (IN HANDLE hMprConfig, IN PWCHAR pszFriendlyName, OUT PWCHAR pszBuffer, IN DWORD dwBufferSize);
+  DWORD APIENTRY MprInfoCreate (IN DWORD dwVersion, OUT LPVOID * lplpNewHeader);
+  DWORD APIENTRY MprInfoDelete (IN LPVOID lpHeader);
+  DWORD APIENTRY MprInfoRemoveAll (IN LPVOID lpHeader, OUT LPVOID * lplpNewHeader);
+  DWORD APIENTRY MprInfoDuplicate (IN LPVOID lpHeader, OUT LPVOID * lplpNewHeader);
+  DWORD APIENTRY MprInfoBlockAdd (IN LPVOID lpHeader, IN DWORD dwInfoType, IN DWORD dwItemSize, IN DWORD dwItemCount, IN LPBYTE lpItemData, OUT LPVOID * lplpNewHeader);
+  DWORD APIENTRY MprInfoBlockRemove (IN LPVOID lpHeader, IN DWORD dwInfoType, OUT LPVOID * lplpNewHeader);
+  DWORD APIENTRY MprInfoBlockSet (IN LPVOID lpHeader, IN DWORD dwInfoType, IN DWORD dwItemSize, IN DWORD dwItemCount, IN LPBYTE lpItemData, OUT LPVOID * lplpNewHeader);
+  DWORD APIENTRY MprInfoBlockFind (IN LPVOID lpHeader, IN DWORD dwInfoType, OUT LPDWORD lpdwItemSize, OUT LPDWORD lpdwItemCount, OUT LPBYTE * lplpItemData);
+  DWORD APIENTRY MprInfoBlockQuerySize (IN LPVOID lpHeader);
+#define MprInfoBlockExists(h,t) (MprInfoBlockFind((h),(t),NULL,NULL,NULL) == NO_ERROR)
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -uNr w32api-3.5/include/mprerror.h w32api-3.5-xorp/include/mprerror.h
--- w32api-3.5/include/mprerror.h	Wed Dec  7 15:43:11 2005
+++ w32api-3.5-xorp/include/mprerror.h	Wed Dec  7 15:45:49 2005
@@ -0,0 +1,64 @@
+#ifndef _MPRERROR_H_
+#define _MPRERROR_H_
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+#define ROUTEBASE 900
+#define SUCCESS 0
+#define ERROR_ROUTER_STOPPED (ROUTEBASE+0)
+#define ERROR_ALREADY_CONNECTED (ROUTEBASE+1)
+#define ERROR_UNKNOWN_PROTOCOL_ID (ROUTEBASE+2)
+#define ERROR_DDM_NOT_RUNNING (ROUTEBASE+3)
+#define ERROR_INTERFACE_ALREADY_EXISTS (ROUTEBASE+4)
+#define ERROR_NO_SUCH_INTERFACE (ROUTEBASE+5)
+#define ERROR_INTERFACE_NOT_CONNECTED (ROUTEBASE+6)
+#define ERROR_PROTOCOL_STOP_PENDING (ROUTEBASE+7)
+#define ERROR_INTERFACE_CONNECTED (ROUTEBASE+8)
+#define ERROR_NO_INTERFACE_CREDENTIALS_SET (ROUTEBASE+9)
+#define ERROR_ALREADY_CONNECTING (ROUTEBASE+10)
+#define ERROR_UPDATE_IN_PROGRESS (ROUTEBASE+11)
+#define ERROR_INTERFACE_CONFIGURATION (ROUTEBASE+12)
+#define ERROR_NOT_CLIENT_PORT (ROUTEBASE+13)
+#define ERROR_NOT_ROUTER_PORT (ROUTEBASE+14)
+#define ERROR_CLIENT_INTERFACE_ALREADY_EXISTS (ROUTEBASE+15)
+#define ERROR_INTERFACE_DISABLED (ROUTEBASE+16)
+#define ERROR_AUTH_PROTOCOL_REJECTED (ROUTEBASE+17)
+#define ERROR_NO_AUTH_PROTOCOL_AVAILABLE (ROUTEBASE+18)
+#define ERROR_PEER_REFUSED_AUTH (ROUTEBASE+19)
+#define ERROR_REMOTE_NO_DIALIN_PERMISSION (ROUTEBASE+20)
+#define ERROR_REMOTE_PASSWD_EXPIRED (ROUTEBASE+21)
+#define ERROR_REMOTE_ACCT_DISABLED (ROUTEBASE+22)
+#define ERROR_REMOTE_RESTRICTED_LOGON_HOURS (ROUTEBASE+23)
+#define ERROR_REMOTE_AUTHENTICATION_FAILURE (ROUTEBASE+24)
+#define ERROR_INTERFACE_HAS_NO_DEVICES (ROUTEBASE+25)
+#define ERROR_IDLE_DISCONNECTED (ROUTEBASE+26)
+#define ERROR_INTERFACE_UNREACHABLE (ROUTEBASE+27)
+#define ERROR_SERVICE_IS_PAUSED (ROUTEBASE+28)
+#define ERROR_INTERFACE_DISCONNECTED (ROUTEBASE+29)
+#define ERROR_AUTH_SERVER_TIMEOUT (ROUTEBASE+30)
+#define ERROR_PORT_LIMIT_REACHED (ROUTEBASE+31)
+#define ERROR_PPP_SESSION_TIMEOUT (ROUTEBASE+32)
+#define ERROR_MAX_LAN_INTERFACE_LIMIT (ROUTEBASE+33)
+#define ERROR_MAX_WAN_INTERFACE_LIMIT (ROUTEBASE+34)
+#define ERROR_MAX_CLIENT_INTERFACE_LIMIT (ROUTEBASE+35)
+#define ERROR_BAP_DISCONNECTED (ROUTEBASE+36)
+#define ERROR_USER_LIMIT (ROUTEBASE+37)
+#define ERROR_NO_RADIUS_SERVERS (ROUTEBASE+38)
+#define ERROR_INVALID_RADIUS_RESPONSE (ROUTEBASE+39)
+#define ERROR_DIALIN_HOURS_RESTRICTION (ROUTEBASE+40)
+#define ERROR_ALLOWED_PORT_TYPE_RESTRICTION (ROUTEBASE+41)
+#define ERROR_AUTH_PROTOCOL_RESTRICTION (ROUTEBASE+42)
+#define ERROR_BAP_REQUIRED (ROUTEBASE+43)
+#define ERROR_DIALOUT_HOURS_RESTRICTION (ROUTEBASE+44)
+#define ERROR_ROUTER_CONFIG_INCOMPATIBLE (ROUTEBASE+45)
+#define WARNING_NO_MD5_MIGRATION (ROUTEBASE+46)
+#define ERROR_PROTOCOL_ALREADY_INSTALLED (ROUTEBASE+48)
+#define ERROR_INVALID_SIGNATURE_LENGTH (ROUTEBASE+49)
+#define ERROR_INVALID_SIGNATURE (ROUTEBASE+50)
+#define ERROR_NO_SIGNATURE (ROUTEBASE+51)
+#define ERROR_INVALID_PACKET_LENGTH_OR_ID (ROUTEBASE+52)
+#define ERROR_INVALID_ATTRIBUTE_LENGTH (ROUTEBASE+53)
+#define ERROR_INVALID_PACKET (ROUTEBASE+54)
+#define ERROR_AUTHENTICATOR_MISMATCH (ROUTEBASE+55)
+#define ROUTEBASEEND (ROUTEBASE+56)
+#endif
diff -uNr w32api-3.5/include/routprot.h w32api-3.5-xorp/include/routprot.h
--- w32api-3.5/include/routprot.h	Wed Dec  7 15:42:47 2005
+++ w32api-3.5-xorp/include/routprot.h	Wed Dec  7 15:45:49 2005
@@ -0,0 +1,240 @@
+#ifndef _ROUTPROT_H_
+#define _ROUTPROT_H_
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+#include <stm.h>
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#define RF_ROUTING 0x00000001
+#define RF_DEMAND_UPDATE_ROUTES 0x00000004
+#define RF_ADD_ALL_INTERFACES 0x00000010
+#define RF_MULTICAST 0x00000020
+#define RF_POWER 0x00000040
+#if MPR50
+#define MS_ROUTER_VERSION 0x00000500
+#else
+#error Router version not defined
+#endif
+  typedef enum _ROUTING_PROTOCOL_EVENTS
+  { ROUTER_STOPPED, SAVE_GLOBAL_CONFIG_INFO, SAVE_INTERFACE_CONFIG_INFO, UPDATE_COMPLETE, } ROUTING_PROTOCOL_EVENTS;
+  typedef enum _NET_INTERFACE_TYPE
+  { PERMANENT, DEMAND_DIAL, LOCAL_WORKSTATION_DIAL, REMOTE_WORKSTATION_DIAL } NET_INTERFACE_TYPE;
+#define IR_PROMISCUOUS 0
+#define IR_PROMISCUOUS_MULTICAST 1
+  typedef struct _SUPPORT_FUNCTIONS
+  {
+    union
+    {
+      ULONGLONG _Align8;
+      struct
+      {
+	DWORD dwVersion;
+	DWORD dwReserved;
+      };
+    };
+    OUT DWORD (WINAPI * DemandDialRequest) (IN DWORD ProtocolId, IN DWORD InterfaceIndex);
+    OUT DWORD (WINAPI * SetInterfaceReceiveType) (IN DWORD ProtocolId, IN DWORD InterfaceIndex, IN DWORD InterfaceReceiveType, IN BOOL bActivate);
+    OUT DWORD (WINAPI * ValidateRoute) (IN DWORD ProtocolId, IN PVOID RouteInfo, IN PVOID DestAddress OPTIONAL);
+    OUT DWORD (WINAPI * MIBEntryCreate) (IN DWORD dwRoutingPid, IN DWORD dwEntrySize, IN LPVOID lpEntry);
+    OUT DWORD (WINAPI * MIBEntryDelete) (IN DWORD dwRoutingPid, IN DWORD dwEntrySize, IN LPVOID lpEntry);
+    OUT DWORD (WINAPI * MIBEntrySet) (IN DWORD dwRoutingPid, IN DWORD dwEntrySize, IN LPVOID lpEntry);
+    OUT DWORD (WINAPI * MIBEntryGet) (IN DWORD dwRoutingPid, IN DWORD dwInEntrySize, IN LPVOID lpInEntry, IN OUT LPDWORD lpOutEntrySize, OUT LPVOID lpOutEntry);
+    OUT DWORD (WINAPI * MIBEntryGetFirst) (IN DWORD dwRoutingPid, IN DWORD dwInEntrySize, IN LPVOID lpInEntry, IN OUT LPDWORD lpOutEntrySize, OUT LPVOID lpOutEntry);
+    OUT DWORD (WINAPI * MIBEntryGetNext) (IN DWORD dwRoutingPid, IN DWORD dwInEntrySize, IN LPVOID lpInEntry, IN OUT LPDWORD lpOutEntrySize, OUT LPVOID lpOutEntry);
+    OUT DWORD (WINAPI * GetRouterId) (VOID);
+    OUT BOOL (WINAPI * HasMulticastBoundary) (IN DWORD dwIfIndex, IN DWORD dwGroupAddress);
+  } SUPPORT_FUNCTIONS, *PSUPPORT_FUNCTIONS;
+#define PROTO_IP_OTHER 1
+#define PROTO_IP_LOCAL 2
+#define PROTO_IP_NETMGMT 3
+#define PROTO_IP_ICMP 4
+#define PROTO_IP_EGP 5
+#define PROTO_IP_GGP 6
+#define PROTO_IP_HELLO 7
+#define PROTO_IP_RIP 8
+#define PROTO_IP_IS_IS 9
+#define PROTO_IP_ES_IS 10
+#define PROTO_IP_CISCO 11
+#define PROTO_IP_BBN 12
+#define PROTO_IP_OSPF 13
+#define PROTO_IP_BGP 14
+#define PROTO_IP_MSDP 9
+#define PROTO_IP_IGMP 10
+#define PROTO_IP_BGMP 11
+#define PROTO_IP_VRRP 112
+#define PROTO_IP_BOOTP 9999
+#define PROTO_IP_NT_AUTOSTATIC 10002
+#define PROTO_IP_DNS_PROXY 10003
+#define PROTO_IP_DHCP_ALLOCATOR 10004
+#define PROTO_IP_NAT 10005
+#define PROTO_IP_NT_STATIC 10006
+#define PROTO_IP_NT_STATIC_NON_DOD 10007
+#define PROTO_IP_DIFFSERV 10008
+#define PROTO_IP_MGM 10009
+#define PROTO_IP_ALG 10010
+#define PROTO_IP_H323 10011
+#define PROTO_IP_FTP 10012
+#define PROTO_IP_DTP 10013
+#define PROTOCOL_ID(Type, VendorId, ProtocolId) (((Type & 0x03)<<30)|((VendorId & 0x3FFF)<<16)|(ProtocolId & 0xFFFF))
+#define TYPE_FROM_PROTO_ID(X) (((X) >> 30) & 0x03)
+#define VENDOR_FROM_PROTO_ID(X) (((X) >> 16) & 0x3FFF)
+#define PROTO_FROM_PROTO_ID(X) ((X) & 0xFFFF)
+#define PROTO_TYPE_UCAST 0
+#define PROTO_TYPE_MCAST 1
+#define PROTO_TYPE_MS0 2
+#define PROTO_TYPE_MS1 3
+#define PROTO_VENDOR_MS0 0x0000
+#define PROTO_VENDOR_MS1 0x137
+#define PROTO_VENDOR_MS2 0x3FFF
+#define MS_IP_BOOTP PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_BOOTP)
+#define MS_IP_RIP PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_RIP)
+#define MS_IP_OSPF PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_OSPF)
+#define MS_IP_BGP PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS1, PROTO_IP_BGP)
+#define MS_IP_IGMP PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_IGMP)
+#define MS_IP_BGMP PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_BGMP)
+#define MS_IP_MSDP PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_MSDP)
+#define MS_IP_DNS_PROXY PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DNS_PROXY)
+#define MS_IP_DHCP_ALLOCATOR PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DHCP_ALLOCATOR)
+#define MS_IP_NAT PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_NAT)
+#define MS_IP_DIFFSERV PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DIFFSERV)
+#define MS_IP_MGM PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_MGM)
+#define MS_IP_VRRP PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_VRRP)
+#define MS_IP_DTP PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DTP)
+#define MS_IP_H323 PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_H323)
+#define MS_IP_FTP PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_FTP)
+#define MS_IP_ALG PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_ALG)
+#define IPX_PROTOCOL_BASE 0x0001ffff
+#define IPX_PROTOCOL_RIP IPX_PROTOCOL_BASE + 1
+#define IPX_PROTOCOL_SAP IPX_PROTOCOL_BASE + 2
+#define IPX_PROTOCOL_NLSP IPX_PROTOCOL_BASE + 3
+  typedef struct _UPDATE_COMPLETE_MESSAGE
+  {
+    ULONG InterfaceIndex;
+    ULONG UpdateType;
+    ULONG UpdateStatus;
+  } UPDATE_COMPLETE_MESSAGE, *PUPDATE_COMPLETE_MESSAGE;
+  typedef union _MESSAGE
+  {
+    UPDATE_COMPLETE_MESSAGE UpdateCompleteMessage;
+    DWORD InterfaceIndex;
+  } MESSAGE, *PMESSAGE;
+#define RIS_INTERFACE_ADDRESS_CHANGE 0
+#define RIS_INTERFACE_ENABLED 1
+#define RIS_INTERFACE_DISABLED 2
+#define RIS_INTERFACE_MEDIA_PRESENT 3
+#define RIS_INTERFACE_MEDIA_ABSENT 4
+  typedef struct IPX_ADAPTER_BINDING_INFO
+  {
+    ULONG AdapterIndex;
+    UCHAR Network[4];
+    UCHAR LocalNode[6];
+    UCHAR RemoteNode[6];
+    ULONG MaxPacketSize;
+    ULONG LinkSpeed;
+  } IPX_ADAPTER_BINDING_INFO, *PIPX_ADAPTER_BINDING_INFO;
+  typedef struct IP_LOCAL_BINDING
+  {
+    DWORD Address;
+    DWORD Mask;
+  } IP_LOCAL_BINDING, *PIP_LOCAL_BINDING;
+  typedef struct IP_ADAPTER_BINDING_INFO
+  {
+    ULONG AddressCount;
+    DWORD RemoteAddress;
+    ULONG Mtu;
+    ULONGLONG Speed;
+    IP_LOCAL_BINDING Address[0];
+  } IP_ADAPTER_BINDING_INFO, *PIP_ADAPTER_BINDING_INFO;
+#define SIZEOF_IP_BINDING(X) (FIELD_OFFSET(IP_ADAPTER_BINDING_INFO,Address[0]) + ((X) * sizeof(IP_LOCAL_BINDING)))
+  typedef DWORD (WINAPI * PSTART_PROTOCOL) (IN HANDLE NotificationEvent, IN PSUPPORT_FUNCTIONS SupportFunctions, IN LPVOID GlobalInfo, IN ULONG StructureVersion, IN ULONG StructureSize, IN ULONG StructureCount);
+  typedef DWORD (WINAPI * PSTART_COMPLETE) (VOID);
+  typedef DWORD (WINAPI * PSTOP_PROTOCOL) (VOID);
+  typedef DWORD (WINAPI * PADD_INTERFACE) (IN LPWSTR InterfaceName, IN ULONG InterfaceIndex, IN NET_INTERFACE_TYPE InterfaceType, IN DWORD MediaType, IN WORD AccessType, IN WORD ConnectionType, IN PVOID InterfaceInfo, IN ULONG StructureVersion, IN ULONG StructureSize, IN ULONG StructureCount);
+  typedef DWORD (WINAPI * PDELETE_INTERFACE) (IN ULONG InterfaceIndex);
+  typedef DWORD (WINAPI * PGET_EVENT_MESSAGE) (OUT ROUTING_PROTOCOL_EVENTS * Event, OUT MESSAGE * Result);
+  typedef DWORD (WINAPI * PGET_INTERFACE_INFO) (IN ULONG InterfaceIndex, IN PVOID InterfaceInfo, IN OUT PULONG BufferSize, OUT PULONG StructureVersion, IN PULONG StructureSize, OUT PULONG StructureCount);
+  typedef DWORD (WINAPI * PSET_INTERFACE_INFO) (IN ULONG InterfaceIndex, IN PVOID InterfaceInfo, IN ULONG StructureVersion, IN ULONG StructureSize, IN ULONG StructureCount);
+  typedef DWORD (WINAPI * PINTERFACE_STATUS) (IN ULONG InterfaceIndex, IN BOOL InterfaceActive, IN DWORD StatusType, IN PVOID StatusInfo);
+  typedef DWORD (WINAPI * PQUERY_POWER) (IN DWORD PowerType);
+  typedef DWORD (WINAPI * PSET_POWER) (IN DWORD PowerType);
+  typedef DWORD (WINAPI * PGET_GLOBAL_INFO) (IN PVOID GlobalInfo, IN OUT PULONG BufferSize, OUT PULONG StructureVersion, OUT PULONG StructureSize, OUT PULONG StructureCount);
+  typedef DWORD (WINAPI * PSET_GLOBAL_INFO) (IN PVOID GlobalInfo, IN ULONG StructureVersion, IN ULONG StructureSize, IN ULONG StructureCount);
+  typedef DWORD (WINAPI * PDO_UPDATE_ROUTES) (IN ULONG InterfaceIndex);
+  typedef DWORD (WINAPI * PMIB_CREATE) (IN ULONG InputDataSize, IN PVOID InputData);
+  typedef DWORD (WINAPI * PMIB_DELETE) (IN ULONG InputDataSize, IN PVOID InputData);
+  typedef DWORD (WINAPI * PMIB_GET) (IN ULONG InputDataSize, IN PVOID InputData, OUT PULONG OutputDataSize, OUT PVOID OutputData);
+  typedef DWORD (WINAPI * PMIB_SET) (IN ULONG InputDataSize, IN PVOID InputData);
+  typedef DWORD (WINAPI * PMIB_GET_FIRST) (IN ULONG InputDataSize, IN PVOID InputData, OUT PULONG OutputDataSize, OUT PVOID OutputData);
+  typedef DWORD (WINAPI * PMIB_GET_NEXT) (IN ULONG InputDataSize, IN PVOID InputData, OUT PULONG OutputDataSize, OUT PVOID OutputData);
+  typedef DWORD (WINAPI * PMIB_SET_TRAP_INFO) (IN HANDLE Event, IN ULONG InputDataSize, IN PVOID InputData, OUT PULONG OutputDataSize, OUT PVOID OutputData);
+  typedef DWORD (WINAPI * PMIB_GET_TRAP_INFO) (IN ULONG InputDataSize, IN PVOID InputData, OUT PULONG OutputDataSize, OUT PVOID OutputData);
+  typedef DWORD (WINAPI * PCONNECT_CLIENT) (IN ULONG InterfaceIndex, IN PVOID ClientAddress);
+  typedef DWORD (WINAPI * PDISCONNECT_CLIENT) (IN ULONG InterfaceIndex, IN PVOID ClientAddress);
+#define MRINFO_TUNNEL_FLAG 0x01
+#define MRINFO_PIM_FLAG 0x04
+#define MRINFO_DOWN_FLAG 0x10
+#define MRINFO_DISABLED_FLAG 0x20
+#define MRINFO_QUERIER_FLAG 0x40
+#define MRINFO_LEAF_FLAG 0x80
+  typedef DWORD (WINAPI * PGET_NEIGHBORS) (IN DWORD InterfaceIndex, IN PDWORD NeighborList, IN OUT PDWORD NeighborListSize, OUT PBYTE InterfaceFlags);
+#define MFE_NO_ERROR 0
+#define MFE_REACHED_CORE 1
+#define MFE_OIF_PRUNED 5
+#define MFE_PRUNED_UPSTREAM 4
+#define MFE_OLD_ROUTER 11
+#define MFE_NOT_FORWARDING 2
+#define MFE_WRONG_IF 3
+#define MFE_BOUNDARY_REACHED 6
+#define MFE_NO_MULTICAST 7
+#define MFE_IIF 8
+#define MFE_NO_ROUTE 9
+#define MFE_NOT_LAST_HOP 10
+#define MFE_PROHIBITED 12
+#define MFE_NO_SPACE 13
+  typedef DWORD (WINAPI * PGET_MFE_STATUS) (IN DWORD InterfaceIndex, IN DWORD GroupAddress, IN DWORD SourceAddress, OUT PBYTE StatusCode);
+  typedef struct _MPR50_ROUTING_CHARACTERISTICS
+  {
+    DWORD dwVersion;
+    DWORD dwProtocolId;
+    DWORD fSupportedFunctionality;
+    PSTART_PROTOCOL pfnStartProtocol;
+    PSTART_COMPLETE pfnStartComplete;
+    PSTOP_PROTOCOL pfnStopProtocol;
+    PGET_GLOBAL_INFO pfnGetGlobalInfo;
+    PSET_GLOBAL_INFO pfnSetGlobalInfo;
+    PQUERY_POWER pfnQueryPower;
+    PSET_POWER pfnSetPower;
+    PADD_INTERFACE pfnAddInterface;
+    PDELETE_INTERFACE pfnDeleteInterface;
+    PINTERFACE_STATUS pfnInterfaceStatus;
+    PGET_INTERFACE_INFO pfnGetInterfaceInfo;
+    PSET_INTERFACE_INFO pfnSetInterfaceInfo;
+    PGET_EVENT_MESSAGE pfnGetEventMessage;
+    PDO_UPDATE_ROUTES pfnUpdateRoutes;
+    PCONNECT_CLIENT pfnConnectClient;
+    PDISCONNECT_CLIENT pfnDisconnectClient;
+    PGET_NEIGHBORS pfnGetNeighbors;
+    PGET_MFE_STATUS pfnGetMfeStatus;
+    PMIB_CREATE pfnMibCreateEntry;
+    PMIB_DELETE pfnMibDeleteEntry;
+    PMIB_GET pfnMibGetEntry;
+    PMIB_SET pfnMibSetEntry;
+    PMIB_GET_FIRST pfnMibGetFirstEntry;
+    PMIB_GET_NEXT pfnMibGetNextEntry;
+    PMIB_SET_TRAP_INFO pfnMibSetTrapInfo;
+    PMIB_GET_TRAP_INFO pfnMibGetTrapInfo;
+  } MPR50_ROUTING_CHARACTERISTICS;
+#if MPR50
+  typedef MPR50_ROUTING_CHARACTERISTICS MPR_ROUTING_CHARACTERISTICS;
+#endif
+  typedef MPR_ROUTING_CHARACTERISTICS *PMPR_ROUTING_CHARACTERISTICS;
+#define REGISTER_PROTOCOL_ENTRY_POINT RegisterProtocol
+#define REGISTER_PROTOCOL_ENTRY_POINT_STRING "RegisterProtocol"
+  typedef DWORD (WINAPI * PREGISTER_PROTOCOL) (IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar, IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -uNr w32api-3.5/include/rtmv2.h w32api-3.5-xorp/include/rtmv2.h
--- w32api-3.5/include/rtmv2.h	Wed Dec  7 15:43:33 2005
+++ w32api-3.5-xorp/include/rtmv2.h	Wed Dec  7 15:45:49 2005
@@ -0,0 +1,289 @@
+#ifndef __ROUTING_RTMv2_H__
+#define __ROUTING_RTMv2_H__
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#define RTM_MAX_ADDRESS_SIZE 16
+#define RTM_MAX_VIEWS 32
+#define RTM_VIEW_ID_UCAST 0
+#define RTM_VIEW_ID_MCAST 1
+#define RTM_VIEW_MASK_SIZE 0x20
+#define RTM_VIEW_MASK_NONE 0x00000000
+#define RTM_VIEW_MASK_ANY 0x00000000
+#define RTM_VIEW_MASK_UCAST 0x00000001
+#define RTM_VIEW_MASK_MCAST 0x00000002
+#define RTM_VIEW_MASK_ALL 0xFFFFFFFF
+  typedef INT RTM_VIEW_ID, *PRTM_VIEW_ID;
+  typedef DWORD RTM_VIEW_SET, *PRTM_VIEW_SET;
+  typedef struct _RTM_REGN_PROFILE
+  {
+    UINT MaxNextHopsInRoute;
+    UINT MaxHandlesInEnum;
+    RTM_VIEW_SET ViewsSupported;
+    UINT NumberOfViews;
+  } RTM_REGN_PROFILE, *PRTM_REGN_PROFILE;
+  typedef HANDLE RTM_ENTITY_HANDLE, *PRTM_ENTITY_HANDLE, RTM_DEST_HANDLE, *PRTM_DEST_HANDLE, RTM_ROUTE_HANDLE, *PRTM_ROUTE_HANDLE, RTM_NEXTHOP_HANDLE, *PRTM_NEXTHOP_HANDLE, RTM_ENUM_HANDLE, *PRTM_ENUM_HANDLE, RTM_ROUTE_LIST_HANDLE, *PRTM_ROUTE_LIST_HANDLE, RTM_NOTIFY_HANDLE, *PRTM_NOTIFY_HANDLE;
+  typedef struct _RTM_NET_ADDRESS
+  {
+    USHORT AddressFamily;
+    USHORT NumBits;
+    UCHAR AddrBits[RTM_MAX_ADDRESS_SIZE];
+  } RTM_NET_ADDRESS, *PRTM_NET_ADDRESS;
+#define RTM_IPV4_MAKE_NET_ADDRESS(NetAddress, Addr, Len) RTM_IPV4_SET_ADDR_AND_LEN(NetAddress, Addr, Len)
+#define RTM_CHECK_NTH_BIT(Value, N, Len) if ((Value) & (1 << (N))) { (Len) += (N); (Value) <<= (N); }
+#define RTM_IPV4_LEN_FROM_MASK(Len, Mask) { ULONG _Temp_ = ntohl(Mask); (Len) = 0; RTM_CHECK_NTH_BIT(_Temp_, 16, (Len)); RTM_CHECK_NTH_BIT(_Temp_, 8, (Len)); RTM_CHECK_NTH_BIT(_Temp_, 4, (Len)); while (_Temp_) { (Len) += 1; _Temp_ <<= 1; } }
+#define RTM_IPV4_MASK_FROM_LEN(Len) ((Len) ? htonl(~0 << (32 - (Len))): 0);
+#define RTM_IPV4_SET_ADDR_AND_LEN(NetAddress, Addr, Len) (NetAddress)->AddressFamily = AF_INET; (NetAddress)->NumBits = (USHORT) (Len); (* (ULONG *) ((NetAddress)->AddrBits)) = (Addr);
+#define RTM_IPV4_GET_ADDR_AND_LEN(Addr, Len, NetAddress) (Len) = (NetAddress)->NumBits; (Addr) = (* (ULONG *) ((NetAddress)->AddrBits));
+#define RTM_IPV4_SET_ADDR_AND_MASK(NetAddress, Addr, Mask) (NetAddress)->AddressFamily = AF_INET; (* (ULONG *) ((NetAddress)->AddrBits)) = (Addr); RTM_IPV4_LEN_FROM_MASK((NetAddress)->NumBits, Mask)
+#define RTM_IPV4_GET_ADDR_AND_MASK(Addr, Mask, NetAddress) (Addr) = (* (ULONG *) ((NetAddress)->AddrBits)); (Mask) = RTM_IPV4_MASK_FROM_LEN((NetAddress)->NumBits);
+  typedef struct _RTM_PREF_INFO
+  {
+    ULONG Metric;
+    ULONG Preference;
+  } RTM_PREF_INFO, *PRTM_PREF_INFO;
+  typedef struct _RTM_NEXTHOP_LIST
+  {
+    USHORT NumNextHops;
+    RTM_NEXTHOP_HANDLE NextHops[1];
+  } RTM_NEXTHOP_LIST, *PRTM_NEXTHOP_LIST;
+  typedef struct _RTM_DEST_INFO
+  {
+    RTM_DEST_HANDLE DestHandle;
+    RTM_NET_ADDRESS DestAddress;
+    FILETIME LastChanged;
+    RTM_VIEW_SET BelongsToViews;
+    UINT NumberOfViews;
+    struct
+    {
+      RTM_VIEW_ID ViewId;
+      UINT NumRoutes;
+      RTM_ROUTE_HANDLE Route;
+      RTM_ENTITY_HANDLE Owner;
+      DWORD DestFlags;
+      RTM_ROUTE_HANDLE HoldRoute;
+    } ViewInfo[1];
+  } RTM_DEST_INFO, *PRTM_DEST_INFO;
+#define RTM_BASIC_DEST_INFO_SIZE FIELD_OFFSET(RTM_DEST_INFO, ViewInfo)
+#define RTM_DEST_VIEW_INFO_SIZE (sizeof(RTM_DEST_INFO) - RTM_BASIC_DEST_INFO_SIZE)
+#define RTM_SIZE_OF_DEST_INFO(NumViews) (RTM_BASIC_DEST_INFO_SIZE + (NumViews) * RTM_DEST_VIEW_INFO_SIZE)
+#define RTM_DEST_FLAG_NATURAL_NET 0x01
+#define RTM_DEST_FLAG_FWD_ENGIN_ADD 0x02
+#define RTM_DEST_FLAG_DONT_FORWARD 0x04
+  typedef struct _RTM_ROUTE_INFO
+  {
+    RTM_DEST_HANDLE DestHandle;
+    RTM_ENTITY_HANDLE RouteOwner;
+    RTM_NEXTHOP_HANDLE Neighbour;
+    UCHAR State;
+    UCHAR Flags1;
+    USHORT Flags;
+    RTM_PREF_INFO PrefInfo;
+    RTM_VIEW_SET BelongsToViews;
+    PVOID EntitySpecificInfo;
+    RTM_NEXTHOP_LIST NextHopsList;
+  } RTM_ROUTE_INFO, *PRTM_ROUTE_INFO;
+#define RTM_BASIC_ROUTE_INFO_SIZE FIELD_OFFSET(RTM_ROUTE_INFO, NextHopsList.NumNextHops)
+#define RTM_SIZE_OF_ROUTE_INFO(NumHops) (RTM_BASIC_ROUTE_INFO_SIZE + (NumHops) * sizeof(RTM_NEXTHOP_HANDLE))
+#define RTM_ROUTE_STATE_CREATED 0
+#define RTM_ROUTE_STATE_DELETING 1
+#define RTM_ROUTE_STATE_DELETED 2
+#define RTM_ROUTE_FLAGS_MARTIAN 0x0001
+#define RTM_ROUTE_FLAGS_BLACKHOLE 0x0002
+#define RTM_ROUTE_FLAGS_DISCARD 0x0004
+#define RTM_ROUTE_FLAGS_INACTIVE 0x0008
+#define RTM_ROUTE_FLAGS_LOCAL 0x0010
+#define RTM_ROUTE_FLAGS_REMOTE 0x0020
+#define RTM_ROUTE_FLAGS_MYSELF 0x0040
+#define RTM_ROUTE_FLAGS_LOOPBACK 0x0080
+#define RTM_ROUTE_FLAGS_MCAST 0x0100
+#define RTM_ROUTE_FLAGS_LOCAL_MCAST 0x0200
+#define RTM_ROUTE_FLAGS_LIMITED_BC 0x0400
+#define RTM_ROUTE_FLAGS_ZEROS_NETBC 0x1000
+#define RTM_ROUTE_FLAGS_ZEROS_SUBNETBC 0x2000
+#define RTM_ROUTE_FLAGS_ONES_NETBC 0x4000
+#define RTM_ROUTE_FLAGS_ONES_SUBNETBC 0x8000
+#define RTM_ROUTE_FLAGS_FORWARDING (RTM_ROUTE_FLAGS_MARTIAN | RTM_ROUTE_FLAGS_BLACKHOLE | RTM_ROUTE_FLAGS_DISCARD | RTM_ROUTE_FLAGS_INACTIVE)
+#define RTM_ROUTE_FLAGS_ANY_UNICAST (RTM_ROUTE_FLAGS_LOCAL | RTM_ROUTE_FLAGS_REMOTE | RTM_ROUTE_FLAGS_MYSELF)
+#define RTM_ROUTE_FLAGS_ANY_MCAST (RTM_ROUTE_FLAGS_MCAST | RTM_ROUTE_FLAGS_LOCAL_MCAST)
+#define RTM_ROUTE_FLAGS_SUBNET_BCAST (RTM_ROUTE_FLAGS_ONES_SUBNET_BC | RTM_ROUTE_FLAGS_ZEROS_SUBNETBC)
+#define RTM_ROUTE_FLAGS_NET_BCAST (RTM_ROUTE_FLAGS_ONES_NETBC | RTM_ROUTE_FLAGS_ZEROS_NETBC)
+#define RTM_ROUTE_FLAGS_ANY_BCAST (RTM_ROUTE_FLAGS_LIMITED_BC | RTM_ROUTE_FLAGS_ONES_NETBC | RTM_ROUTE_FLAGS_ONES_SUBNET_BC | RTM_ROUTE_FLAGS_ZEROS_NETBC | RTM_ROUTE_FLAGS_ZEROS_SUBNETBC)
+  typedef struct _RTM_NEXTHOP_INFO
+  {
+    RTM_NET_ADDRESS NextHopAddress;
+    RTM_ENTITY_HANDLE NextHopOwner;
+    ULONG InterfaceIndex;
+    USHORT State;
+    USHORT Flags;
+    PVOID EntitySpecificInfo;
+    RTM_DEST_HANDLE RemoteNextHop;
+  } RTM_NEXTHOP_INFO, *PRTM_NEXTHOP_INFO;
+#define RTM_NEXTHOP_STATE_CREATED 0
+#define RTM_NEXTHOP_STATE_DELETED 1
+#define RTM_NEXTHOP_FLAGS_REMOTE 0x0001
+#define RTM_NEXTHOP_FLAGS_DOWN 0x0002
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+#pragma warning(disable : 4201)
+  typedef struct _RTM_ENTITY_ID
+  {
+    union
+    {
+      struct
+      {
+	ULONG EntityProtocolId;
+	ULONG EntityInstanceId;
+      };
+      ULONGLONG EntityId;
+    };
+  } RTM_ENTITY_ID, *PRTM_ENTITY_ID;
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#else
+#pragma warning(default : 4201)
+#endif
+  typedef struct _RTM_ENTITY_INFO
+  {
+    USHORT RtmInstanceId;
+    USHORT AddressFamily;
+    RTM_ENTITY_ID EntityId;
+  } RTM_ENTITY_INFO, *PRTM_ENTITY_INFO;
+  typedef enum _RTM_EVENT_TYPE
+  { RTM_ENTITY_REGISTERED, RTM_ENTITY_DEREGISTERED, RTM_ROUTE_EXPIRED, RTM_CHANGE_NOTIFICATION } RTM_EVENT_TYPE, *PRTM_EVENT_TYPE;
+  typedef DWORD (WINAPI * _EVENT_CALLBACK) (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_EVENT_TYPE EventType, IN PVOID Context1, IN PVOID Context2);
+  typedef _EVENT_CALLBACK RTM_EVENT_CALLBACK, *PRTM_EVENT_CALLBACK;
+#define METHOD_TYPE_ALL_METHODS 0xFFFFFFFF
+#define METHOD_RIP2_NEIGHBOUR_ADDR 0x00000001
+#define METHOD_RIP2_OUTBOUND_INTF 0x00000002
+#define METHOD_RIP2_ROUTE_TAG 0x00000004
+#define METHOD_RIP2_ROUTE_TIMESTAMP 0x00000008
+#define METHOD_OSPF_ROUTE_TYPE 0x00000001
+#define METHOD_OSPF_ROUTE_METRIC 0x00000002
+#define METHOD_OSPF_LSDB_TYPE 0x00000004
+#define METHOD_OSPF_ROUTE_TAG 0x00000008
+#define METHOD_OSPF_ROUTE_AREA 0x00000010
+#define METHOD_OSPF_FWD_ADDRESS 0x00000020
+#define METHOD_BGP4_AS_PATH 0x00000001
+#define METHOD_BGP4_PEER_ID 0x00000002
+#define METHOD_BGP4_PA_ORIGIN 0x00000004
+#define METHOD_BGP4_NEXTHOP_ATTR 0x00000008
+  typedef DWORD RTM_ENTITY_METHOD_TYPE, *PRTM_ENTITY_METHOD_TYPE;
+  typedef struct _RTM_ENTITY_METHOD_INPUT
+  {
+    RTM_ENTITY_METHOD_TYPE MethodType;
+    UINT InputSize;
+    UCHAR InputData[1];
+  } RTM_ENTITY_METHOD_INPUT, *PRTM_ENTITY_METHOD_INPUT;
+  typedef struct _RTM_ENTITY_METHOD_OUTPUT
+  {
+    RTM_ENTITY_METHOD_TYPE MethodType;
+    DWORD MethodStatus;
+    UINT OutputSize;
+    UCHAR OutputData[1];
+  } RTM_ENTITY_METHOD_OUTPUT, *PRTM_ENTITY_METHOD_OUTPUT;
+  typedef VOID (WINAPI * _ENTITY_METHOD) (IN RTM_ENTITY_HANDLE CallerHandle, IN RTM_ENTITY_HANDLE CalleeHandle, IN RTM_ENTITY_METHOD_INPUT * Input, OUT RTM_ENTITY_METHOD_OUTPUT * Output);
+  typedef _ENTITY_METHOD RTM_ENTITY_EXPORT_METHOD, *PRTM_ENTITY_EXPORT_METHOD;
+  typedef struct _RTM_ENTITY_EXPORT_METHODS
+  {
+    UINT NumMethods;
+    RTM_ENTITY_EXPORT_METHOD Methods[1];
+  } RTM_ENTITY_EXPORT_METHODS, *PRTM_ENTITY_EXPORT_METHODS;
+#define RTM_RESUME_METHODS 0
+#define RTM_BLOCK_METHODS 1
+  typedef DWORD RTM_ROUTE_CHANGE_FLAGS, *PRTM_ROUTE_CHANGE_FLAGS;
+#define RTM_ROUTE_CHANGE_FIRST 0x01
+#define RTM_ROUTE_CHANGE_NEW 0x02
+#define RTM_ROUTE_CHANGE_BEST 0x00010000
+  typedef DWORD RTM_NEXTHOP_CHANGE_FLAGS, *PRTM_NEXTHOP_CHANGE_FLAGS;
+#define RTM_NEXTHOP_CHANGE_NEW 0x01
+  typedef DWORD RTM_MATCH_FLAGS, *PRTM_MATCH_FLAGS;
+#define RTM_MATCH_NONE 0x00000000
+#define RTM_MATCH_OWNER 0x00000001
+#define RTM_MATCH_NEIGHBOUR 0x00000002
+#define RTM_MATCH_PREF 0x00000004
+#define RTM_MATCH_NEXTHOP 0x00000008
+#define RTM_MATCH_INTERFACE 0x00000010
+#define RTM_MATCH_FULL 0x0000FFFF
+#define RTM_BEST_PROTOCOL (ULONG) 0
+#define RTM_THIS_PROTOCOL (ULONG) ~0
+  typedef DWORD RTM_ENUM_FLAGS, *PRTM_ENUM_FLAGS;
+#define RTM_ENUM_START 0x00000000
+#define RTM_ENUM_NEXT 0x00000001
+#define RTM_ENUM_RANGE 0x00000002
+#define RTM_ENUM_ALL_DESTS 0x00000000
+#define RTM_ENUM_OWN_DESTS 0x01000000
+#define RTM_ENUM_ALL_ROUTES 0x00000000
+#define RTM_ENUM_OWN_ROUTES 0x00010000
+  typedef DWORD RTM_NOTIFY_FLAGS, *PRTM_NOTIFY_FLAGS;
+#define RTM_NUM_CHANGE_TYPES 3
+#define RTM_CHANGE_TYPE_ALL 0x0001
+#define RTM_CHANGE_TYPE_BEST 0x0002
+#define RTM_CHANGE_TYPE_FORWARDING 0x0004
+#define RTM_NOTIFY_ONLY_MARKED_DESTS 0x00010000
+  DWORD WINAPI RtmRegisterEntity (IN PRTM_ENTITY_INFO RtmEntityInfo, IN PRTM_ENTITY_EXPORT_METHODS ExportMethods OPTIONAL, IN RTM_EVENT_CALLBACK EventCallback, IN BOOL ReserveOpaquePointer, OUT PRTM_REGN_PROFILE RtmRegProfile, OUT PRTM_ENTITY_HANDLE RtmRegHandle);
+  DWORD WINAPI RtmDeregisterEntity (IN RTM_ENTITY_HANDLE RtmRegHandle);
+  DWORD WINAPI RtmGetRegisteredEntities (IN RTM_ENTITY_HANDLE RtmRegHandle, IN OUT PUINT NumEntities, OUT PRTM_ENTITY_HANDLE EntityHandles, OUT PRTM_ENTITY_INFO EntityInfos OPTIONAL);
+  DWORD WINAPI RtmReleaseEntities (IN RTM_ENTITY_HANDLE RtmRegHandle, IN UINT NumEntities, IN PRTM_ENTITY_HANDLE EntityHandles);
+  DWORD WINAPI RtmLockDestination (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_DEST_HANDLE DestHandle, IN BOOL Exclusive, IN BOOL LockDest);
+  DWORD WINAPI RtmGetOpaqueInformationPointer (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_DEST_HANDLE DestHandle, OUT PVOID * OpaqueInfoPointer);
+  DWORD WINAPI RtmGetEntityMethods (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENTITY_HANDLE EntityHandle, IN OUT PUINT NumMethods, OUT PRTM_ENTITY_EXPORT_METHOD ExptMethods);
+  DWORD WINAPI RtmInvokeMethod (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENTITY_HANDLE EntityHandle, IN PRTM_ENTITY_METHOD_INPUT Input, IN OUT PUINT OutputSize, OUT PRTM_ENTITY_METHOD_OUTPUT Output);
+  DWORD WINAPI RtmBlockMethods (IN RTM_ENTITY_HANDLE RtmRegHandle, IN HANDLE TargetHandle OPTIONAL, IN UCHAR TargetType OPTIONAL, IN DWORD BlockingFlag);
+  DWORD WINAPI RtmGetEntityInfo (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENTITY_HANDLE EntityHandle, OUT PRTM_ENTITY_INFO EntityInfo);
+  DWORD WINAPI RtmGetDestInfo (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_DEST_HANDLE DestHandle, IN ULONG ProtocolId, IN RTM_VIEW_SET TargetViews, OUT PRTM_DEST_INFO DestInfo);
+  DWORD WINAPI RtmGetRouteInfo (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_HANDLE RouteHandle, OUT PRTM_ROUTE_INFO RouteInfo OPTIONAL, OUT PRTM_NET_ADDRESS DestAddress OPTIONAL);
+  DWORD WINAPI RtmGetNextHopInfo (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NEXTHOP_HANDLE NextHopHandle, OUT PRTM_NEXTHOP_INFO NextHopInfo);
+  DWORD WINAPI RtmReleaseEntityInfo (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_ENTITY_INFO EntityInfo);
+  DWORD WINAPI RtmReleaseDestInfo (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_DEST_INFO DestInfo);
+  DWORD WINAPI RtmReleaseRouteInfo (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_ROUTE_INFO RouteInfo);
+  DWORD WINAPI RtmReleaseNextHopInfo (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_NEXTHOP_INFO NextHopInfo);
+  DWORD WINAPI RtmAddRouteToDest (IN RTM_ENTITY_HANDLE RtmRegHandle, IN OUT PRTM_ROUTE_HANDLE RouteHandle OPTIONAL, IN PRTM_NET_ADDRESS DestAddress, IN PRTM_ROUTE_INFO RouteInfo, IN ULONG TimeToLive, IN RTM_ROUTE_LIST_HANDLE RouteListHandle OPTIONAL, IN RTM_NOTIFY_FLAGS NotifyType, IN RTM_NOTIFY_HANDLE NotifyHandle OPTIONAL, IN OUT PRTM_ROUTE_CHANGE_FLAGS ChangeFlags);
+  DWORD WINAPI RtmDeleteRouteToDest (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_HANDLE RouteHandle, OUT PRTM_ROUTE_CHANGE_FLAGS ChangeFlags);
+  DWORD WINAPI RtmHoldDestination (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_DEST_HANDLE DestHandle, IN RTM_VIEW_SET TargetViews, IN ULONG HoldTime);
+  DWORD WINAPI RtmGetRoutePointer (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_HANDLE RouteHandle, OUT PRTM_ROUTE_INFO * RoutePointer);
+  DWORD WINAPI RtmLockRoute (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_HANDLE RouteHandle, IN BOOL Exclusive, IN BOOL LockRoute, OUT PRTM_ROUTE_INFO * RoutePointer OPTIONAL);
+  DWORD WINAPI RtmUpdateAndUnlockRoute (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_HANDLE RouteHandle, IN ULONG TimeToLive, IN RTM_ROUTE_LIST_HANDLE RouteListHandle OPTIONAL, IN RTM_NOTIFY_FLAGS NotifyType, IN RTM_NOTIFY_HANDLE NotifyHandle OPTIONAL, OUT PRTM_ROUTE_CHANGE_FLAGS ChangeFlags);
+  DWORD WINAPI RtmGetExactMatchDestination (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_NET_ADDRESS DestAddress, IN ULONG ProtocolId, IN RTM_VIEW_SET TargetViews, OUT PRTM_DEST_INFO DestInfo);
+  DWORD WINAPI RtmGetMostSpecificDestination (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_NET_ADDRESS DestAddress, IN ULONG ProtocolId, IN RTM_VIEW_SET TargetViews, OUT PRTM_DEST_INFO DestInfo);
+  DWORD WINAPI RtmGetLessSpecificDestination (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_DEST_HANDLE DestHandle, IN ULONG ProtocolId, IN RTM_VIEW_SET TargetViews, OUT PRTM_DEST_INFO DestInfo);
+  DWORD WINAPI RtmGetExactMatchRoute (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_NET_ADDRESS DestAddress, IN RTM_MATCH_FLAGS MatchingFlags, IN OUT PRTM_ROUTE_INFO RouteInfo, IN ULONG InterfaceIndex, IN RTM_VIEW_SET TargetViews, OUT PRTM_ROUTE_HANDLE RouteHandle);
+  DWORD WINAPI RtmIsBestRoute (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_HANDLE RouteHandle, OUT PRTM_VIEW_SET BestInViews);
+  DWORD WINAPI RtmAddNextHop (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_NEXTHOP_INFO NextHopInfo, IN OUT PRTM_NEXTHOP_HANDLE NextHopHandle OPTIONAL, OUT PRTM_NEXTHOP_CHANGE_FLAGS ChangeFlags);
+  DWORD WINAPI RtmFindNextHop (IN RTM_ENTITY_HANDLE RtmRegHandle, IN PRTM_NEXTHOP_INFO NextHopInfo, OUT PRTM_NEXTHOP_HANDLE NextHopHandle, OUT PRTM_NEXTHOP_INFO * NextHopPointer OPTIONAL);
+  DWORD WINAPI RtmDeleteNextHop (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NEXTHOP_HANDLE NextHopHandle OPTIONAL, IN PRTM_NEXTHOP_INFO NextHopInfo);
+  DWORD WINAPI RtmGetNextHopPointer (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NEXTHOP_HANDLE NextHopHandle, OUT PRTM_NEXTHOP_INFO * NextHopPointer);
+  DWORD WINAPI RtmLockNextHop (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NEXTHOP_HANDLE NextHopHandle, IN BOOL Exclusive, IN BOOL LockNextHop, OUT PRTM_NEXTHOP_INFO * NextHopPointer OPTIONAL);
+  DWORD WINAPI RtmCreateDestEnum (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_VIEW_SET TargetViews, IN RTM_ENUM_FLAGS EnumFlags, IN PRTM_NET_ADDRESS NetAddress, IN ULONG ProtocolId, OUT PRTM_ENUM_HANDLE RtmEnumHandle);
+  DWORD WINAPI RtmGetEnumDests (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENUM_HANDLE EnumHandle, IN OUT PUINT NumDests, OUT PRTM_DEST_INFO DestInfos);
+  DWORD WINAPI RtmReleaseDests (IN RTM_ENTITY_HANDLE RtmRegHandle, IN UINT NumDests, IN PRTM_DEST_INFO DestInfos);
+  DWORD WINAPI RtmCreateRouteEnum (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_DEST_HANDLE DestHandle OPTIONAL, IN RTM_VIEW_SET TargetViews, IN RTM_ENUM_FLAGS EnumFlags, IN PRTM_NET_ADDRESS StartDest OPTIONAL, IN RTM_MATCH_FLAGS MatchingFlags, IN PRTM_ROUTE_INFO CriteriaRoute OPTIONAL, IN ULONG CriteriaInterface OPTIONAL, OUT PRTM_ENUM_HANDLE RtmEnumHandle);
+  DWORD WINAPI RtmGetEnumRoutes (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENUM_HANDLE EnumHandle, IN OUT PUINT NumRoutes, OUT PRTM_ROUTE_HANDLE RouteHandles);
+  DWORD WINAPI RtmReleaseRoutes (IN RTM_ENTITY_HANDLE RtmRegHandle, IN UINT NumRoutes, IN PRTM_ROUTE_HANDLE RouteHandles);
+  DWORD WINAPI RtmCreateNextHopEnum (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENUM_FLAGS EnumFlags, IN PRTM_NET_ADDRESS NetAddress, OUT PRTM_ENUM_HANDLE RtmEnumHandle);
+  DWORD WINAPI RtmGetEnumNextHops (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENUM_HANDLE EnumHandle, IN OUT PUINT NumNextHops, OUT PRTM_NEXTHOP_HANDLE NextHopHandles);
+  DWORD WINAPI RtmReleaseNextHops (IN RTM_ENTITY_HANDLE RtmRegHandle, IN UINT NumNextHops, IN PRTM_NEXTHOP_HANDLE NextHopHandles);
+  DWORD WINAPI RtmDeleteEnumHandle (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENUM_HANDLE EnumHandle);
+  DWORD WINAPI RtmRegisterForChangeNotification (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_VIEW_SET TargetViews, IN RTM_NOTIFY_FLAGS NotifyFlags, IN PVOID NotifyContext, OUT PRTM_NOTIFY_HANDLE NotifyHandle);
+  DWORD WINAPI RtmGetChangedDests (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NOTIFY_HANDLE NotifyHandle, IN OUT PUINT NumDests, OUT PRTM_DEST_INFO ChangedDests);
+  DWORD WINAPI RtmReleaseChangedDests (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NOTIFY_HANDLE NotifyHandle, IN UINT NumDests, IN PRTM_DEST_INFO ChangedDests);
+  DWORD WINAPI RtmIgnoreChangedDests (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NOTIFY_HANDLE NotifyHandle, IN UINT NumDests, IN PRTM_DEST_HANDLE ChangedDests);
+  DWORD WINAPI RtmGetChangeStatus (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NOTIFY_HANDLE NotifyHandle, IN RTM_DEST_HANDLE DestHandle, OUT PBOOL ChangeStatus);
+  DWORD WINAPI RtmMarkDestForChangeNotification (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NOTIFY_HANDLE NotifyHandle, IN RTM_DEST_HANDLE DestHandle, IN BOOL MarkDest);
+  DWORD WINAPI RtmIsMarkedForChangeNotification (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NOTIFY_HANDLE NotifyHandle, IN RTM_DEST_HANDLE DestHandle, OUT PBOOL DestMarked);
+  DWORD WINAPI RtmDeregisterFromChangeNotification (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_NOTIFY_HANDLE NotifyHandle);
+  DWORD WINAPI RtmCreateRouteList (IN RTM_ENTITY_HANDLE RtmRegHandle, OUT PRTM_ROUTE_LIST_HANDLE RouteListHandle);
+  DWORD WINAPI RtmInsertInRouteList (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_LIST_HANDLE RouteListHandle OPTIONAL, IN UINT NumRoutes, IN PRTM_ROUTE_HANDLE RouteHandles);
+  DWORD WINAPI RtmCreateRouteListEnum (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_LIST_HANDLE RouteListHandle, OUT PRTM_ENUM_HANDLE RtmEnumHandle);
+  DWORD WINAPI RtmGetListEnumRoutes (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ENUM_HANDLE EnumHandle, IN OUT PUINT NumRoutes, OUT PRTM_ROUTE_HANDLE RouteHandles);
+  DWORD WINAPI RtmDeleteRouteList (IN RTM_ENTITY_HANDLE RtmRegHandle, IN RTM_ROUTE_LIST_HANDLE RouteListHandle);
+  DWORD WINAPI RtmReferenceHandles (IN RTM_ENTITY_HANDLE RtmRegHandle, IN UINT NumHandles, IN HANDLE * RtmHandles);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -uNr w32api-3.5/include/rtutils.h w32api-3.5-xorp/include/rtutils.h
--- w32api-3.5/include/rtutils.h	Wed Dec  7 15:43:40 2005
+++ w32api-3.5-xorp/include/rtutils.h	Wed Dec  7 15:45:49 2005
@@ -0,0 +1,284 @@
+#ifndef __ROUTING_RTUTILS_H__
+#define __ROUTING_RTUTILS_H__
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#define TRACE_USE_FILE 0x00000001
+#define TRACE_USE_CONSOLE 0x00000002
+#define TRACE_NO_SYNCH 0x00000004
+#define TRACE_NO_STDINFO 0x00000001
+#define TRACE_USE_MASK 0x00000002
+#define TRACE_USE_MSEC 0x00000004
+#define TRACE_USE_DATE 0x00000008
+#define INVALID_TRACEID 0xFFFFFFFF
+  DWORD APIENTRY TraceRegisterExA (IN LPCSTR lpszCallerName, IN DWORD dwFlags);
+  DWORD APIENTRY TraceDeregisterA (IN DWORD dwTraceID);
+  DWORD APIENTRY TraceDeregisterExA (IN DWORD dwTraceID, IN DWORD dwFlags);
+  DWORD APIENTRY TraceGetConsoleA (IN DWORD dwTraceID, OUT LPHANDLE lphConsole);
+  DWORD __cdecl TracePrintfA (IN DWORD dwTraceID, IN LPCSTR lpszFormat, IN ... OPTIONAL);
+  DWORD __cdecl TracePrintfExA (IN DWORD dwTraceID, IN DWORD dwFlags, IN LPCSTR lpszFormat, IN ... OPTIONAL);
+  DWORD APIENTRY TraceVprintfExA (IN DWORD dwTraceID, IN DWORD dwFlags, IN LPCSTR lpszFormat, IN va_list arglist);
+  DWORD APIENTRY TracePutsExA (IN DWORD dwTraceID, IN DWORD dwFlags, IN LPCSTR lpszString);
+  DWORD APIENTRY TraceDumpExA (IN DWORD dwTraceID, IN DWORD dwFlags, IN LPBYTE lpbBytes, IN DWORD dwByteCount, IN DWORD dwGroupSize, IN BOOL bAddressPrefix, IN LPCSTR lpszPrefix);
+#define TraceRegisterA(a) TraceRegisterExA(a,0)
+#define TraceVprintfA(a,b,c) TraceVprintfExA(a,0,b,c)
+#define TracePutsA(a,b) TracePutsExA(a,0,b)
+#define TraceDumpA(a,b,c,d,e,f) TraceDumpExA(a,0,b,c,d,e,f)
+  DWORD APIENTRY TraceRegisterExW (IN LPCWSTR lpszCallerName, IN DWORD dwFlags);
+  DWORD APIENTRY TraceDeregisterW (IN DWORD dwTraceID);
+  DWORD APIENTRY TraceDeregisterExW (IN DWORD dwTraceID, IN DWORD dwFlags);
+  DWORD APIENTRY TraceGetConsoleW (IN DWORD dwTraceID, OUT LPHANDLE lphConsole);
+  DWORD __cdecl TracePrintfW (IN DWORD dwTraceID, IN LPCWSTR lpszFormat, IN ... OPTIONAL);
+  DWORD __cdecl TracePrintfExW (IN DWORD dwTraceID, IN DWORD dwFlags, IN LPCWSTR lpszFormat, IN ... OPTIONAL);
+  DWORD APIENTRY TraceVprintfExW (IN DWORD dwTraceID, IN DWORD dwFlags, IN LPCWSTR lpszFormat, IN va_list arglist);
+  DWORD APIENTRY TracePutsExW (IN DWORD dwTraceID, IN DWORD dwFlags, IN LPCWSTR lpszString);
+  DWORD APIENTRY TraceDumpExW (IN DWORD dwTraceID, IN DWORD dwFlags, IN LPBYTE lpbBytes, IN DWORD dwByteCount, IN DWORD dwGroupSize, IN BOOL bAddressPrefix, IN LPCWSTR lpszPrefix);
+#define TraceRegisterW(a) TraceRegisterExW(a,0)
+#define TraceVprintfW(a,b,c) TraceVprintfExW(a,0,b,c)
+#define TracePutsW(a,b) TracePutsExW(a,0,b)
+#define TraceDumpW(a,b,c,d,e,f) TraceDumpExW(a,0,b,c,d,e,f)
+#ifdef UNICODE
+#define TraceRegister TraceRegisterW
+#define TraceDeregister TraceDeregisterW
+#define TraceDeregisterEx TraceDeregisterExW
+#define TraceGetConsole TraceGetConsoleW
+#define TracePrintf TracePrintfW
+#define TraceVprintf TraceVprintfW
+#define TracePuts TracePutsW
+#define TraceDump TraceDumpW
+#define TraceRegisterEx TraceRegisterExW
+#define TracePrintfEx TracePrintfExW
+#define TraceVprintfEx TraceVprintfExW
+#define TracePutsEx TracePutsExW
+#define TraceDumpEx TraceDumpExW
+#else
+#define TraceRegister TraceRegisterA
+#define TraceDeregister TraceDeregisterA
+#define TraceDeregisterEx TraceDeregisterExA
+#define TraceGetConsole TraceGetConsoleA
+#define TracePrintf TracePrintfA
+#define TraceVprintf TraceVprintfA
+#define TracePuts TracePutsA
+#define TraceDump TraceDumpA
+#define TraceRegisterEx TraceRegisterExA
+#define TracePrintfEx TracePrintfExA
+#define TraceVprintfEx TraceVprintfExA
+#define TracePutsEx TracePutsExA
+#define TraceDumpEx TraceDumpExA
+#endif
+  VOID APIENTRY LogErrorA (IN DWORD dwMessageId, IN DWORD cNumberOfSubStrings, IN LPSTR * plpwsSubStrings, IN DWORD dwErrorCode);
+  VOID APIENTRY LogEventA (IN DWORD wEventType, IN DWORD dwMessageId, IN DWORD cNumberOfSubStrings, IN LPSTR * plpwsSubStrings);
+  VOID LogErrorW (IN DWORD dwMessageId, IN DWORD cNumberOfSubStrings, IN LPWSTR * plpwsSubStrings, IN DWORD dwErrorCode);
+  VOID LogEventW (IN DWORD wEventType, IN DWORD dwMessageId, IN DWORD cNumberOfSubStrings, IN LPWSTR * plpwsSubStrings);
+#ifdef UNICODE
+#define LogError LogErrorW
+#define LogEvent LogEventW
+#else
+#define LogError LogErrorA
+#define LogEvent LogEventA
+#endif
+  HANDLE __stdcall RouterLogRegisterA (LPCSTR lpszSource);
+  VOID __stdcall RouterLogDeregisterA (HANDLE hLogHandle);
+  VOID __stdcall RouterLogEventA (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwMessageId, IN DWORD dwSubStringCount, IN LPSTR * plpszSubStringArray, IN DWORD dwErrorCode);
+  VOID __stdcall RouterLogEventDataA (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwMessageId, IN DWORD dwSubStringCount, IN LPSTR * plpszSubStringArray, IN DWORD dwDataBytes, IN LPBYTE lpDataBytes);
+  VOID __stdcall RouterLogEventStringA (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwMessageId, IN DWORD dwSubStringCount, IN LPSTR * plpszSubStringArray, IN DWORD dwErrorCode, IN DWORD dwErrorIndex);
+  VOID __cdecl RouterLogEventExA (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwErrorCode, IN DWORD dwMessageId, IN LPCSTR ptszFormat, ...);
+  VOID __stdcall RouterLogEventValistExA (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwErrorCode, IN DWORD dwMessageId, IN LPCSTR ptszFormat, IN va_list arglist);
+  DWORD __stdcall RouterGetErrorStringA (IN DWORD dwErrorCode, OUT LPSTR * lplpszErrorString);
+#define RouterLogErrorA(h,msg,count,array,err) RouterLogEventA(h,EVENTLOG_ERROR_TYPE,msg,count,array,err)
+#define RouterLogWarningA(h,msg,count,array,err) RouterLogEventA(h,EVENTLOG_WARNING_TYPE,msg,count,array,err)
+#define RouterLogInformationA(h,msg,count,array,err) RouterLogEventA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err)
+#define RouterLogErrorDataA(h,msg,count,array,c,buf) RouterLogEventDataA(h,EVENTLOG_ERROR_TYPE,msg,count,array,c,buf)
+#define RouterLogWarningDataA(h,msg,count,array,c,buf) RouterLogEventDataA(h,EVENTLOG_WARNING_TYPE,msg,count,array,c,buf)
+#define RouterLogInformationDataA(h,msg,count,array,c,buf) RouterLogEventDataA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,c,buf)
+#define RouterLogErrorStringA(h,msg,count,array,err,index) RouterLogEventStringA(h,EVENTLOG_ERROR_TYPE,msg,count,array, err,index)
+#define RouterLogWarningStringA(h,msg,count,array,err,index) RouterLogEventStringA(h,EVENTLOG_WARNING_TYPE,msg,count,array,err,index)
+#define RouterLogInformationStringA(h,msg,count,array, err,index) RouterLogEventStringA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err, index)
+  HANDLE RouterLogRegisterW (LPCWSTR lpszSource);
+  VOID RouterLogDeregisterW (HANDLE hLogHandle);
+  VOID RouterLogEventW (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwMessageId, IN DWORD dwSubStringCount, IN LPWSTR * plpszSubStringArray, IN DWORD dwErrorCode);
+  VOID RouterLogEventDataW (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwMessageId, IN DWORD dwSubStringCount, IN LPWSTR * plpszSubStringArray, IN DWORD dwDataBytes, IN LPBYTE lpDataBytes);
+  VOID RouterLogEventStringW (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwMessageId, IN DWORD dwSubStringCount, IN LPWSTR * plpszSubStringArray, IN DWORD dwErrorCode, IN DWORD dwErrorIndex);
+  VOID __cdecl RouterLogEventExW (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwErrorCode, IN DWORD dwMessageId, IN LPCWSTR ptszFormat, ...);
+  VOID RouterLogEventValistExW (IN HANDLE hLogHandle, IN DWORD dwEventType, IN DWORD dwErrorCode, IN DWORD dwMessageId, IN LPCWSTR ptszFormat, IN va_list arglist);
+  DWORD RouterGetErrorStringW (IN DWORD dwErrorCode, OUT LPWSTR * lplpwszErrorString);
+#define RouterLogErrorW(h,msg,count,array,err) RouterLogEventW(h,EVENTLOG_ERROR_TYPE,msg,count,array,err)
+#define RouterLogWarningW(h,msg,count,array,err) RouterLogEventW(h,EVENTLOG_WARNING_TYPE,msg,count,array,err)
+#define RouterLogInformationW(h,msg,count,array,err) RouterLogEventW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err)
+#define RouterLogErrorDataW(h,msg,count,array,c,buf) RouterLogEventDataW(h,EVENTLOG_ERROR_TYPE,msg,count,array,c,buf)
+#define RouterLogWarningDataW(h,msg,count,array,c,buf) RouterLogEventDataW(h,EVENTLOG_WARNING_TYPE,msg,count,array,c,buf)
+#define RouterLogInformationDataW(h,msg,count,array,c,buf) RouterLogEventDataW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,c,buf)
+#define RouterLogErrorStringW(h,msg,count,array,err,index) RouterLogEventStringW(h,EVENTLOG_ERROR_TYPE,msg,count,array,err,index)
+#define RouterLogWarningStringW(h,msg,count,array,err,index) RouterLogEventStringW(h,EVENTLOG_WARNING_TYPE,msg,count,array,err,index)
+#define RouterLogInformationStringW(h,msg,count,array,err,index) RouterLogEventStringW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err, index)
+#ifdef UNICODE
+#define RouterLogRegister RouterLogRegisterW
+#define RouterLogDeregister RouterLogDeregisterW
+#define RouterLogEvent RouterLogEventW
+#define RouterLogError RouterLogErrorW
+#define RouterLogWarning RouterLogWarningW
+#define RouterLogInformation RouterLogInformationW
+#define RouterLogEventData RouterLogEventDataW
+#define RouterLogErrorData RouterLogErrorDataW
+#define RouterLogWarningData RouterLogWarningDataW
+#define RouterLogInformationData RouterLogInformationDataW
+#define RouterLogEventString RouterLogEventStringW
+#define RouterLogEventEx RouterLogEventExW
+#define RouterLogEventValistEx RouterLogEventValistExW
+#define RouterLogErrorString RouterLogErrorStringW
+#define RouterLogWarningString RouterLogWarningStringW
+#define RouterLogInformationString RouterLogInformationStringW
+#define RouterGetErrorString RouterGetErrorStringW
+#
+#else
+#define RouterLogRegister RouterLogRegisterA
+#define RouterLogDeregister RouterLogDeregisterA
+#define RouterLogEvent RouterLogEventA
+#define RouterLogError RouterLogErrorA
+#define RouterLogWarning RouterLogWarningA
+#define RouterLogInformation RouterLogInformationA
+#define RouterLogEventData RouterLogEventDataA
+#define RouterLogErrorData RouterLogErrorDataA
+#define RouterLogWarningData RouterLogWarningDataA
+#define RouterLogInformationData RouterLogInformationDataA
+#define RouterLogEventString RouterLogEventStringA
+#define RouterLogEventEx RouterLogEventExA
+#define RouterLogEventValistEx RouterLogEventValistExA
+#define RouterLogErrorString RouterLogErrorStringA
+#define RouterLogWarningString RouterLogWarningStringA
+#define RouterLogInformationString RouterLogInformationStringA
+#define RouterGetErrorString RouterGetErrorStringA
+#endif
+  typedef VOID (APIENTRY * WORKERFUNCTION) (PVOID);
+  DWORD APIENTRY QueueWorkItem (IN WORKERFUNCTION functionptr, IN PVOID context, IN BOOL serviceinalertablethread);
+  DWORD APIENTRY SetIoCompletionProc (IN HANDLE FileHandle, IN LPOVERLAPPED_COMPLETION_ROUTINE CompletionProc);
+#define NUM_ALERTABLE_THREADS	2
+#define MAX_WORKER_THREADS 10
+#define WORK_QUEUE_TIMEOUT	1
+#define THREAD_IDLE_TIMEOUT	10
+  VOID RouterAssert (IN PSTR pszFailedAssertion, IN PSTR pszFileName, IN DWORD dwLineNumber, IN PSTR pszMessage OPTIONAL);
+#if DBG
+#define RTASSERT(exp) if (!(exp)) RouterAssert(#exp, __FILE__, __LINE__, NULL)
+#define RTASSERTMSG(msg, exp) if (!(exp)) RouterAssert(#exp, __FILE__, __LINE__, msg)
+#else
+#define RTASSERT(exp)
+#define RTASSERTMSG(msg, exp)
+#endif
+#define RTUTILS_MAX_PROTOCOL_NAME_LEN 40
+#define RTUTILS_MAX_PROTOCOL_DLL_LEN 48
+#ifndef MAX_PROTOCOL_NAME_LEN
+#define MAX_PROTOCOL_NAME_LEN RTUTILS_MAX_PROTOCOL_NAME_LEN
+#else
+#undef MAX_PROTOCOL_NAME_LEN
+#endif
+#define MAX_PROTOCOL_DLL_LEN RTUTILS_MAX_PROTOCOL_DLL_LEN
+  typedef struct _MPR_PROTOCOL_0
+  {
+    DWORD dwProtocolId;
+    WCHAR wszProtocol[RTUTILS_MAX_PROTOCOL_NAME_LEN + 1];
+    WCHAR wszDLLName[RTUTILS_MAX_PROTOCOL_DLL_LEN + 1];
+  } MPR_PROTOCOL_0;
+  DWORD APIENTRY MprSetupProtocolEnum (IN DWORD dwTransportId, OUT LPBYTE * lplpBuffer, OUT LPDWORD lpdwEntriesRead);
+  DWORD APIENTRY MprSetupProtocolFree (IN LPVOID lpBuffer);
+#define ROUTING_RESERVED
+#define OPT1_1
+#define OPT1_2
+#define OPT2_1
+#define OPT2_2
+#define OPT3_1
+#define OPT3_2
+#if 0
+  typedef struct _ASYNC_SOCKET_DATA
+  {
+    OVERLAPPED Overlapped;
+    IN WSABUF WsaBuf;
+    OUT SOCKADDR_IN SrcAddress;
+    OUT DWORD NumBytesReceived;
+    IN OUT DWORD Flags;
+    OUT DWORD Status;
+    IN WORKERFUNCTION pFunction;
+    IN PVOID pContext;
+  } ASYNC_SOCKET_DATA, *PASYNC_SOCKET_DATA;
+  DWORD APIENTRY AsyncSocketInit (SOCKET sock);
+  DWORD APIENTRY AsyncWSARecvFrom (SOCKET sock, PASYNC_SOCKET_DATA pSockData);
+#endif
+  struct _WAIT_THREAD_ENTRY;
+  struct _WT_EVENT_ENTRY;
+  typedef struct _WT_TIMER_ENTRY
+  {
+    LONGLONG te_Timeout;
+    WORKERFUNCTION te_Function;
+    PVOID te_Context;
+    DWORD te_ContextSz;
+    BOOL te_RunInServer;
+    DWORD te_Status;
+#define	TIMER_INACTIVE 3
+#define	TIMER_ACTIVE	4
+    DWORD te_ServerId;
+    struct _WAIT_THREAD_ENTRY *teP_wte;
+    LIST_ENTRY te_ServerLinks;
+    LIST_ENTRY te_Links;
+    BOOL te_Flag;
+    DWORD te_TimerId;
+  } WT_TIMER_ENTRY, *PWT_TIMER_ENTRY;
+  typedef struct _WT_WORK_ITEM
+  {
+    WORKERFUNCTION wi_Function;
+    PVOID wi_Context;
+    DWORD wi_ContextSz;
+    BOOL wi_RunInServer;
+    struct _WT_EVENT_ENTRY *wiP_ee;
+    LIST_ENTRY wi_ServerLinks;
+    LIST_ENTRY wi_Links;
+  } WT_WORK_ITEM, *PWT_WORK_ITEM;
+#define WT_EVENT_BINDING	WT_WORK_ITEM
+#define PWT_EVENT_BINDING	PWT_WORK_ITEM
+  typedef struct _WT_EVENT_ENTRY
+  {
+    HANDLE ee_Event;
+    BOOL ee_bManualReset;
+    BOOL ee_bInitialState;
+    BOOL ee_bDeleteEvent;
+    DWORD ee_Status;
+    BOOL ee_bHighPriority;
+    LIST_ENTRY eeL_wi;
+    BOOL ee_bSignalSingle;
+    BOOL ee_bOwnerSelf;
+    INT ee_ArrayIndex;
+    DWORD ee_ServerId;
+    struct _WAIT_THREAD_ENTRY *eeP_wte;
+    LIST_ENTRY ee_ServerLinks;
+    LIST_ENTRY ee_Links;
+    DWORD ee_RefCount;
+    BOOL ee_bFlag;
+    DWORD ee_EventId;
+  } WT_EVENT_ENTRY, *PWT_EVENT_ENTRY;
+  PWT_EVENT_ENTRY APIENTRY CreateWaitEvent (IN HANDLE pEvent OPT1_1, IN LPSECURITY_ATTRIBUTES lpEventAttributes OPT1_2, IN BOOL bManualReset, IN BOOL bInitialState, IN LPCTSTR lpName OPT1_2, IN BOOL bHighPriority, IN WORKERFUNCTION pFunction OPT2_1, IN PVOID pContext OPT2_1, IN DWORD dwContextSz OPT2_1, IN BOOL bRunInServerContext OPT2_1);
+  PWT_EVENT_BINDING APIENTRY CreateWaitEventBinding (IN PWT_EVENT_ENTRY pee, IN WORKERFUNCTION pFunction, IN PVOID pContext, IN DWORD dwContextSz, IN BOOL bRunInServerContext);
+  PWT_TIMER_ENTRY APIENTRY CreateWaitTimer (IN WORKERFUNCTION pFunction, IN PVOID pContext, IN DWORD dwContextSz, IN BOOL bRunInServerContext);
+  DWORD APIENTRY DeRegisterWaitEventBindingSelf (IN PWT_EVENT_BINDING pwiWorkItem);
+  DWORD APIENTRY DeRegisterWaitEventBinding (IN PWT_EVENT_BINDING pwiWorkItem);
+  DWORD APIENTRY DeRegisterWaitEventsTimers (PLIST_ENTRY pLEvents, PLIST_ENTRY pLTimers);
+  DWORD APIENTRY DeRegisterWaitEventsTimersSelf (IN PLIST_ENTRY pLEvents, IN PLIST_ENTRY pLTimers);
+  DWORD APIENTRY RegisterWaitEventBinding (IN PWT_EVENT_BINDING pwiWorkItem);
+  DWORD APIENTRY RegisterWaitEventsTimers (IN PLIST_ENTRY pLEventsToAdd, IN PLIST_ENTRY pLTimersToAdd);
+  DWORD APIENTRY UpdateWaitTimer (IN PWT_TIMER_ENTRY pte, IN LONGLONG * time);
+  VOID APIENTRY WTFree (PVOID ptr);
+  VOID APIENTRY WTFreeEvent (IN PWT_EVENT_ENTRY peeEvent);
+  VOID APIENTRY WTFreeTimer (IN PWT_TIMER_ENTRY pteTimer);
+  VOID APIENTRY DebugPrintWaitWorkerThreads (DWORD dwDebugLevel);
+#define DEBUGPRINT_FILTER_NONCLIENT_EVENTS	0x2
+#define DEBUGPRINT_FILTER_EVENTS	0x4
+#define DEBUGPRINT_FILTER_TIMERS	0x8
+#define ERROR_WAIT_THREAD_UNAVAILABLE	1
+#define ERROR_WT_EVENT_ALREADY_DELETED	2
+#define TIMER_HIGH(time) (((LARGE_INTEGER*)&time)->HighPart)
+#define TIMER_LOW(time) (((LARGE_INTEGER*)&time)->LowPart)
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -uNr w32api-3.5/include/stm.h w32api-3.5-xorp/include/stm.h
--- w32api-3.5/include/stm.h	Wed Dec  7 15:43:51 2005
+++ w32api-3.5-xorp/include/stm.h	Wed Dec  7 15:45:49 2005
@@ -0,0 +1,87 @@
+#ifndef __ROUTING_STM_H__
+#define __ROUTING_STM_H__
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+#define SERVICES 0x00000002
+#define DEMAND_UPDATE_SERVICES 0x00000008
+typedef struct _IPX_SERVER_ENTRY
+{
+  USHORT Type;
+  UCHAR Name[48];
+  UCHAR Network[4];
+  UCHAR Node[6];
+  UCHAR Socket[2];
+  USHORT HopCount;
+} IPX_SERVER_ENTRY, *PIPX_SERVER_ENTRY;
+typedef struct _IPX_SERVICE
+{
+  ULONG InterfaceIndex;
+  ULONG Protocol;
+  IPX_SERVER_ENTRY Server;
+} IPX_SERVICE, *PIPX_SERVICE;
+typedef BOOL (WINAPI * PIS_SERVICE) (IN USHORT Type, IN PUCHAR Name, OUT PIPX_SERVICE Service OPTIONAL);
+#define STM_ONLY_THIS_INTERFACE 0x00000001
+#define STM_ONLY_THIS_PROTOCOL 0x00000002
+#define STM_ONLY_THIS_TYPE 0x00000004
+#define STM_ONLY_THIS_NAME 0x00000008
+#define STM_ORDER_BY_TYPE_AND_NAME 0
+#define STM_ORDER_BY_INTERFACE_TYPE_NAME	1
+typedef HANDLE (WINAPI * PCREATE_SERVICE_ENUMERATION_HANDLE) (IN DWORD ExclusionFlags, IN PIPX_SERVICE CriteriaService);
+typedef DWORD (WINAPI * PENUMERATE_GET_NEXT_SERVICE) (IN HANDLE EnumerationHandle, OUT PIPX_SERVICE Service);
+typedef DWORD (WINAPI * PCLOSE_SERVICE_ENUMERATION_HANDLE) (IN HANDLE EnumerationHandle);
+typedef ULONG (WINAPI * PGET_SERVICE_COUNT) (VOID);
+typedef DWORD (WINAPI * PCREATE_STATIC_SERVICE) (IN ULONG InterfaceIndex, IN PIPX_SERVER_ENTRY ServerEntry);
+typedef DWORD (WINAPI * PDELETE_STATIC_SERVICE) (IN ULONG InterfaceIndex, IN PIPX_SERVER_ENTRY ServerEntry);
+typedef DWORD (WINAPI * PBLOCK_CONVERT_SERVICES_TO_STATIC) (IN ULONG InterfaceIndex);
+typedef DWORD (WINAPI * PBLOCK_DELETE_STATIC_SERVICES) (IN ULONG InterfaceIndex);
+typedef DWORD (WINAPI * PGET_FIRST_ORDERED_SERVICE) (IN DWORD OrderingMethod, IN DWORD ExclusionFlags, IN OUT PIPX_SERVICE Service);
+typedef DWORD (WINAPI * PGET_NEXT_ORDERED_SERVICE) (IN DWORD OrderingMethod, IN DWORD ExclusionFlags, IN OUT PIPX_SERVICE Service);
+typedef DWORD (WINAPI * PDO_UPDATE_SERVICES) (IN ULONG InterfaceIndex);
+typedef BOOL (WINAPI * PGET_SERVICE_ID) (IN USHORT Type, IN PUCHAR Name, OUT PULONG ServiceID);
+typedef BOOL (WINAPI * PGET_SERVICE_FROM_ID) (IN ULONG ServiceID, OUT PIPX_SERVICE Service);
+typedef DWORD (WINAPI * PGET_NEXT_SERVICE_FROM_ID) (IN ULONG ServiceID, OUT PIPX_SERVICE NextService, OUT PULONG NextServiceID);
+typedef struct _MPR40_SERVICE_CHARACTERISTICS
+{
+  DWORD dwVersion;
+  DWORD dwProtocolId;
+  DWORD fSupportedFunctionality;
+  PIS_SERVICE pfnIsService;
+  PDO_UPDATE_SERVICES pfnUpdateServices;
+  PCREATE_SERVICE_ENUMERATION_HANDLE pfnCreateServiceEnumerationHandle;
+  PENUMERATE_GET_NEXT_SERVICE pfnEnumerateGetNextService;
+  PCLOSE_SERVICE_ENUMERATION_HANDLE pfnCloseServiceEnumerationHandle;
+  PGET_SERVICE_COUNT pfnGetServiceCount;
+  PCREATE_STATIC_SERVICE pfnCreateStaticService;
+  PDELETE_STATIC_SERVICE pfnDeleteStaticService;
+  PBLOCK_CONVERT_SERVICES_TO_STATIC pfnBlockConvertServicesToStatic;
+  PBLOCK_DELETE_STATIC_SERVICES pfnBlockDeleteStaticServices;
+  PGET_FIRST_ORDERED_SERVICE pfnGetFirstOrderedService;
+  PGET_NEXT_ORDERED_SERVICE pfnGetNextOrderedService;
+} MPR40_SERVICE_CHARACTERISTICS;
+#if 0
+typedef struct _MPR50_SERVICE_CHARACTERISTICS
+{
+#ifdef __cplusplus
+  MPR40_SERVICE_CHARACTERISTICS mscMpr40ServiceChars;
+#else
+    MPR40_SERVICE_CHARACTERISTICS;
+#endif
+} MPR50_SERVICE_CHARACTERISTICS;
+#else
+typedef MPR40_SERVICE_CHARACTERISTICS MPR50_SERVICE_CHARACTERISTICS;
+#endif
+#if MPR50
+typedef MPR50_SERVICE_CHARACTERISTICS MPR_SERVICE_CHARACTERISTICS;
+#else
+#if MPR40
+typedef MPR40_SERVICE_CHARACTERISTICS MPR_SERVICE_CHARACTERISTICS;
+#endif
+#endif
+typedef MPR_SERVICE_CHARACTERISTICS *PMPR_SERVICE_CHARACTERISTICS;
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#else
+#pragma warning(default:4201)
+#endif
+#endif
diff -uNr w32api-3.5/include/winbase.h w32api-3.5-xorp/include/winbase.h
--- w32api-3.5/include/winbase.h	Thu Oct 27 21:57:57 2005
+++ w32api-3.5-xorp/include/winbase.h	Wed Dec  7 16:14:54 2005
@@ -1097,6 +1097,9 @@
 WINBASEAPI BOOL WINAPI CancelDeviceWakeupRequest(HANDLE);
 WINBASEAPI BOOL WINAPI CancelIo(HANDLE);
 WINBASEAPI BOOL WINAPI CancelWaitableTimer(HANDLE);
+#if (_WIN32_WINNT >= 0x0502)
+WINBASEAPI BOOL WINAPI ChangeTimerQueueTimer(HANDLE,HANDLE,ULONG,ULONG);
+#endif
 #if (_WIN32_WINNT >= 0x0501)
 WINBASEAPI BOOL WINAPI CheckNameLegalDOS8Dot3A(LPCSTR,LPSTR,DWORD,PBOOL,PBOOL);
 WINBASEAPI BOOL WINAPI CheckNameLegalDOS8Dot3W(LPCWSTR,LPSTR,DWORD,PBOOL,PBOOL);
@@ -1903,6 +1906,7 @@
 #define UnlockSegment(w) GlobalUnfix((HANDLE)(w)) /* Obsolete: Has no effect. */
 WINBASEAPI BOOL WINAPI UnmapViewOfFile(PVOID);
 #if (_WIN32_WINNT >= 0x0500)
+WINBASEAPI BOOL WINAPI UnregisterWait(HANDLE);
 WINBASEAPI BOOL WINAPI UnregisterWaitEx(HANDLE,HANDLE);
 #endif
 WINBASEAPI BOOL WINAPI UpdateResourceA(HANDLE,LPCSTR,LPCSTR,WORD,PVOID,DWORD);
diff -uNr w32api-3.5/include/winnt.h w32api-3.5-xorp/include/winnt.h
--- w32api-3.5/include/winnt.h	Thu Aug 11 01:59:49 2005
+++ w32api-3.5-xorp/include/winnt.h	Wed Dec  7 16:14:04 2005
@@ -1308,6 +1308,7 @@
 #define WT_EXECUTEINTIMERTHREAD 0x00000020                           
 #define WT_EXECUTEINPERSISTENTTHREAD 0x00000080                      
 #define WT_TRANSFER_IMPERSONATION 0x00000100                         
+#define WT_SET_MAX_THREADPOOL_THREADS(Flags,Limit) ((Flags)|=(Limit)<<16)
 #if (_WIN32_WINNT >= 0x0501)
 #define ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION 1
 #define ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION 2
diff -uNr w32api-3.5/lib/iphlpapi.def w32api-3.5-xorp/lib/iphlpapi.def
--- w32api-3.5/lib/iphlpapi.def	Sun Feb 15 07:35:02 2004
+++ w32api-3.5-xorp/lib/iphlpapi.def	Wed Dec  7 14:36:39 2005
@@ -1,6 +1,7 @@
 LIBRARY IPHLPAPI.DLL
 EXPORTS
 AddIPAddress@20
+CancelIPChangeNotify@4
 CreateIpForwardEntry@4
 CreateIpNetEntry@4
 CreateProxyArpEntry@12
@@ -8,35 +9,64 @@
 DeleteIpForwardEntry@4
 DeleteIpNetEntry@4
 DeleteProxyArpEntry@12
+DisableMediaSense@8
 EnableRouter@8
 FlushIpNetTable@4
+FlushIpNetTableFromStack@4
 GetAdapterIndex@8
+GetAdapterOrderMap@0
+GetAdaptersAddresses@20
 GetAdaptersInfo@8
 GetBestInterface@8
+GetBestInterfaceEx@8
 GetBestRoute@12
+GetExtendedTcpTable@24
+GetExtendedUdpTable@24
 GetFriendlyIfIndex@4
 GetIcmpStatistics@4
+GetIcmpStatisticsEx@8
 GetIfEntry@4
 GetIfTable@12
 GetInterfaceInfo@8
 GetIpAddrTable@12
+GetIpErrorString@12
 GetIpForwardTable@12
 GetIpNetTable@12
 GetIpStatistics@4
+GetIpStatisticsEx@8
 GetNetworkParams@8
 GetNumberOfInterfaces@4
+GetOwnerModuleFromTcp6Entry@16
+GetOwnerModuleFromTcpEntry@16
+GetOwnerModuleFromUdp6Entry@16
+GetOwnerModuleFromUdpEntry@16
 GetPerAdapterInfo@12
 GetRTTAndHopCount@16
 GetTcpStatistics@4
+GetTcpStatisticsEx@8
 GetTcpTable@12
 GetUdpStatistics@4
+GetUdpStatisticsEx@8
 GetUdpTable@12
 GetUniDirectionalAdapterInfo@8
+Icmp6CreateFile@0
+Icmp6ParseReplies@8
+Icmp6SendEcho2@48
+IcmpCloseHandle@4
+IcmpCreateFile@0
+IcmpParseReplies@8
+IcmpSendEcho2@44
+IcmpSendEcho@32
 IpReleaseAddress@4
 IpRenewAddress@4
+NotifyAddrChange@8
+NotifyRouteChange@8
+RestoreMediaSense@8
 SendARP@16
 SetAdapterIpAddress@20
+SetBlockRoutes@12
 SetIfEntry@4
+SetIfEntryToStack@8
 SetIpForwardEntry@4
 SetIpNetEntry@4
 SetIpStatistics@4
diff -uNr w32api-3.5/lib/kernel32.def w32api-3.5-xorp/lib/kernel32.def
--- w32api-3.5/lib/kernel32.def	Thu Oct 27 21:57:57 2005
+++ w32api-3.5-xorp/lib/kernel32.def	Wed Dec  7 14:43:52 2005
@@ -8,6 +8,7 @@
 AddLocalAlternateComputerNameA@8
 AddLocalAlternateComputerNameW@8
 AddRefActCtx@4
+AddVectoredContinueHandler@8
 AddVectoredExceptionHandler@8
 AllocConsole@0
 AllocateUserPhysicalPages@12
@@ -21,6 +22,7 @@
 Beep@8
 BeginUpdateResourceA@8
 BeginUpdateResourceW@8
+BindIoCompletionCallback@12
 BuildCommDCBA@8
 BuildCommDCBAndTimeoutsA@12
 BuildCommDCBAndTimeoutsW@12
@@ -37,22 +39,18 @@
 CheckRemoteDebuggerPresent@8
 ClearCommBreak@4
 ClearCommError@12
-CloseConsoleHandle@4
 CloseHandle@4
-CloseProfileUserMapping@0
-CmdBatNotification@4
 CommConfigDialogA@12
 CommConfigDialogW@12
 CompareFileTime@8
 CompareStringA@24
 CompareStringW@24
 ConnectNamedPipe@8
-ConsoleMenuControl@12
 ContinueDebugEvent@12
 ConvertDefaultLocale@4
 ConvertFiberToThread@0
 ConvertThreadToFiber@4
-ConvertToGlobalHandle@4
+ConvertThreadToFiberEx@8
 CopyFileA@12
 CopyFileW@12
 CopyFileExA@24
@@ -67,7 +65,7 @@
 CreateEventA@16
 CreateEventW@16
 CreateFiber@12
-CreateFiberEx@12
+CreateFiberEx@20
 CreateFileA@28
 CreateFileMappingA@24
 CreateFileMappingW@24
@@ -77,8 +75,10 @@
 CreateIoCompletionPort@16
 CreateJobObjectA@8
 CreateJobObjectW@8
+CreateJobSet@12
 CreateMailslotA@16
 CreateMailslotW@16
+CreateMemoryResourceNotification@4
 CreateMutexA@12
 CreateMutexW@12
 CreateNamedPipeA@32
@@ -94,7 +94,6 @@
 CreateTimerQueue@0
 CreateTimerQueueTimer@28
 CreateToolhelp32Snapshot@8
-CreateVirtualBuffer@12
 CreateWaitableTimerA@12
 CreateWaitableTimerW@12
 DeactivateActCtx@8
@@ -103,6 +102,8 @@
 DebugBreak@0
 DebugBreakProcess@4
 DebugSetProcessKillOnExit@4
+DecodePointer@4
+DecodeSystemPointer@4
 DefineDosDeviceA@12
 DefineDosDeviceW@12
 DeleteAtom@4
@@ -121,8 +122,9 @@
 DnsHostnameToComputerNameA@12
 DnsHostnameToComputerNameW@12
 DosDateTimeToFileTime@12
-DuplicateConsoleHandle@16
 DuplicateHandle@28
+EncodePointer@4
+EncodeSystemPointer@4
 EndUpdateResourceA@8
 EndUpdateResourceW@8
 EnterCriticalSection@4
@@ -144,6 +146,7 @@
 EnumResourceTypesW@12
 EnumSystemCodePagesA@8
 EnumSystemCodePagesW@8
+EnumSystemFirmwareTables@12
 EnumSystemGeoID@12
 EnumSystemLanguageGroupsA@12
 EnumSystemLanguageGroupsW@12
@@ -153,16 +156,14 @@
 EnumTimeFormatsW@12
 EnumUILanguagesA@12
 EnumUILanguagesW@12
+EnumerateLocalComputerNamesA@16
+EnumerateLocalComputerNamesW@16
 EraseTape@12
 EscapeCommFunction@8
 ExitProcess@4
 ExitThread@4
-ExitVDM@8
 ExpandEnvironmentStringsA@12
 ExpandEnvironmentStringsW@12
-ExpungeConsoleCommandHistoryA@4
-ExpungeConsoleCommandHistoryW@4
-ExtendVirtualBuffer@8
 FatalAppExitA@8
 FatalAppExitW@8
 FatalExit@4
@@ -185,13 +186,15 @@
 FindFirstFileW@8
 FindFirstFileExA@24
 FindFirstFileExW@24
+FindFirstStreamW@16
 FindFirstVolumeA@8
-FindFirstVolumeW@8
 FindFirstVolumeMountPointA@12
 FindFirstVolumeMountPointW@12
+FindFirstVolumeW@8
 FindNextChangeNotification@4
 FindNextFileA@8
 FindNextFileW@8
+FindNextStreamW@8
 FindNextVolumeA@12
 FindNextVolumeW@12
 FindNextVolumeMountPointA@12
@@ -202,6 +205,10 @@
 FindResourceW@12
 FindVolumeClose@4
 FindVolumeMountPointClose@4
+FlsAlloc@4
+FlsFree@4
+FlsGetValue@4
+FlsSetValue@8
 FlushConsoleInputBuffer@4
 FlushFileBuffers@4
 FlushInstructionCache@12
@@ -217,7 +224,6 @@
 FreeLibraryAndExitThread@8
 FreeResource@4
 FreeUserPhysicalPages@12
-FreeVirtualBuffer@4
 GenerateConsoleCtrlEvent@8
 GetACP@0
 GetAtomNameA@12
@@ -255,23 +261,14 @@
 GetConsoleAliasesLengthW@4
 GetConsoleAliasesW@12
 GetConsoleCP@0
-GetConsoleCommandHistoryA@12
-GetConsoleCommandHistoryLengthA@4
-GetConsoleCommandHistoryLengthW@4
-GetConsoleCommandHistoryW@12
 GetConsoleCursorInfo@8
 GetConsoleDisplayMode@4
-GetConsoleFontInfo@16
 GetConsoleFontSize@8
-GetConsoleHardwareState@12
-GetConsoleInputExeNameA@8
-GetConsoleInputExeNameW@8
-GetConsoleInputWaitHandle@0
-GetConsoleKeyboardLayoutNameA@4
-GetConsoleKeyboardLayoutNameW@4
 GetConsoleMode@8
 GetConsoleOutputCP@0
+GetConsoleProcessList@8
 GetConsoleScreenBufferInfo@8
+GetConsoleSelectionInfo@4
 GetConsoleTitleA@8
 GetConsoleTitleW@8
 GetConsoleWindow@0
@@ -283,13 +280,14 @@
 GetCurrentDirectoryW@8
 GetCurrentProcess@0
 GetCurrentProcessId@0
+GetCurrentProcessorNumber@0
 GetCurrentThread@0
 GetCurrentThreadId@0
 GetDateFormatA@24
 GetDateFormatW@24
 GetDefaultCommConfigA@12
 GetDefaultCommConfigW@12
-GetDevicePowerState@4
+GetDevicePowerState@8
 GetDiskFreeSpaceA@20
 GetDiskFreeSpaceW@20
 GetDiskFreeSpaceExA@16
@@ -298,7 +296,6 @@
 GetDllDirectoryW@8
 GetDriveTypeA@4
 GetDriveTypeW@4
-GetErrorMode@0
 GetEnvironmentStrings@0
 GetEnvironmentStringsA@0
 GetEnvironmentStringsW@0
@@ -322,6 +319,7 @@
 GetGeoInfoA@20
 GetGeoInfoW@20
 GetHandleInformation@8
+GetLargePageMinimum@0
 GetLargestConsoleWindowSize@4
 GetLastError@0
 GetLocalTime@4
@@ -330,6 +328,7 @@
 GetLogicalDriveStringsA@8
 GetLogicalDriveStringsW@8
 GetLogicalDrives@0
+GetLogicalProcessorInformation@8
 GetLongPathNameA@12
 GetLongPathNameW@12
 GetMailslotInfo@20
@@ -339,14 +338,17 @@
 GetModuleHandleW@4
 GetModuleHandleExA@12
 GetModuleHandleExW@12
+GetNLSVersion@12
 GetNamedPipeHandleStateA@28
 GetNamedPipeHandleStateW@28
 GetNamedPipeInfo@20
 GetNativeSystemInfo@4
-GetNextVDMCommand@4
+GetNumaAvailableMemoryNode@8
+GetNumaHighestNodeNumber@4
+GetNumaNodeProcessorMask@8
+GetNumaProcessorNode@8
 GetNumberFormatA@24
 GetNumberFormatW@24
-GetNumberOfConsoleFonts@0
 GetNumberOfConsoleInputEvents@8
 GetNumberOfConsoleMouseButtons@4
 GetOEMCP@0
@@ -368,13 +370,14 @@
 GetProcessHeap@0
 GetProcessHeaps@8
 GetProcessId@4
+GetProcessIdOfThread@4
 GetProcessIoCounters@8
 GetProcessPriorityBoost@8
 GetProcessShutdownParameters@8
 GetProcessTimes@20
 GetProcessVersion@4
 GetProcessWorkingSetSize@12
-GetProductName@8
+GetProcessWorkingSetSizeEx@16
 GetProfileIntA@12
 GetProfileIntW@12
 GetProfileSectionA@12
@@ -396,6 +399,8 @@
 GetSystemDefaultUILanguage@0
 GetSystemDirectoryA@8
 GetSystemDirectoryW@8
+GetSystemFileCacheSize@12
+GetSystemFirmwareTable@16
 GetSystemInfo@4
 GetSystemPowerStatus@4
 GetSystemRegistryQuota@8
@@ -416,6 +421,7 @@
 GetTempPathW@8
 GetThreadContext@8
 GetThreadIOPendingFlag@8
+GetThreadId@4
 GetThreadLocale@0
 GetThreadPriority@4
 GetThreadPriorityBoost@8
@@ -429,7 +435,6 @@
 GetUserDefaultLangID@0
 GetUserDefaultUILanguage@0
 GetUserGeoID@4
-GetVDMCurrentDirectories@8
 GetVersion@0
 GetVersionExA@4
 GetVersionExW@4
@@ -460,7 +465,6 @@
 GlobalLock@4
 GlobalMemoryStatus@4
 GlobalMemoryStatusEx@4
-GlobalMemoryStatusVlm@4
 GlobalReAlloc@12
 GlobalSize@4
 GlobalUnWire@4
@@ -474,25 +478,21 @@
 HeapAlloc@12
 HeapCompact@8
 HeapCreate@12
-HeapCreateTagsW@16
 HeapDestroy@4
-HeapExtend@16
 HeapFree@12
 HeapLock@4
 HeapQueryInformation@20
-HeapQueryTagW@20
 HeapReAlloc@16
 HeapSetInformation@16
 HeapSize@12
-HeapSummary@12
 HeapUnlock@4
-HeapUsage@20
 HeapValidate@12
 HeapWalk@8
 InitAtomTable@4
 InitializeCriticalSection@4
 InitializeCriticalSectionAndSpinCount@8
 InitializeSListHead@4
+InterlockedCompareExchange64@20
 InterlockedCompareExchange@12
 InterlockedDecrement@4
 InterlockedExchange@8
@@ -501,7 +501,6 @@
 InterlockedIncrement@4
 InterlockedPopEntrySList@4
 InterlockedPushEntrySList@8
-InvalidateConsoleDIBits@8
 IsBadCodePtr@4
 IsBadHugeReadPtr@8
 IsBadHugeWritePtr@8
@@ -512,6 +511,7 @@
 IsDBCSLeadByte@4
 IsDBCSLeadByteEx@8
 IsDebuggerPresent@0
+IsNLSDefinedString@20
 IsProcessInJob@12
 IsProcessorFeaturePresent@4
 IsSystemResumeAutomatic@0
@@ -546,7 +546,6 @@
 MapUserPhysicalPagesScatter@12
 MapViewOfFile@20
 MapViewOfFileEx@24
-MapViewOfFileVlm@28
 Module32First@8
 Module32FirstW@8
 Module32Next@8
@@ -559,7 +558,8 @@
 MoveFileWithProgressW@20
 MulDiv@12
 MultiByteToWideChar@24
-OpenConsoleW@16
+NeedCurrentDirectoryForExePathA@4
+NeedCurrentDirectoryForExePathW@4
 OpenEventA@12
 OpenEventW@12
 OpenFile@12
@@ -570,7 +570,6 @@
 OpenMutexA@12
 OpenMutexW@12
 OpenProcess@12
-OpenProfileUserMapping@0
 OpenSemaphoreA@12
 OpenSemaphoreW@12
 OpenThread@12
@@ -591,21 +590,20 @@
 PulseEvent@4
 PurgeComm@8
 QueryActCtxW@28
+QueryDepthSList@4
 QueryDosDeviceA@12
 QueryDosDeviceW@12
 QueryInformationJobObject@20
 QueryMemoryResourceNotification@8
 QueryPerformanceCounter@4
 QueryPerformanceFrequency@4
-QueryWin31IniFilesMappedToRegistry@16
 QueueUserAPC@12
 QueueUserWorkItem@12
 RaiseException@16
+ReOpenFile@16
 ReadConsoleA@20
 ReadConsoleInputA@16
 ReadConsoleInputW@16
-ReadConsoleInputExA@20
-ReadConsoleInputExW@20
 ReadConsoleOutputA@20
 ReadConsoleOutputAttribute@20
 ReadConsoleOutputCharacterA@20
@@ -616,29 +614,29 @@
 ReadFile@20
 ReadFileEx@20
 ReadFileScatter@20
-ReadFileVlm@20
 ReadProcessMemory@20
-ReadProcessMemoryVlm@20
-RegisterConsoleVDM@44
-RegisterWaitForInputIdle@4
 RegisterWaitForSingleObject@24
 RegisterWaitForSingleObjectEx@20
-RegisterWowBaseHandlers@4
-RegisterWowExec@4
 ReleaseActCtx@4
 ReleaseMutex@4
 ReleaseSemaphore@12
 RemoveDirectoryA@4
 RemoveDirectoryW@4
+RemoveLocalAlternateComputerNameA@8
+RemoveLocalAlternateComputerNameW@8
+RemoveVectoredContinueHandler@4
 RemoveVectoredExceptionHandler@4
 ReplaceFile@24
 ReplaceFileA@24
 ReplaceFileW@24
+RequestDeviceWakeup@4
 RequestWakeupLatency@4
 ResetEvent@4
 ResetWriteWatch@8
 RestoreLastError@4
 ResumeThread@4
+RtlCaptureContext@4
+RtlCaptureStackBackTrace@16
 RtlFillMemory@12
 RtlMoveMemory@12
 RtlUnwind@16
@@ -660,25 +658,12 @@
 SetComputerNameExW@8
 SetConsoleActiveScreenBuffer@4
 SetConsoleCP@4
-SetConsoleCommandHistoryMode@4
 SetConsoleCtrlHandler@8
 SetConsoleCursor@8
 SetConsoleCursorInfo@8
 SetConsoleCursorPosition@8
-SetConsoleDisplayMode@12
-SetConsoleFont@8
-SetConsoleHardwareState@12
-SetConsoleIcon@4
-SetConsoleInputExeNameA@4
-SetConsoleInputExeNameW@4
-SetConsoleKeyShortcuts@16
-SetConsoleMaximumWindowSize@8
-SetConsoleMenuClose@4
 SetConsoleMode@8
-SetConsoleNumberOfCommandsA@8
-SetConsoleNumberOfCommandsW@8
 SetConsoleOutputCP@4
-SetConsolePalette@12
 SetConsoleScreenBufferSize@8
 SetConsoleTextAttribute@8
 SetConsoleTitleA@4
@@ -692,6 +677,8 @@
 SetDllDirectoryA@4
 SetDllDirectoryW@4
 SetEndOfFile@4
+SetEnvironmentStringsA@4
+SetEnvironmentStringsW@4
 SetEnvironmentVariableA@8
 SetEnvironmentVariableW@8
 SetErrorMode@4
@@ -706,22 +693,28 @@
 SetFileShortNameW@8
 SetFileTime@16
 SetFileValidData@12
+SetFirmwareEnvironmentVariableA@16
+SetFirmwareEnvironmentVariableW@16
 SetHandleCount@4
 SetHandleInformation@12
 SetInformationJobObject@16
-SetLastConsoleEventActive@0
 SetLastError@4
+SetLocalPrimaryComputerNameA@8
+SetLocalPrimaryComputerNameW@8
 SetLocalTime@4
 SetLocaleInfoA@12
 SetLocaleInfoW@12
 SetMailslotInfo@8
+SetMessageWaitingIndicator@8
 SetNamedPipeHandleState@16
 SetPriorityClass@8
 SetProcessAffinityMask@8
 SetProcessPriorityBoost@8
 SetProcessShutdownParameters@8
 SetProcessWorkingSetSize@12
+SetProcessWorkingSetSizeEx@16
 SetStdHandle@8
+SetSystemFileCacheSize@12
 SetSystemPowerState@8
 SetSystemTime@4
 SetSystemTimeAdjustment@8
@@ -734,18 +727,17 @@
 SetThreadLocale@4
 SetThreadPriority@8
 SetThreadPriorityBoost@8
+SetThreadStackGuarantee@4
 SetTimeZoneInformation@4
 SetTimerQueueTimer@24
 SetUnhandledExceptionFilter@4
 SetUserGeoID@4
-SetVDMCurrentDirectories@8
 SetVolumeLabelA@8
 SetVolumeLabelW@8
 SetVolumeMountPointA@8
 SetVolumeMountPointW@8
 SetWaitableTimer@24
 SetupComm@12
-ShowConsoleCursor@8
 SignalObjectAndWait@16
 SizeofResource@8
 Sleep@4
@@ -764,44 +756,35 @@
 TlsFree@4
 TlsGetValue@4
 TlsSetValue@8
+Toolhelp32ReadProcessMemory@20
 TransactNamedPipe@28
 TransmitCommChar@8
-TrimVirtualBuffer@4
 TryEnterCriticalSection@4
-UTRegister@28
-UTUnRegister@4
+TzSpecificLocalTimeToSystemTime@12
 UnhandledExceptionFilter@4
 UnlockFile@20
 UnlockFileEx@20
 UnmapViewOfFile@4
-UnmapViewOfFileVlm@4
 UnregisterWait@4
 UnregisterWaitEx@8
 UpdateResourceA@24
 UpdateResourceW@24
-VDMConsoleOperation@8
-VDMOperationStarted@4
 VerLanguageNameA@12
 VerLanguageNameW@12
 VerSetConditionMask@16
-VerifyConsoleIoHandle@4
 VerifyVersionInfoA@16
 VerifyVersionInfoW@16
 VirtualAlloc@16
 VirtualAllocEx@20
-VirtualAllocVlm@24
-VirtualBufferExceptionHandler@12
 VirtualFree@12
 VirtualFreeEx@16
-VirtualFreeVlm@20
 VirtualLock@8
 VirtualProtect@16
 VirtualProtectEx@20
-VirtualProtectVlm@24
 VirtualQuery@12
 VirtualQueryEx@16
-VirtualQueryVlm@16
 VirtualUnlock@8
+WTSGetActiveConsoleSessionId@0
 WaitCommEvent@12
 WaitForDebugEvent@8
 WaitForMultipleObjects@16
@@ -812,10 +795,11 @@
 WaitNamedPipeW@8
 WideCharToMultiByte@32
 WinExec@8
+Wow64DisableWow64FsRedirection@4
+Wow64EnableWow64FsRedirection@4
+Wow64RevertWow64FsRedirection@4
 WriteConsoleA@20
 WriteConsoleInputA@16
-WriteConsoleInputVDMA@16
-WriteConsoleInputVDMW@16
 WriteConsoleInputW@16
 WriteConsoleOutputA@20
 WriteConsoleOutputAttribute@20
@@ -826,7 +810,6 @@
 WriteFile@20
 WriteFileEx@20
 WriteFileGather@20
-WriteFileVlm@20
 WritePrivateProfileSectionA@12
 WritePrivateProfileSectionW@12
 WritePrivateProfileStringA@16
@@ -834,7 +817,6 @@
 WritePrivateProfileStructA@20
 WritePrivateProfileStructW@20
 WriteProcessMemory@20
-WriteProcessMemoryVlm@20
 WriteProfileSectionA@8
 WriteProfileSectionW@8
 WriteProfileStringA@12
diff -uNr w32api-3.5/lib/mprapi.def w32api-3.5-xorp/lib/mprapi.def
--- w32api-3.5/lib/mprapi.def	Wed Dec  7 14:24:07 2005
+++ w32api-3.5-xorp/lib/mprapi.def	Wed Dec  7 14:28:30 2005
@@ -0,0 +1,117 @@
+LIBRARY MPRAPI.DLL
+EXPORTS
+CompressPhoneNumber@8
+MprAdminBufferFree@4
+MprAdminConnectionClearStats@8
+MprAdminConnectionEnum@28
+MprAdminConnectionGetInfo@16
+MprAdminConnectionRemoveQuarantine@12
+MprAdminDeregisterConnectionNotification@8
+MprAdminDeviceEnum@16
+MprAdminEstablishDomainRasServer@12
+MprAdminGetErrorString@8
+MprAdminGetPDCServer@12
+MprAdminInterfaceConnect@16
+MprAdminInterfaceCreate@16
+MprAdminInterfaceDelete@8
+MprAdminInterfaceDeviceGetInfo@20
+MprAdminInterfaceDeviceSetInfo@20
+MprAdminInterfaceDisconnect@8
+MprAdminInterfaceEnum@28
+MprAdminInterfaceGetCredentials@20
+MprAdminInterfaceGetCredentialsEx@16
+MprAdminInterfaceGetHandle@16
+MprAdminInterfaceGetInfo@16
+MprAdminInterfaceQueryUpdateResult@16
+MprAdminInterfaceSetCredentials@20
+MprAdminInterfaceSetCredentialsEx@16
+MprAdminInterfaceSetInfo@16
+MprAdminInterfaceTransportAdd@20
+MprAdminInterfaceTransportGetInfo@20
+MprAdminInterfaceTransportRemove@12
+MprAdminInterfaceTransportSetInfo@20
+MprAdminInterfaceUpdatePhonebookInfo@8
+MprAdminInterfaceUpdateRoutes@16
+MprAdminIsDomainRasServer@12
+MprAdminIsServiceRunning@4
+MprAdminMIBBufferFree@4
+MprAdminMIBEntryCreate@20
+MprAdminMIBEntryDelete@20
+MprAdminMIBEntryGet@28
+MprAdminMIBEntryGetFirst@28
+MprAdminMIBEntryGetNext@28
+MprAdminMIBEntrySet@20
+MprAdminMIBServerConnect@8
+MprAdminMIBServerDisconnect@4
+MprAdminPortClearStats@8
+MprAdminPortDisconnect@8
+MprAdminPortEnum@32
+MprAdminPortGetInfo@16
+MprAdminPortReset@8
+MprAdminRegisterConnectionNotification@8
+MprAdminSendUserMessage@12
+MprAdminServerConnect@8
+MprAdminServerDisconnect@4
+MprAdminServerGetCredentials@12
+MprAdminServerGetInfo@12
+MprAdminServerSetCredentials@12
+MprAdminServerSetInfo@12
+MprAdminTransportCreate@32
+MprAdminTransportGetInfo@24
+MprAdminTransportSetInfo@24
+MprAdminUpgradeUsers@8
+MprAdminUserClose@4
+MprAdminUserGetInfo@16
+MprAdminUserOpen@12
+MprAdminUserRead@12
+MprAdminUserReadProfFlags@8
+MprAdminUserServerConnect@12
+MprAdminUserServerDisconnect@4
+MprAdminUserSetInfo@16
+MprAdminUserWrite@12
+MprAdminUserWriteProfFlags@8
+MprConfigBufferFree@4
+MprConfigGetFriendlyName@16
+MprConfigGetGuidName@16
+MprConfigInterfaceCreate@16
+MprConfigInterfaceDelete@8
+MprConfigInterfaceEnum@28
+MprConfigInterfaceGetHandle@12
+MprConfigInterfaceGetInfo@20
+MprConfigInterfaceSetInfo@16
+MprConfigInterfaceTransportAdd@28
+MprConfigInterfaceTransportEnum@32
+MprConfigInterfaceTransportGetHandle@16
+MprConfigInterfaceTransportGetInfo@20
+MprConfigInterfaceTransportRemove@12
+MprConfigInterfaceTransportSetInfo@20
+MprConfigServerBackup@8
+MprConfigServerConnect@8
+MprConfigServerDisconnect@4
+MprConfigServerGetInfo@12
+MprConfigServerInstall@8
+MprConfigServerRefresh@4
+MprConfigServerRestore@8
+MprConfigServerSetInfo@12
+MprConfigTransportCreate@36
+MprConfigTransportDelete@8
+MprConfigTransportEnum@28
+MprConfigTransportGetHandle@12
+MprConfigTransportGetInfo@28
+MprConfigTransportSetInfo@28
+MprDomainQueryAccess@8
+MprDomainQueryRasServer@12
+MprDomainRegisterRasServer@12
+MprDomainSetAccess@8
+MprGetUsrParams@12
+MprInfoBlockAdd@24
+MprInfoBlockFind@20
+MprInfoBlockQuerySize@4
+MprInfoBlockRemove@12
+MprInfoBlockSet@24
+MprInfoCreate@8
+MprInfoDelete@4
+MprInfoDuplicate@8
+MprInfoRemoveAll@8
+MprPortSetUsage@4
+RasPrivilegeAndCallBackNumber@8
diff -uNr w32api-3.5/lib/rtm.def w32api-3.5-xorp/lib/rtm.def
--- w32api-3.5/lib/rtm.def	Wed Dec  7 14:24:07 2005
+++ w32api-3.5-xorp/lib/rtm.def	Wed Dec  7 14:28:39 2005
@@ -0,0 +1,114 @@
+LIBRARY RTM.DLL
+EXPORTS
+BestMatchInTable@12
+CheckTable@4
+CreateTable@8
+DeleteFromTable@20
+DestroyTable@4
+DumpTable@8
+EnumOverTable@32
+InsertIntoTable@20
+MgmAddGroupMembershipEntry@32
+MgmDeInitialize@0
+MgmDeRegisterMProtocol@4
+MgmDeleteGroupMembershipEntry@32
+MgmGetFirstMfe@12
+MgmGetFirstMfeStats@16
+MgmGetMfe@12
+MgmGetMfeStats@16
+MgmGetNextMfe@16
+MgmGetNextMfeStats@20
+MgmGetProtocolOnInterface@16
+MgmGroupEnumerationEnd@4
+MgmGroupEnumerationGetNext@16
+MgmGroupEnumerationStart@12
+MgmInitialize@8
+MgmRegisterMProtocol@16
+MgmReleaseInterfaceOwnership@12
+MgmTakeInterfaceOwnership@12
+NextMatchInTable@12
+RtmAddNextHop@16
+RtmAddRoute@24
+RtmAddRouteToDest@36
+RtmBlockConvertRoutesToStatic@12
+RtmBlockDeleteRoutes@12
+RtmBlockMethods@16
+RtmBlockSetRouteEnable@16
+RtmCloseEnumerationHandle@4
+RtmCreateDestEnum@24
+RtmCreateEnumerationHandle@12
+RtmCreateNextHopEnum@16
+RtmCreateRouteEnum@36
+RtmCreateRouteList@8
+RtmCreateRouteListEnum@12
+RtmCreateRouteTable@8
+RtmDeleteEnumHandle@8
+RtmDeleteNextHop@12
+RtmDeleteRoute@16
+RtmDeleteRouteList@8
+RtmDeleteRouteTable@4
+RtmDeleteRouteToDest@12
+RtmDequeueRouteChangeMessage@16
+RtmDereferenceHandles@12
+RtmDeregisterClient@4
+RtmDeregisterEntity@4
+RtmDeregisterFromChangeNotification@8
+RtmEnumerateGetNextRoute@8
+RtmFindNextHop@16
+RtmGetAddressFamilyInfo@20
+RtmGetChangeStatus@16
+RtmGetChangedDests@16
+RtmGetDestInfo@20
+RtmGetEntityInfo@12
+RtmGetEntityMethods@16
+RtmGetEnumDests@16
+RtmGetEnumNextHops@16
+RtmGetEnumRoutes@16
+RtmGetExactMatchDestination@20
+RtmGetExactMatchRoute@28
+RtmGetFirstRoute@12
+RtmGetInstanceInfo@16
+RtmGetInstances@8
+RtmGetLessSpecificDestination@20
+RtmGetListEnumRoutes@16
+RtmGetMostSpecificDestination@20
+RtmGetNetworkCount@4
+RtmGetNextHopInfo@12
+RtmGetNextHopPointer@12
+RtmGetNextRoute@12
+RtmGetOpaqueInformationPointer@12
+RtmGetRegisteredEntities@16
+RtmGetRouteAge@4
+RtmGetRouteInfo@16
+RtmGetRoutePointer@12
+RtmHoldDestination@16
+RtmIgnoreChangedDests@16
+RtmInsertInRouteList@16
+RtmInvokeMethod@20
+RtmIsBestRoute@12
+RtmIsMarkedForChangeNotification@16
+RtmIsRoute@12
+RtmLockDestination@16
+RtmLockNextHop@20
+RtmLockRoute@20
+RtmLookupIPDestination@8
+RtmMarkDestForChangeNotification@16
+RtmReadAddressFamilyConfig@12
+RtmReadInstanceConfig@8
+RtmReferenceHandles@12
+RtmRegisterClient@16
+RtmRegisterEntity@24
+RtmRegisterForChangeNotification@20
+RtmReleaseChangedDests@16
+RtmReleaseDestInfo@8
+RtmReleaseDests@12
+RtmReleaseEntities@12
+RtmReleaseEntityInfo@8
+RtmReleaseNextHopInfo@8
+RtmReleaseNextHops@12
+RtmReleaseRouteInfo@8
+RtmReleaseRoutes@12
+RtmUpdateAndUnlockRoute@28
+RtmWriteAddressFamilyConfig@12
+RtmWriteInstanceConfig@8
+SearchInTable@20
diff -uNr w32api-3.5/lib/rtutils.def w32api-3.5-xorp/lib/rtutils.def
--- w32api-3.5/lib/rtutils.def	Wed Dec  7 14:24:07 2005
+++ w32api-3.5-xorp/lib/rtutils.def	Wed Dec  7 14:27:33 2005
@@ -0,0 +1,45 @@
+LIBRARY RTUTILS.DLL
+EXPORTS
+LogErrorA@16
+LogErrorW@16
+LogEventA@16
+LogEventW@16
+MprSetupProtocolEnum@12
+MprSetupProtocolFree@4
+QueueWorkItem@12
+RouterAssert@16
+RouterGetErrorStringA@8
+RouterGetErrorStringW@8
+RouterLogDeregisterA@4
+RouterLogDeregisterW@4
+RouterLogEventA@24
+RouterLogEventDataA@28
+RouterLogEventDataW@28
+RouterLogEventExA
+RouterLogEventExW
+RouterLogEventStringA@28
+RouterLogEventStringW@28
+RouterLogEventValistExA@24
+RouterLogEventValistExW@24
+RouterLogEventW@24
+RouterLogRegisterA@4
+RouterLogRegisterW@4
+SetIoCompletionProc@8
+TraceDeregisterA@4
+TraceDeregisterExA@8
+TraceDeregisterExW@8
+TraceDeregisterW@4
+TraceDumpExA@28
+TraceDumpExW@28
+TraceGetConsoleA@8
+TraceGetConsoleW@8
+TracePrintfA
+TracePrintfExA
+TracePrintfExW
+TracePrintfW
+TracePutsExA@12
+TracePutsExW@12
+TraceRegisterExA@8
+TraceRegisterExW@8
+TraceVprintfExA@16
+TraceVprintfExW@16
