/*
 * Copyright (c) 2001-2003 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#ident "$XORP: xorp/xrl/interfaces/rtrmgr_xif.cc,v 1.5 2003/03/10 23:01:31 hodson Exp $"

#include "rtrmgr_xif.hh"

bool
XrlRtrmgrV0p1Client::send_get_pid(
	const char*	the_tgt, 
	const CB0&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/get_pid");
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall0, cb));
}


/* Unmarshall get_pid */
void
XrlRtrmgrV0p1Client::unmarshall0(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB0		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t pid;
    try {
	a->get("pid", pid);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &pid);
}

bool
XrlRtrmgrV0p1Client::send_register_client(
	const char*	the_tgt, 
	const uint32_t&	userid, 
	const string&	clientname, 
	const CB1&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/register_client");
    x.args().add("userid", userid);
    x.args().add("clientname", clientname);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall1, cb));
}


/* Unmarshall register_client */
void
XrlRtrmgrV0p1Client::unmarshall1(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB1		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    string filename;
    uint32_t pid;
    try {
	a->get("filename", filename);
	a->get("pid", pid);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &filename, &pid);
}

bool
XrlRtrmgrV0p1Client::send_unregister_client(
	const char*	the_tgt, 
	const string&	token, 
	const CB2&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/unregister_client");
    x.args().add("token", token);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall2, cb));
}


/* Unmarshall unregister_client */
void
XrlRtrmgrV0p1Client::unmarshall2(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB2		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlRtrmgrV0p1Client::send_authenticate_client(
	const char*	the_tgt, 
	const uint32_t&	userid, 
	const string&	clientname, 
	const string&	token, 
	const CB3&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/authenticate_client");
    x.args().add("userid", userid);
    x.args().add("clientname", clientname);
    x.args().add("token", token);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall3, cb));
}


/* Unmarshall authenticate_client */
void
XrlRtrmgrV0p1Client::unmarshall3(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB3		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlRtrmgrV0p1Client::send_enter_config_mode(
	const char*	the_tgt, 
	const string&	token, 
	const bool&	exclusive, 
	const CB4&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/enter_config_mode");
    x.args().add("token", token);
    x.args().add("exclusive", exclusive);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall4, cb));
}


/* Unmarshall enter_config_mode */
void
XrlRtrmgrV0p1Client::unmarshall4(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB4		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlRtrmgrV0p1Client::send_leave_config_mode(
	const char*	the_tgt, 
	const string&	token, 
	const CB5&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/leave_config_mode");
    x.args().add("token", token);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall5, cb));
}


/* Unmarshall leave_config_mode */
void
XrlRtrmgrV0p1Client::unmarshall5(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB5		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlRtrmgrV0p1Client::send_get_config_users(
	const char*	the_tgt, 
	const string&	token, 
	const CB6&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/get_config_users");
    x.args().add("token", token);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall6, cb));
}


/* Unmarshall get_config_users */
void
XrlRtrmgrV0p1Client::unmarshall6(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB6		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList users;
    try {
	a->get("users", users);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &users);
}

bool
XrlRtrmgrV0p1Client::send_get_running_config(
	const char*	the_tgt, 
	const string&	token, 
	const CB7&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/get_running_config");
    x.args().add("token", token);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall7, cb));
}


/* Unmarshall get_running_config */
void
XrlRtrmgrV0p1Client::unmarshall7(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB7		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string config;
    try {
	a->get("config", config);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &config);
}

bool
XrlRtrmgrV0p1Client::send_apply_config_change(
	const char*	the_tgt, 
	const string&	token, 
	const string&	target, 
	const string&	deltas, 
	const string&	deletions, 
	const CB8&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/apply_config_change");
    x.args().add("token", token);
    x.args().add("target", target);
    x.args().add("deltas", deltas);
    x.args().add("deletions", deletions);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall8, cb));
}


/* Unmarshall apply_config_change */
void
XrlRtrmgrV0p1Client::unmarshall8(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB8		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlRtrmgrV0p1Client::send_lock_config(
	const char*	the_tgt, 
	const string&	token, 
	const uint32_t&	timeout, 
	const CB9&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/lock_config");
    x.args().add("token", token);
    x.args().add("timeout", timeout);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall9, cb));
}


/* Unmarshall lock_config */
void
XrlRtrmgrV0p1Client::unmarshall9(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB9		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool success;
    uint32_t holder;
    try {
	a->get("success", success);
	a->get("holder", holder);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &success, &holder);
}

bool
XrlRtrmgrV0p1Client::send_unlock_config(
	const char*	the_tgt, 
	const string&	token, 
	const CB10&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/unlock_config");
    x.args().add("token", token);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall10, cb));
}


/* Unmarshall unlock_config */
void
XrlRtrmgrV0p1Client::unmarshall10(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB10		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlRtrmgrV0p1Client::send_lock_node(
	const char*	the_tgt, 
	const string&	token, 
	const string&	node, 
	const uint32_t&	timeout, 
	const CB11&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/lock_node");
    x.args().add("token", token);
    x.args().add("node", node);
    x.args().add("timeout", timeout);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall11, cb));
}


/* Unmarshall lock_node */
void
XrlRtrmgrV0p1Client::unmarshall11(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB11		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool success;
    uint32_t holder;
    try {
	a->get("success", success);
	a->get("holder", holder);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &success, &holder);
}

bool
XrlRtrmgrV0p1Client::send_unlock_node(
	const char*	the_tgt, 
	const string&	token, 
	const string&	node, 
	const CB12&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/unlock_node");
    x.args().add("token", token);
    x.args().add("node", node);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall12, cb));
}


/* Unmarshall unlock_node */
void
XrlRtrmgrV0p1Client::unmarshall12(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB12		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlRtrmgrV0p1Client::send_save_config(
	const char*	the_tgt, 
	const string&	token, 
	const string&	filename, 
	const CB13&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/save_config");
    x.args().add("token", token);
    x.args().add("filename", filename);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall13, cb));
}


/* Unmarshall save_config */
void
XrlRtrmgrV0p1Client::unmarshall13(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB13		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlRtrmgrV0p1Client::send_load_config(
	const char*	the_tgt, 
	const string&	token, 
	const string&	target, 
	const string&	filename, 
	const CB14&	cb
)
{
    Xrl x(the_tgt, "rtrmgr/0.1/load_config");
    x.args().add("token", token);
    x.args().add("target", target);
    x.args().add("filename", filename);
    return _sender->send(x, callback(this, &XrlRtrmgrV0p1Client::unmarshall14, cb));
}


/* Unmarshall load_config */
void
XrlRtrmgrV0p1Client::unmarshall14(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB14		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}
