<!-- $XORP: www/getting_started.html,v 1.1 2004/04/21 17:25:21 mjh Exp $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<HEAD>
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<TITLE>Getting Started with XORP</TITLE>
</HEAD>
<BODY BGCOLOR="white">
<p>
<a href="/"><img src="xorp2.png" alt="XORP logo"  border="0"></a>
<h2>Getting Started with XORP</h2>

This short guide is aimed at people new to XORP understand what XORP
does and how to use it.  It's a work in progress - please let us know
what additional help you would find useful.
<P>
<UL>
<LI><a href="#what">What exactly is XORP?</a>
<LI><a href="#getting">Getting XORP</a>
<LI><a href="#os">Supported Operating Systems</a>
<LI><a href="#compiling">Compiling XORP from source</a>
<LI><a href="#validating">Validating a XORP Compilation</a>
<LI><a href="#running">Running XORP</a>
<LI><a href="#inside">Inside XORP</a>
<LI><a href="#porting">Porting XORP to a new platform</a>
</UL>
<P>

<table border="0" cellpadding="10"  cellspacing="3" 
width="100%" bgcolor="#b0b0b0">
<TR><TD bgcolor="#b0b0b0">
  <a name="what"><h4>What exactly is XORP?</h4></a>
</TD</TR>
<TR><TD bgcolor="#ffffff">
<P>
XORP is <I>intended</I> to provide a complete and extensible software
stack for an IP router, including routing protocols, management
mechanisms and an extensible forwarding path.  The goal is to provide
a <I>platform</I>, by which we mean that XORP provides the critical
common infrastructure, and we hope other people will code novel
applications or protocols to run on the XORP platform.
<P>
At the present time, XORP doesn't provide it's own forwarding path,
but rather relies on the forwarding capabilities of the underlying
operating system.  This means that although the control plane is
nicely extensible, the forwarding path isn't.  We have plans to
address this in the future using the <a
href="http://www.pdos.lcs.mit.edu/click/">Click</a> modular router
code, but intend to keep the option of using native forwarding for
those that prefer it.
<P>
XORP does provide routing protocols (BGP, RIP, PIM Sparse Mode),
support protocols (IGMPv2, MLDv1), and management mechanisms (command
line interface, SNMP).  This list will grow as more people start
<a href="contributing.html">contributing</a> to XORP.
<P>
The XORP core is not intended to be just research-quality code.  In
it's role as a research platform, it is critical that XORP can be
deployed in production environments.  Thus it's really important to us
that XORP is stable and secure.  While we have an extensive set of
internal <a href="#validating">test suites</a>, these can only test so
much.  True stability will only come from real-world testing - if you
try XORP, and it doesn't do what you expect or hope, please let us
know, either through email to feedback at xorp.org or <a
href="http://www.xorp.org/bugzilla/index.cgi">bugzilla</a>.
</td></tr></table><P>


<table border="0" cellpadding="10"  cellspacing="3" 
width="100%" bgcolor="#b0b0b0">
<TR><TD bgcolor="#b0b0b0">
  <a name="getting"><h4>Getting XORP</h4></a>
</TD</TR>
<TR><TD bgcolor="#ffffff">
<P>
There are three ways to try out XORP.  
<UL>
<LI><a href="downloads.html">Download</a> a release, and <a
href="#compiling">compile</a> it from source.
<LI>Get the current source snapshot <a href="cvs.html">from CVS</a> and <a
href="#compiling">compile</a> it.
<LI>Download a <a href="livecd.html">live CD</a>, and try out a
precompiled release.
</UL>
If you want to develop new functionality for XORP, you'll obviously
need to compile from source, but the live CD provides a way to try
XORP out without needing to worry about having the right compilers or
operating system installed.
</td></tr></table><P>


<table border="0" cellpadding="10"  cellspacing="3" 
width="100%" bgcolor="#b0b0b0">
<TR><TD bgcolor="#b0b0b0">
  <a name="os"><h4>Supported Operating Systems</h4></a>
</TD</TR>
<TR><TD bgcolor="#ffffff">
<P>
XORP should be fairly portable.  At the present time, XORP the main
development platforms for XORP are FreeBSD and Linux.  XORP should run
on all recent versions of FreeBSD (as of April 2004, we recommend
FreeBSD 4.9) and on most versions of Linux with a 2.4.x kernel.  
<P>
XORP compiles on MacOS 10.2 or later, but there is not currently any
forwarding support.  If you try XORP on another platform, let us know
how you fare.  See <a href="#porting">porting</a> if you're interested
in porting XORP to a new platform.
<P>
We aim to add Windows XP to our supported platforms during 2004.
</td></tr></table><P>

<table border="0" cellpadding="10"  cellspacing="3" 
width="100%" bgcolor="#b0b0b0">
<TR><TD bgcolor="#b0b0b0">
  <a name="compiling"><h3>Compiling XORP from source</h3></a>
</TD</TR>
<TR><TD bgcolor="#ffffff">
<P>
XORP is written in C++.  We've endeavoured to comply as far as
possible with the ANSI standards, but currently XORP has only been
compiled with variants of gcc.  XORP is known to compile on gcc
2.95.x, 2.96, 3.2.x, 3.3.x, and pre-releases of 3.4.  
<P>
Our <a href="#tinderbox">tinderbox</a> checks daily that XORP still
compiles and passes its validation tests with 2.95.4, 3.3.4, and
3.4-prerelease.  The aim is that you should always be able to check
out a current source snapshot from CVS, compile it, and have it pass
all the internal validation tests.  We don't always succeed, but
failures identified by the tinderbox are always fixed very rapidly.
<P>
To compile XORP requires nearly 1GB of free disk space, and up to an
hour depending on your CPU speed and the version of the compiler
you're using.  Much of this is spent compiling the validation tests,
which are always built by default.
<P>
To compile XORP, you will need gmake installed. This is the default on
Linux but not on FreeBSD.
<P>
Assuming you have a checked out copy of the XORP source, you should be
able to compile XORP by typing (in the top-level XORP source directory
where the file "VERSION" is located):
<PRE>
# ./configure
# gmake
</PRE>
Note: gmake may be installed as make on some platforms.  Then go away
and have a coffee or two.
<P>
This will build XORP "in place".  That is, the bgp binary (xorp_bgp)
will be left in the bgp subdirectory, the XORP shell binary (xorpsh)
will be left in the rtrmgr directory, and so on.  This default can be
overridden (for example, if you're cross-compiling multiple platforms
from the same source), but there's no need to if you're just starting
out.
</td></tr></table><P>


<table border="0" cellpadding="10"  cellspacing="3" 
width="100%" bgcolor="#b0b0b0">
<TR><TD bgcolor="#b0b0b0">
  <a name="validating"><h4>Validating a XORP Compilation</h4></a>
</TD</TR>
<TR><TD bgcolor="#ffffff">
<P>
Assuming the compilation completed without errors, you should now
validate that the build actually runs correctly.  In the top-level
directory, type:
<PRE>
# gmake check
</PRE>
This will run all the internal validation tests for all the XORP
modules.  This is a rather lengthy procedure, but it's a good idea to
be sure that everything is working.  
<P>
The debugging output can sometimes be a little excessive, but what
you're looking for is lines like:
<pre>
PASS: test_trie
</pre>
which indicates that a particular test program completed successfully.
Hopefully you won't see any lines like:
<pre>
FAIL: test_peering1.sh
</pre>
Which indicates a particular validation test failed.  
<P>
There can be warnings such as:
<pre>
[ 2004/04/22 00:48:57 WARNING coord BGP ] TCP connection from test_peer: peer1 to localhost closed
</pre>
Unless these result in a FAIL message, they are typically
transient artifacts of the testing methodology, and can safely be
ignored.
<P>
</td></tr></table><P>

<table border="0" cellpadding="10"  cellspacing="3" 
width="100%" bgcolor="#b0b0b0">
<TR><TD bgcolor="#b0b0b0">
  <a name="running"><h4>Running XORP</h4></a>
</TD</TR>
<TR><TD bgcolor="#ffffff">
<P>
XORP tries to hide from the operator the internal structure of the
software, so that the operator only needs to know the right commands
to use to configure the router.  The operator should not need to know
that XORP is internally composed of multiple processes, nor what those
processes do.  All the operator needs to see is a single router
configuration file that determines the startup configuration, and a
single command line interface that can be used to configure XORP.
<P>
There is a single XORP process that manages the whole XORP router -
this is called <B>xorp_rtrmgr</B> (short for XORP Router Manager).  If
you built XORP from source using the defaults, the xorp_rtrmgr binary
will be in the rtrmgr subdirectory.
<P>
xorp_rtrmgr will expect to find a configuration file in the same
directory it is started from.  By default this configuration file is
called <B>config.boot</B>.  You can specify a different filename using
the -b command line flag.  The -n "no execute" flag will cause
xorp_rtrmgr to startup and pretend the router is operating normally,
but to not actually start any processes.  This can be used to check
configuration files.  
<P>
Typically xorp_rtrmgr must be run as root.  This is because it starts
up all processes that need privileged access to insert routes into
the forwarding path in the kernel.
<P>
If you are using the live CD, then xorp_rtrmgr should start by default
after the OS has booted, and read the config.boot file from the floppy
drive.
<P>
To interact with the router via the command line interface, the
operator uses the XORP command shell <B>xorpsh</B>.  If you compiled
from source, this should also be in the rtrmgr subdirectory.  xorpsh
should not normally be run as root, but if a user is going to change
the configuration of the router (as opposed to simply monitor the
router's operation) then they need to be in the "xorp" Unix group.  If
you are using the live CD then, by default, logging in as username
xorp should cause the user's login shell to be xorpsh.
<P>
The <a
href="/releases/current/docs/rtrmgr/xorpsh_userguide.pdf">xorpsh user
manual</a> (PDF) provides basic information about how to use xorpsh.
The "help" command also provides basic online help.  To learn how to
configure specific routing protocols, interface IP addresses, and so
forth, you need to see the <a
href="/releases/current/docs/index.html">relevant user manuals</a>.
</TD></TR>
</table><P>

<table border="0" cellpadding="10"  cellspacing="3" 
width="100%" bgcolor="#b0b0b0">
<TR><TD bgcolor="#b0b0b0">
  <a name="inside"><h4>Inside XORP</h4></a>
</TD</TR>
<TR><TD bgcolor="#ffffff">
<P>
<img src="releases/current/docs/processes3.png">
<P>
XORP is implemented as multiple processes communicated through a novel
<a
href="releases/current/docs/libxipc/xrl_interfaces.pdf">inter-process
communication mechanism</a> (PDF) called XORP Resource Locators or
XRLs for short.  A design overview is <a
href="releases/current/docs/design_arch/design_arch.pdf">here</a>.
</TD></TR> </table><P>


<table border="0" cellpadding="10"  cellspacing="3" 
width="100%" bgcolor="#b0b0b0">
<TR><TD bgcolor="#b0b0b0">
  <a name="porting"><h4>Porting XORP to a new platform</h4></a>
</TD</TR>
<TR><TD bgcolor="#ffffff">
<P>
Notes on porting:
<P>
Most of XORP should be relatively portable.  The first requirement is
that you have a compatible C++ compiler.  All recent versions of gcc
should work, but we don't yet know about other compilers.
<P>
The goal is for all of the system dependencies to be in the Forwarding
Engine Abstraction process.  To port XORP to a new platform, either an
existing FEA must be ported to that platform, or a new bottom end to
FEA will need to be written.  FreeBSD and Linux use different bottom
ends to the FEA.
<P>
The libxipc XRL IPC library may need work to port, but this should not
be a significant problem on most platforms.
<P>
System dependencies on raw sockets, and similar things that differ
from OS to OS should not be present in the routing protocols, but
should rather be relayed through requests via the FEA.  At the present
time this is not true of all routing protocols.

</TD></TR> </table><P>


<hr>
<address>feedback&#64;xorp&#46;org</address>
<!-- Created: Tue Dec 10 16:03:16 PST 2002 -->
<!-- hhmts start -->
Last modified: Wed Apr 21 11:29:03 PDT 2004
<!-- hhmts end -->

  </body>
</html>

