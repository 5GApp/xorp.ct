""" C++ generic callback template generator

Notes:

This program generates types and methods for creating and invoking
callbacks in C++ with arbitrary bound arguments and late arguments
passed in.

At present the generated code assumes that returning void is permitted
by the compiler.  Some additional hacking will be needed to support
the specializations necessary when this is not the case, but on our
main build system this is not an issue.

The notion of having a script to generate templates was borrowed from
David Mazieres callback.h file (in the async lib distributed with
sfs).  The code generated bears strong similarities to David's work, but
was largely written independently of it. 

"""

import getopt, sys, string

def aname(type):
    """Return arg name derived from type"""
    return type.lower()

def decl_arg(t):
    return "%s %s" % (t, aname(t))

def decl_args(types):
    return map(decl_arg, types)

def mem_arg(t):
    return "_%s" % aname(t)

def mem_args(types):
    return map(mem_arg, types)

def mem_decl(t):
    return "%s %s" % (t, mem_arg(t))

def mem_decls(types):
    return map(mem_decl, types)

def cons_arg(t):
    return "%s(%s)" % (mem_arg(t), aname(t))

def cons_args(types):
    return map(cons_arg, types)

def call_args(types):
    return map(aname, types)

def class_arg(t):
    return "class %s" % t

def class_args(types):
    return map(class_arg, types)

def csv(l):
    """
    Transform list of strings into a comma separated values string
    """
    s = ''
    n = len(l)
    if (n >= 1):
        s = "%s" % l[0]
    for i in range(1,n):
        s += ", %s" % l[i]
    return s;

def joining_csv(l):
    """
    Transform list of strings into a comma separated values string suitable
    for appending to an existing comma separated value string.
    """
    s = ''
    n = len(l)
    for i in range(0,n):
        s += ", %s" % l[i]
    return s;

def output_header(procname, nb, nl):
    from time import time, localtime, strftime
    print \
"""/*
 * Copyright (c) 2001,2002 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by '%s -b %d -l %d' on %s.
 */
"""  % (procname, nb, nl, 						      \
        strftime("%d %b %Y %H:%M:%S", localtime(time())))

    print """
/**
 * @libdoc Callbacks
 *
 * @sect Callback Overview
 *
 * XORP is an asynchronous programming environment and as a result there
 * are many places where callbacks are useful.  Callbacks are typically
 * invoked to signify the completion or advancement of an asynchronous
 * operation.
 *
 * XORP provides a generic and flexible callback interface that utilizes
 * overloaded templatized functions for for generating callbacks
 * in conjunction with many small templatized classes. Whilst this makes
 * the syntax a little ugly, it provides a great deal of flexibility.
 *
 * XorpCallbacks are callback objects are created by the callback()
 * function which returns a reference pointer to a newly created callback
 * object.  The callback is invoked by calling dispatch(), eg.
 *
<pre>

#include <iostream>

#include "config.h"
#include "libxorp/callback.hh"

static void hello_world() { 
    cout << "Hello World" << endl;
}

int main() {
    // Typedef callback() return type for readability.  SimpleCallback
    // declares a XorpCallback taking 0 arguments and of return type void.
    typedef XorpCallback0<void>::RefPtr SimpleCallback;

    // Create XorpCallback object using callback()
    SimpleCallback cb = callback(hello_world);
    
    // Invoke callback, results in call to hello_world.
    cb->dispatch();
    return 0;
}

</pre>
 *
 * The callback() method is overloaded and can also be used to create
 * callbacks to member functions, eg.
 *
<pre>

#include <iostream>

#include "config.h"
#include "libxorp/callback.hh"

class Foo {
public:
    void hello_world() { 
	cout << "Foo::Hello World" << endl;
    }
};

int main() {
    typedef XorpCallback0<void>::RefPtr SimpleCallback;

    Foo f;

    // Create a callback to a member function
    SimpleCallback cb = callback(&f, &Foo::hello_world);

    // Invoke f.hello_world
    cb->dispatch();

    return 0;
}

</pre>
 *
 * In addition, to being able to invoke member functions, callbacks can
 * also store arguments to functions. eg.
 *
<pre>

#include <iostream>

#include "config.h"
#include "libxorp/callback.hh"

static int sum(int x, int y) {
    cout << "sum(x = " << x << ", y = " << y << ")" << endl;
    return x + y;
}

int main() {
    // Callback to function returning "int"
    typedef XorpCallback0<int>::RefPtr NoArgCallback;

    NoArgCallback cb1 = callback(sum, 1, 2);
    cout << "cb1->dispatch() returns " << cb1->dispatch() << endl; // "3"

    // Callback to function returning int and taking an integer argument
    typedef XorpCallback1<int,int>::RefPtr OneIntArgCallback;

    OneIntArgCallback cb2 = callback(sum, 5);
    cout << "cb2->dispatch(10) returns " << cb2->dispatch(10) << endl; // 15
    cout << "cb2->dispatch(20) returns " << cb2->dispatch(20) << endl; // 25

    // Callback to function returning int and taking  2 integer arguments
    typedef XorpCallback2<int,int,int>::RefPtr TwoIntArgCallback;

    TwoIntArgCallback cb3 = callback(sum);
    cout << "cb3->dispatch() returns " << cb3->dispatch(50, -50) << endl; // 0

    return 0;
}

</pre>
 *
 * Bound arguments, as with member functions, are implemented by the
 * overloading of the callback() method.  At dispatch time, the bound
 * arguments are last arguments past to the wrappered function.  If you
 * compile and run the program you will see:
 *
<pre>
sum(x = 10, y = 5)
cb2->dispatch(10) returns 15
</pre>
 *
 * and:
 *
<pre>
sum(x = 20, y = 5)
cb2->dispatch(10) returns 25
</pre>
 *
 * for the one bound argument cases.
 *
 * @sect Declaring Callback Types
 *
 * There are a host of XorpCallbackN types.  The N denotes the number
 * of arguments that will be passed at dispatch time by the callback
 * invoker.  The template parameters to XorpCallbackN types are the
 * return value followed by the types of arguments that will be passed
 * at dispatch time.  Thus type:
 *
 * <pre>
XorpCallback1<double, int>::RefPtr
 * </pre>
 *
 * corresponds to callback object returning a double when invoked and
 * requiring an integer argument to passed at dispatch time.
 *
 * When arguments are bound to a callback they are not specified
 * in the templatized argument list. So the above declaration is good
 * for a function taking an integer argument followed by upto the
 * maximum number of bound arguments.
 *
 * Note: In this header file, support is provided for upto %d bound
 * arguments and %d dispatch arguments.
 *
 * @sect Ref Pointer Helpers
 * 
 * Callback objects may be set to NULL, since they use reference pointers
 * to store the objects.  Callbacks may be unset using the ref_ptr::release()
 * method:
 *
<pre>
    cb.release();
</pre>
 * and to tested using the ref_ptr::is_empty() method:
<pre>
if (! cb.is_empty()) {
    cb->dispatch();
}
</pre>
 *
 * In many instances, the RefPtr associated with a callback on an object
 * will be stored by the object itself.  For instance, a class may own a
 * timer object and the associated timer expiry callback which is
 * a member function of the containing class.  Because the containing class
 * owns the callback object corresponding the timer callback, there is
 * never an opportunity for the callback to be dispatched on a deleted object
 * or with invalid data.
 */
""" % (nb, nl)

    print """
#ifndef __XORP_CALLBACK_HH__
#define __XORP_CALLBACK_HH__

#include "ref_ptr.hh"
"""

def output_trailer():
    print "#endif /* __XORP_CALLBACK_HH__ */"

def output_kdoc_baseclass(nl):
    print "/**"
    print " * @short Base class for callbacks with %d dispatch time args." % nl
    print " */"

def output_kdoc_class(target, nl, nb):
    print "/**"
    print " * @short Callback object for %s with %d dispatch time" % (target, nl)
    print " * arguments and %d bound (stored) arguments." % nb
    print " */"

def output_kdoc_factory(target, nl, nb):
    print "/**"
    print " * Factory function that creates a callback object targetted at a"
    print " * %s with %d dispatch time arguments and %d bound arguments." % (target, nl, nb)
    print " */"

def output_base(l_types):
    n = len(l_types)

    print "/* ------------------------------------------------------------------------- */"
    print "/* Code relating to callbacks with %d late args */" % n
    print
    output_kdoc_baseclass(n)
    print "template<class R%s>" % joining_csv(class_args(l_types))
    print "struct XorpCallback%d {" % n
    print "    typedef ref_ptr<XorpCallback%d> RefPtr;" % n
    print "    virtual ~XorpCallback%d() {}" % n
    print "    virtual R dispatch(%s)" % csv(l_types) + " = 0;"
    print "};\n"

def output_rest(l_types, b_types):
    nl = len(l_types)
    nb = len(b_types)

    output_kdoc_class("functions", nl, nb)
    print "template <class R%s>" % joining_csv(class_args(l_types) + class_args(b_types))
    print "struct XorpFunctionCallback%dB%d : public XorpCallback%d<R%s> {" \
          % (nl, nb, nl, joining_csv(l_types))
    print "    typedef R (*F)(%s);" % csv(l_types + b_types)
    print "    XorpFunctionCallback%dB%d(F f%s) : _f(f)%s {}" \
          % (nl, nb, joining_csv(decl_args(b_types)), joining_csv(cons_args(b_types)))
    print "    R dispatch(%s) { return (*_f)(%s); }" \
          % (csv(decl_args(l_types)), csv(call_args(l_types) + mem_args(b_types)))
    print "protected:\n    F   _f;"
    for ba in mem_decls(b_types):
        print "    %s;" % ba
    print "};"
    print
    output_kdoc_factory("function", nl, nb)
    print "template <class R%s>" % joining_csv(class_args(l_types + b_types))
    print "typename XorpCallback%d<R%s>::RefPtr" % (nl, joining_csv(l_types))
    print "callback(R (*f)(%s)%s) {" % (csv(l_types + b_types), joining_csv(decl_args(b_types)))
    print "    return XorpCallback%d<R%s>::RefPtr(new XorpFunctionCallback%dB%d<R%s>(f%s));" \
          % (nl, joining_csv(l_types), nl, nb, joining_csv(l_types + b_types), joining_csv(call_args(b_types)))
    print "}"
    print

    for CONST,const in [('',''), ('Const', ' const')]:
        output_kdoc_class("%s member methods" % const, nl, nb)
        print "template <class R, class O%s>" % (joining_csv(class_args(l_types + b_types)))
        print "struct Xorp%sMemberCallback%dB%d : XorpCallback%d<R%s> {" \
              % (CONST, nl, nb, nl, joining_csv(l_types))
        print "    typedef R (O::*M)(%s) %s;" % (csv(l_types + b_types), const)
        print "    Xorp%sMemberCallback%dB%d(O *o, M m%s) : _o(o), _m(m)%s {}" \
              % (CONST, nl, nb, joining_csv(decl_args(b_types)), \
                 joining_csv(cons_args(b_types)))
        print "    R dispatch(%s) { return ((*_o).*_m)(%s); }" \
              % (csv(decl_args(l_types)), csv(call_args(l_types) + mem_args(b_types)))
        print "protected:"
        print "    O	*_o;	// Callback's target object"
        print "    M	 _m;	// Callback's target method"
        for ba in mem_decls(b_types):
            print "    %s;	// Bound argument" % ba
        print "};"

        for p,q in [('*', ''), ('&', '&')]:
            print
            output_kdoc_factory("%s member function" % const, nl, nb)
            print "template <class R, class O%s> typename XorpCallback%s<R%s>::RefPtr" \
                      % (joining_csv(class_args(l_types) + class_args(b_types)), nl, (joining_csv(l_types)))
            print "callback(O %so, R (O::*p)(%s)%s%s)" \
                      % (p, csv(l_types + b_types), const, joining_csv(decl_args(b_types)))
            print "{"
            print "    return XorpCallback%d<R%s>::RefPtr(new Xorp%sMemberCallback%dB%d<R, O%s>(%so, p%s));" \
                      % (nl, joining_csv(l_types), CONST, nl, nb, joining_csv(l_types + b_types), \
                         q, joining_csv(call_args(b_types)))
            print "}"
        print

def cb_gen(max_bound, max_late):
    l_types = []
    for l in range(0, max_late):
        if (l):
            l_types.append("A%d" % l);
        output_base(l_types)

        b_types = []
        for b in range (0, max_bound):
            if (b):
                b_types.append("BA%d" % b)
            output_rest(l_types, b_types)

us=\
"""usage: %s [-h|--help] [-b <max_bound_args>] [-l <max_late_args>]"""

def main():
    def usage():
        print us % sys.argv[0]

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hb:l:",\
                                   ["help", "bound-args=", "late-args="])
    except getopt.GetoptError:
        usage()
        sys.exit(1)

    nb = 4
    nl = 4
    for o, a in opts:
        if (o in ("-h", "--help")):
            usage()
            sys.exit()
        if (o in ("-b", "--bound-args")):
            nb = int(a)
        if (o in ("-l", "--late-args")):
            nl = int(a)

    output_header(sys.argv[0], nb, nl)
    
    cb_gen(nb + 1, nl + 1)

    output_trailer()

if __name__ == '__main__':
    main()
