/*
 * Copyright (c) 2001-2007 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 *
 * $XORP: xorp/xrl/targets/fea_base.hh,v 1.77 2007/08/09 07:03:26 pavlin Exp $
 */


#ifndef __XRL_TARGETS_FEA_BASE_HH__
#define __XRL_TARGETS_FEA_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlFeaTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlFeaTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlFeaTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlFeaTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "fea/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Load Click FEA support.
     */
    virtual XrlCmdError fea_click_0_1_load_click() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Unload Click FEA support.
     */
    virtual XrlCmdError fea_click_0_1_unload_click() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable Click FEA support.
     *
     *  @param enable if true, then enable the Click FEA support, otherwise
     *  disable it.
     */
    virtual XrlCmdError fea_click_0_1_enable_click(
	// Input values,
	const bool&	enable) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start Click FEA support.
     */
    virtual XrlCmdError fea_click_0_1_start_click() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Stop Click FEA support.
     */
    virtual XrlCmdError fea_click_0_1_stop_click() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable duplicating the Click routes to the system kernel.
     *
     *  @param enable if true, then enable duplicating the Click routes to the
     *  system kernel, otherwise disable it.
     */
    virtual XrlCmdError fea_click_0_1_enable_duplicate_routes_to_kernel(
	// Input values,
	const bool&	enable) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable kernel-level Click FEA support.
     *
     *  @param enable if true, then enable the kernel-level Click FEA support,
     *  otherwise disable it.
     */
    virtual XrlCmdError fea_click_0_1_enable_kernel_click(
	// Input values,
	const bool&	enable) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable installing kernel-level Click on startup.
     *
     *  @param enable if true, then install kernel-level Click on startup.
     */
    virtual XrlCmdError fea_click_0_1_enable_kernel_click_install_on_startup(
	// Input values,
	const bool&	enable) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the list of kernel Click modules to load on startup if
     *  installing kernel-level Click on startup is enabled. The file names of
     *  the kernel modules are separated by colon.
     *
     *  @param modules the list of kernel Click modules (separated by colon) to
     *  load.
     */
    virtual XrlCmdError fea_click_0_1_set_kernel_click_modules(
	// Input values,
	const string&	modules) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the kernel-level Click mount directory.
     *
     *  @param directory the kernel-level Click mount directory.
     */
    virtual XrlCmdError fea_click_0_1_set_kernel_click_mount_directory(
	// Input values,
	const string&	directory) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the external program to generate the kernel-level Click
     *  configuration.
     *
     *  @param kernel_click_config_generator_file the name of the external
     *  program to generate the kernel-level Click configuration.
     */
    virtual XrlCmdError fea_click_0_1_set_kernel_click_config_generator_file(
	// Input values,
	const string&	kernel_click_config_generator_file) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable user-level Click FEA support.
     *
     *  @param enable if true, then enable the user-level Click FEA support,
     *  otherwise disable it.
     */
    virtual XrlCmdError fea_click_0_1_enable_user_click(
	// Input values,
	const bool&	enable) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the user-level Click command file.
     *
     *  @param user_click_command_file the name of the user-level Click command
     *  file.
     */
    virtual XrlCmdError fea_click_0_1_set_user_click_command_file(
	// Input values,
	const string&	user_click_command_file) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the extra arguments to the user-level Click command.
     *
     *  @param user_click_command_extra_arguments the extra arguments to the
     *  user-level Click command.
     */
    virtual XrlCmdError fea_click_0_1_set_user_click_command_extra_arguments(
	// Input values,
	const string&	user_click_command_extra_arguments) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify whether to execute on startup the user-level Click command.
     *
     *  @param user_click_command_execute_on_startup if true, then execute the
     *  user-level Click command on startup.
     */
    virtual XrlCmdError fea_click_0_1_set_user_click_command_execute_on_startup(
	// Input values,
	const bool&	user_click_command_execute_on_startup) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the address to use for control access to the user-level Click.
     *
     *  @param user_click_control_address the address to use for control access
     *  to the user-level Click.
     */
    virtual XrlCmdError fea_click_0_1_set_user_click_control_address(
	// Input values,
	const IPv4&	user_click_control_address) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the socket port to use for control access to the user-level
     *  Click.
     *
     *  @param user_click_control_socket_port the socket port to use for
     *  control access to the user-level Click.
     */
    virtual XrlCmdError fea_click_0_1_set_user_click_control_socket_port(
	// Input values,
	const uint32_t&	user_click_control_socket_port) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the configuration file to be used by user-level Click on
     *  startup.
     *
     *  @param user_click_startup_config_file the name of the configuration
     *  file to be used by user-level Click on startup.
     */
    virtual XrlCmdError fea_click_0_1_set_user_click_startup_config_file(
	// Input values,
	const string&	user_click_startup_config_file) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Specify the external program to generate the user-level Click
     *  configuration.
     *
     *  @param user_click_config_generator_file the name of the external
     *  program to generate the user-level Click configuration.
     */
    virtual XrlCmdError fea_click_0_1_set_user_click_config_generator_file(
	// Input values,
	const string&	user_click_config_generator_file) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add a FIB client.
     *
     *  @param client_target_name the target name of the FIB client to add.
     *
     *  @param send_updates whether updates should be sent.
     *
     *  @param send_resolves whether resolution requests should be sent.
     */
    virtual XrlCmdError fea_fib_0_1_add_fib_client4(
	// Input values,
	const string&	client_target_name,
	const bool&	send_updates,
	const bool&	send_resolves) = 0;

    virtual XrlCmdError fea_fib_0_1_add_fib_client6(
	// Input values,
	const string&	client_target_name,
	const bool&	send_updates,
	const bool&	send_resolves) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete a FIB client.
     *
     *  @param client_target_name the target name of the FIB client to delete.
     */
    virtual XrlCmdError fea_fib_0_1_delete_fib_client4(
	// Input values,
	const string&	client_target_name) = 0;

    virtual XrlCmdError fea_fib_0_1_delete_fib_client6(
	// Input values,
	const string&	client_target_name) = 0;

    virtual XrlCmdError ifmgr_0_1_set_restore_original_config_on_shutdown(
	// Input values,
	const bool&	enable) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_interface_names(
	// Output values,
	XrlAtomList&	ifnames) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_names(
	// Input values,
	const string&	ifname,
	// Output values,
	XrlAtomList&	vifs) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_flags(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	bool&	enabled,
	bool&	broadcast,
	bool&	loopback,
	bool&	point_to_point,
	bool&	multicast) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_pif_index(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	uint32_t&	pif_index) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_addresses4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	XrlAtomList&	addresses) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_addresses6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	XrlAtomList&	addresses) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_address_flags4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	bool&	enabled,
	bool&	broadcast,
	bool&	loopback,
	bool&	point_to_point,
	bool&	multicast) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_address_flags6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	// Output values,
	bool&	enabled,
	bool&	loopback,
	bool&	point_to_point,
	bool&	multicast) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_interface_enabled(
	// Input values,
	const string&	ifname,
	// Output values,
	bool&	enabled) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_interface_discard(
	// Input values,
	const string&	ifname,
	// Output values,
	bool&	discard) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_mac(
	// Input values,
	const string&	ifname,
	// Output values,
	Mac&	mac) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_mtu(
	// Input values,
	const string&	ifname,
	// Output values,
	uint32_t&	mtu) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_no_carrier(
	// Input values,
	const string&	ifname,
	// Output values,
	bool&	no_carrier) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_enabled(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	bool&	enabled) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_prefix4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	uint32_t&	prefix_len) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_broadcast4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	IPv4&	broadcast) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_endpoint4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	IPv4&	endpoint) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_prefix6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	// Output values,
	uint32_t&	prefix_len) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_endpoint6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	// Output values,
	IPv6&	endpoint) = 0;

    virtual XrlCmdError ifmgr_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;

    virtual XrlCmdError ifmgr_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;

    virtual XrlCmdError ifmgr_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;

    virtual XrlCmdError ifmgr_0_1_create_interface(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;

    virtual XrlCmdError ifmgr_0_1_delete_interface(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Implicitly configure all interfaces within the FEA by using information
     *  from the underlying system.
     *
     *  @param tid the transaction ID.
     */
    virtual XrlCmdError ifmgr_0_1_configure_all_interfaces_from_system(
	// Input values,
	const uint32_t&	tid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Implicitly configure an interface within the FEA by using information
     *  from the underlying system.
     *
     *  @param tid the transaction ID.
     *
     *  @param ifname the name of the interface to configure.
     */
    virtual XrlCmdError ifmgr_0_1_configure_interface_from_system(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;

    virtual XrlCmdError ifmgr_0_1_set_interface_enabled(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	enabled) = 0;

    virtual XrlCmdError ifmgr_0_1_set_interface_discard(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	discard) = 0;

    virtual XrlCmdError ifmgr_0_1_set_mac(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const Mac&	mac) = 0;

    virtual XrlCmdError ifmgr_0_1_restore_original_mac(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;

    virtual XrlCmdError ifmgr_0_1_set_mtu(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const uint32_t&	mtu) = 0;

    virtual XrlCmdError ifmgr_0_1_restore_original_mtu(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a vif
     *
     *  @param ifname the name of the physical interface associated with the
     *  new vif.
     *
     *  @param vif name for new vif, must be unique across all the vifs in the
     *  system.
     */
    virtual XrlCmdError ifmgr_0_1_create_vif(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif) = 0;

    virtual XrlCmdError ifmgr_0_1_delete_vif(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif) = 0;

    virtual XrlCmdError ifmgr_0_1_set_vif_enabled(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const bool&	enabled) = 0;

    virtual XrlCmdError ifmgr_0_1_create_address4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address) = 0;

    virtual XrlCmdError ifmgr_0_1_delete_address4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address) = 0;

    virtual XrlCmdError ifmgr_0_1_set_address_enabled4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const bool&	enabled) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_address_enabled4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	bool&	enabled) = 0;

    virtual XrlCmdError ifmgr_0_1_set_prefix4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const uint32_t&	prefix_len) = 0;

    virtual XrlCmdError ifmgr_0_1_set_broadcast4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const IPv4&	broadcast) = 0;

    virtual XrlCmdError ifmgr_0_1_set_endpoint4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const IPv4&	endpoint) = 0;

    virtual XrlCmdError ifmgr_0_1_create_address6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address) = 0;

    virtual XrlCmdError ifmgr_0_1_delete_address6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address) = 0;

    virtual XrlCmdError ifmgr_0_1_set_address_enabled6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const bool&	enabled) = 0;

    virtual XrlCmdError ifmgr_0_1_get_configured_address_enabled6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	// Output values,
	bool&	enabled) = 0;

    virtual XrlCmdError ifmgr_0_1_set_prefix6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const uint32_t&	prefix_len) = 0;

    virtual XrlCmdError ifmgr_0_1_set_endpoint6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const IPv6&	endpoint) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register remote mirror of interface state.
     */
    virtual XrlCmdError ifmgr_replicator_0_1_register_ifmgr_mirror(
	// Input values,
	const string&	clientname) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register remote mirror of interface state.
     */
    virtual XrlCmdError ifmgr_replicator_0_1_unregister_ifmgr_mirror(
	// Input values,
	const string&	clientname) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup a route for a destination host address.
     *
     *  @param dst the destination host address to lookup.
     *
     *  @param nexthop the address of the next-hop router toward dst.
     *
     *  @param ifname the name of the physical interface toward dst.
     *
     *  @param vifname the name of the virtual interface toward dst.
     *
     *  @param metric the routing metric toward dst.
     *
     *  @param admin_distance the administratively defined distance toward dst.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError fti_0_2_lookup_route_by_dest4(
	// Input values,
	const IPv4&	dst,
	// Output values,
	IPv4Net&	netmask,
	IPv4&	nexthop,
	string&	ifname,
	string&	vifname,
	uint32_t&	metric,
	uint32_t&	admin_distance,
	string&	protocol_origin) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup a route for a destination host address.
     *
     *  @param dst the destination host address to lookup.
     *
     *  @param nexthop the address of the next-hop router toward dst.
     *
     *  @param ifname the name of the physical interface toward dst.
     *
     *  @param vifname the name of the virtual interface toward dst.
     *
     *  @param metric the routing metric toward dst.
     *
     *  @param admin_distance the administratively defined distance toward dst.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError fti_0_2_lookup_route_by_dest6(
	// Input values,
	const IPv6&	dst,
	// Output values,
	IPv6Net&	netmask,
	IPv6&	nexthop,
	string&	ifname,
	string&	vifname,
	uint32_t&	metric,
	uint32_t&	admin_distance,
	string&	protocol_origin) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup a route for a destination subnet address.
     *
     *  @param dst the destination subnet address to lookup.
     *
     *  @param nexthop the address of the next-hop router toward dst.
     *
     *  @param ifname the name of the physical interface toward dst.
     *
     *  @param vifname the name of the virtual interface toward dst.
     *
     *  @param metric the routing metric toward dst.
     *
     *  @param admin_distance the administratively defined distance toward dst.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError fti_0_2_lookup_route_by_network4(
	// Input values,
	const IPv4Net&	dst,
	// Output values,
	IPv4&	nexthop,
	string&	ifname,
	string&	vifname,
	uint32_t&	metric,
	uint32_t&	admin_distance,
	string&	protocol_origin) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup a route for a destination subnet address.
     *
     *  @param dst the destination subnet address to lookup.
     *
     *  @param nexthop the address of the next-hop router toward dst.
     *
     *  @param ifname the name of the physical interface toward dst.
     *
     *  @param vifname the name of the virtual interface toward dst.
     *
     *  @param metric the routing metric toward dst.
     *
     *  @param admin_distance the administratively defined distance toward dst.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError fti_0_2_lookup_route_by_network6(
	// Input values,
	const IPv6Net&	dst,
	// Output values,
	IPv6&	nexthop,
	string&	ifname,
	string&	vifname,
	uint32_t&	metric,
	uint32_t&	admin_distance,
	string&	protocol_origin) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test if the underlying system supports IPv4.
     *
     *  @param result true if the underlying system supports IPv4, otherwise
     *  false.
     */
    virtual XrlCmdError fti_0_2_have_ipv4(
	// Output values,
	bool&	result) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test if the underlying system supports IPv6.
     *
     *  @param result true if the underlying system supports IPv4, otherwise
     *  false.
     */
    virtual XrlCmdError fti_0_2_have_ipv6(
	// Output values,
	bool&	result) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test whether the IPv4 unicast forwarding engine is enabled or disabled
     *  to forward packets.
     *
     *  @param enabled if true, then the IPv4 unicast forwarding is enabled,
     *  otherwise is disabled.
     */
    virtual XrlCmdError fti_0_2_get_unicast_forwarding_enabled4(
	// Output values,
	bool&	enabled) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test whether the IPv6 unicast forwarding engine is enabled or disabled
     *  to forward packets.
     *
     *  @param enabled if true, then the IPv6 unicast forwarding is enabled,
     *  otherwise is disabled.
     */
    virtual XrlCmdError fti_0_2_get_unicast_forwarding_enabled6(
	// Output values,
	bool&	enabled) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv4 unicast forwarding engine to enable or disable forwarding
     *  of packets.
     *
     *  @param enabled if true, then enable IPv4 unicast forwarding, otherwise
     *  disable it.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_enabled4(
	// Input values,
	const bool&	enabled) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 unicast forwarding engine to enable or disable forwarding
     *  of packets.
     *
     *  @param enabled if true, then enable IPv6 unicast forwarding, otherwise
     *  disable it.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_enabled6(
	// Input values,
	const bool&	enabled) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv4 unicast forwarding engine whether to retain existing XORP
     *  forwarding entries on startup.
     *
     *  @param retain if true, then retain the XORP forwarding entries,
     *  otherwise delete them.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(
	// Input values,
	const bool&	retain) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv4 unicast forwarding engine whether to retain existing XORP
     *  forwarding entries on shutdown.
     *
     *  @param retain if true, then retain the XORP forwarding entries,
     *  otherwise delete them.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(
	// Input values,
	const bool&	retain) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 unicast forwarding engine whether to retain existing XORP
     *  forwarding entries on startup.
     *
     *  @param retain if true, then retain the XORP forwarding entries,
     *  otherwise delete them.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(
	// Input values,
	const bool&	retain) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 unicast forwarding engine whether to retain existing XORP
     *  forwarding entries on shutdown.
     *
     *  @param retain if true, then retain the XORP forwarding entries,
     *  otherwise delete them.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(
	// Input values,
	const bool&	retain) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv4 unicast forwarding table ID to be used.
     *
     *  @param is_configured if true, the forwarding table ID is configured,
     *  otherwise the default table should be used.
     *
     *  @param table_id the IPv4 unicast forwarding table ID to be used.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_table_id4(
	// Input values,
	const bool&	is_configured,
	const uint32_t&	table_id) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 unicast forwarding table ID to be used.
     *
     *  @param is_configured if true, the forwarding table ID is configured,
     *  otherwise the default table should be used.
     *
     *  @param table_id the IPv6 unicast forwarding table ID to be used.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_table_id6(
	// Input values,
	const bool&	is_configured,
	const uint32_t&	table_id) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start transaction.
     *
     *  @param tid the transaction ID to use for this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Commit transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Abort transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete a routing entry.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param dst destination network.
     *
     *  @param nexthop nexthop router address.
     *
     *  @param ifname interface name associated with nexthop.
     *
     *  @param vifname virtual interface name with nexthop.
     *
     *  @param metric origin routing protocol metric for route.
     *
     *  @param admin_distance administrative distance of origin routing
     *  protocol.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError redist_transaction4_0_1_add_route(
	// Input values,
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;

    virtual XrlCmdError redist_transaction4_0_1_delete_route(
	// Input values,
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete all routing entries.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     */
    virtual XrlCmdError redist_transaction4_0_1_delete_all_routes(
	// Input values,
	const uint32_t&	tid,
	const string&	cookie) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start transaction.
     *
     *  @param tid the transaction ID to use for this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Commit transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Abort transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete a routing entry.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param dst destination network.
     *
     *  @param nexthop nexthop router address.
     *
     *  @param ifname interface name associated with nexthop.
     *
     *  @param vifname virtual interface name with nexthop.
     *
     *  @param metric origin routing protocol metric for route.
     *
     *  @param admin_distance administrative distance of origin routing
     *  protocol.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError redist_transaction6_0_1_add_route(
	// Input values,
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;

    virtual XrlCmdError redist_transaction6_0_1_delete_route(
	// Input values,
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete all routing entries.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     */
    virtual XrlCmdError redist_transaction6_0_1_delete_all_routes(
	// Input values,
	const uint32_t&	tid,
	const string&	cookie) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send a raw link-level packet on an interface.
     *
     *  @param if_name the interface to send the packet on.
     *
     *  @param vif_name the vif to send the packet on.
     *
     *  @param src_address the MAC source address.
     *
     *  @param dst_address the MAC destination address.
     *
     *  @param ether_type the EtherType protocol type. It must be between 1536
     *  and 65535.
     *
     *  @param payload the payload, everything after the MAC header.
     */
    virtual XrlCmdError raw_link_0_1_send(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const Mac&	src_address,
	const Mac&	dst_address,
	const uint32_t&	ether_type,
	const vector<uint8_t>&	payload) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register to receive raw link-level packets. The receiver is expected to
     *  support raw_link_client/0.1 interface.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ether_type the EtherType protocol number that the receiver is
     *  interested in. It must be between 1536 and 65535. A protocol number of
     *  0 is used to specify all protocols.
     *
     *  @param filter_program the optional filter program to be applied on the
     *  received packets. The program uses tcpdump(1) style expression.
     *
     *  @param enable_multicast_loopback if true then enable delivering of
     *  multicast datagrams back to this host (assuming the host is a member of
     *  the same multicast group).
     */
    virtual XrlCmdError raw_link_0_1_register_receiver(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const bool&	enable_multicast_loopback) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Unregister to receive raw link-level packets.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ether_type the EtherType protocol number that the receiver is
     *  not interested in anymore. It must be between 1536 and 65535. A
     *  protocol number of 0 is used to specify all protocols.
     *
     *  @param filter_program the filter program that was applied on the
     *  received packets. The program uses tcpdump(1) style expression.
     */
    virtual XrlCmdError raw_link_0_1_unregister_receiver(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join a MAC multicast group.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ether_type the EtherType protocol number that the receiver is
     *  interested in. It must be between 1536 and 65535. A protocol number of
     *  0 is used to specify all protocols.
     *
     *  @param filter_program the optional filter program to be applied on the
     *  received packets. The program uses tcpdump(1) style expression.
     *
     *  @param group_address the multicast group address to join.
     */
    virtual XrlCmdError raw_link_0_1_join_multicast_group(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const Mac&	group_address) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave a MAC multicast group.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ether_type the EtherType protocol number that the receiver is
     *  not interested in anymore. It must be between 1536 and 65535. A
     *  protocol number of 0 is used to specify all protocols.
     *
     *  @param filter_program the filter program that was applied on the
     *  received packets. The program uses tcpdump(1) style expression.
     *
     *  @param group_address the multicast group address to leave.
     */
    virtual XrlCmdError raw_link_0_1_leave_multicast_group(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const Mac&	group_address) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send an IPv4 packet on a raw socket.
     *
     *  @param if_name the interface to send the packet on. It is essential for
     *  multicast. In the unicast case this field may be empty.
     *
     *  @param vif_name the vif to send the packet on. It is essential for
     *  multicast. In the unicast case this field may be empty.
     *
     *  @param src_address the IP source address.
     *
     *  @param dst_address the IP destination address.
     *
     *  @param ip_protocol the IP protocol number. It must be between 1 and
     *  255.
     *
     *  @param ip_ttl the IP TTL (hop-limit). If it has a negative value, the
     *  TTL will be set internally before transmission.
     *
     *  @param ip_tos the Type Of Service (Diffserv/ECN bits for IPv4). If it
     *  has a negative value, the TOS will be set internally before
     *  transmission.
     *
     *  @param ip_router_alert if true, then add the IP Router Alert option to
     *  the IP packet.
     *
     *  @param ip_internet_control if true, then this is IP control traffic.
     *
     *  @param payload the payload, everything after the IP header and options.
     */
    virtual XrlCmdError raw_packet4_0_1_send(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_address,
	const IPv4&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const vector<uint8_t>&	payload) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register to receive IPv4 packets. The receiver is expected to support
     *  raw_packet4_client/0.1 interface.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is
     *  interested in. It must be between 0 and 255. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param enable_multicast_loopback if true then enable delivering of
     *  multicast datagrams back to this host (assuming the host is a member of
     *  the same multicast group.
     */
    virtual XrlCmdError raw_packet4_0_1_register_receiver(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const bool&	enable_multicast_loopback) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Unregister to receive IPv4 packets.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ip_protocol the IP Protocol number that the receiver is not
     *  interested in anymore. It must be between 0 and 255. A protocol number
     *  of 0 is used to specify all protocols.
     */
    virtual XrlCmdError raw_packet4_0_1_unregister_receiver(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join an IPv4 multicast group.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is
     *  interested in. It must be between 0 and 255. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param group_address the multicast group address to join.
     */
    virtual XrlCmdError raw_packet4_0_1_join_multicast_group(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv4&	group_address) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave an IPv4 multicast group.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is not
     *  interested in anymore. It must be between 0 and 255. A protocol number
     *  of 0 is used to specify all protocols.
     *
     *  @param group_address the multicast group address to leave.
     */
    virtual XrlCmdError raw_packet4_0_1_leave_multicast_group(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv4&	group_address) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send an IPv6 packet on a raw socket.
     *
     *  @param if_name the interface to send the packet on. It is essential for
     *  multicast. In the unicast case this field may be empty.
     *
     *  @param vif_name the vif to send the packet on. It is essential for
     *  multicast. In the unicast case this field may be empty.
     *
     *  @param src_address the IP source address.
     *
     *  @param dst_address the IP destination address.
     *
     *  @param ip_protocol the IP protocol number. It must be between 1 and
     *  255.
     *
     *  @param ip_ttl the IP TTL (hop-limit). If it has a negative value, the
     *  TTL will be set internally before transmission.
     *
     *  @param ip_tos the Type Of Service (IP traffic class for IPv6). If it
     *  has a negative value, the TOS will be set internally before
     *  transmission.
     *
     *  @param ip_router_alert if true, then add the IP Router Alert option to
     *  the IP packet.
     *
     *  @param ip_internet_control if true, then this is IP control traffic.
     *
     *  @param ext_headers_type a list of u32 integers with the types of the
     *  optional extention headers.
     *
     *  @param ext_headers_payload a list of payload data, one for each
     *  optional extention header. The number of entries must match
     *  ext_headers_type.
     *
     *  @param payload the payload, everything after the IP header and options.
     */
    virtual XrlCmdError raw_packet6_0_1_send(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_address,
	const IPv6&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const XrlAtomList&	ext_headers_type,
	const XrlAtomList&	ext_headers_payload,
	const vector<uint8_t>&	payload) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register to receive IPv6 packets. The receiver is expected to support
     *  raw_packet6_client/0.1 interface.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is
     *  interested in. It must be between 0 and 255. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param enable_multicast_loopback if true then enable delivering of
     *  multicast datagrams back to this host (assuming the host is a member of
     *  the same multicast group.
     */
    virtual XrlCmdError raw_packet6_0_1_register_receiver(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const bool&	enable_multicast_loopback) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Unregister to receive IPv6 packets.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ip_protocol the IP Protocol number that the receiver is not
     *  interested in anymore. It must be between 0 and 255. A protocol number
     *  of 0 is used to specify all protocols.
     */
    virtual XrlCmdError raw_packet6_0_1_unregister_receiver(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join an IPv6 multicast group.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is
     *  interested in. It must be between 0 and 255. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param group_address the multicast group address to join.
     */
    virtual XrlCmdError raw_packet6_0_1_join_multicast_group(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv6&	group_address) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave an IPv6 multicast group.
     *
     *  @param xrl_target_name the receiver's XRL target name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is not
     *  interested in anymore. It must be between 0 and 255. A protocol number
     *  of 0 is used to specify all protocols.
     *
     *  @param group_address the multicast group address to leave.
     */
    virtual XrlCmdError raw_packet6_0_1_leave_multicast_group(
	// Input values,
	const string&	xrl_target_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv6&	group_address) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Open a TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_tcp_open(
	// Input values,
	const string&	creator,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Open an UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open(
	// Input values,
	const string&	creator,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_tcp_open_and_bind(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open_and_bind(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound UDP multicast socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param mcast_addr the multicast group address to join.
     *
     *  @param ttl the TTL to use for this multicast socket.
     *
     *  @param reuse allow other sockets to bind to same multicast group.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open_bind_join(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	mcast_addr,
	const uint32_t&	ttl,
	const bool&	reuse,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound and connected TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_addr the address to connect to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_tcp_open_bind_connect(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound and connected UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_addr the address to connect to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open_bind_connect(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Bind a socket.
     *
     *  @param sockid the socket ID of the socket to bind.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     */
    virtual XrlCmdError socket4_0_1_bind(
	// Input values,
	const string&	sockid,
	const IPv4&	local_addr,
	const uint32_t&	local_port) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join multicast group on already bound socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param mcast_addr group to join.
     *
     *  @param join_if_addr interface address to perform join on.
     */
    virtual XrlCmdError socket4_0_1_udp_join_group(
	// Input values,
	const string&	sockid,
	const IPv4&	mcast_addr,
	const IPv4&	join_if_addr) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave multicast group on already bound socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param mcast_addr group to leave.
     *
     *  @param leave_if_addr interface address to perform leave on.
     */
    virtual XrlCmdError socket4_0_1_udp_leave_group(
	// Input values,
	const string&	sockid,
	const IPv4&	mcast_addr,
	const IPv4&	leave_if_addr) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Close socket.
     *
     *  @param sockid unique socket ID of socket to be closed.
     */
    virtual XrlCmdError socket4_0_1_close(
	// Input values,
	const string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Listen for inbound connections on socket. When a connection request
     *  received the socket creator will receive notification through
     *  socket4_user/0.1/connect_event.
     *
     *  @param sockid the unique socket ID of the socket to perform listen.
     *
     *  @param backlog the maximum number of pending connections.
     */
    virtual XrlCmdError socket4_0_1_tcp_listen(
	// Input values,
	const string&	sockid,
	const uint32_t&	backlog) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param data block of data to be sent.
     */
    virtual XrlCmdError socket4_0_1_send(
	// Input values,
	const string&	sockid,
	const vector<uint8_t>&	data) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket to a given destination. The packet is not routed as
     *  the forwarding engine sending the packet may not have access to the
     *  full routing table.
     *
     *  @param sockid unique socket ID.
     *
     *  @param remote_addr destination address for data.
     *
     *  @param remote_port destination port for data.
     *
     *  @param data block of data to be sent.
     */
    virtual XrlCmdError socket4_0_1_send_to(
	// Input values,
	const string&	sockid,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	const vector<uint8_t>&	data) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket to a given multicast group from a given interface.
     *
     *  @param sockid unique socket ID.
     *
     *  @param group_addr destination address for data.
     *
     *  @param group_port destination port for data.
     *
     *  @param ifaddr interface address
     */
    virtual XrlCmdError socket4_0_1_send_from_multicast_if(
	// Input values,
	const string&	sockid,
	const IPv4&	group_addr,
	const uint32_t&	group_port,
	const IPv4&	ifaddr,
	const vector<uint8_t>&	data) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set a named socket option.
     *
     *  @param sockid unique socket ID.
     *
     *  @param optname name of option to be set. Valid values are:
     *  "multicast_loopback" "multicast_ttl"
     *
     *  @param optval value of option to be set. If value is logically boolean
     *  then zero represents false and any non-zero value true.
     */
    virtual XrlCmdError socket4_0_1_set_socket_option(
	// Input values,
	const string&	sockid,
	const string&	optname,
	const uint32_t&	optval) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Open a TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_tcp_open(
	// Input values,
	const string&	creator,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Open an UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_udp_open(
	// Input values,
	const string&	creator,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_tcp_open_and_bind(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_udp_open_and_bind(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound UDP multicast socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param mcast_addr the multicast group address to join.
     *
     *  @param ttl the ttl to use for this multicast socket.
     *
     *  @param reuse allow other sockets to bind to same multicast group.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_udp_open_bind_join(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	mcast_addr,
	const uint32_t&	ttl,
	const bool&	reuse,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound and connected TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_addr the address to connect to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_tcp_open_bind_connect(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound and connected UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_addr the address to connect to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param is_blocking if true then the socket will be blocking, otherwise
     *  non-blocking.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_udp_open_bind_connect(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	const bool&	is_blocking,
	// Output values,
	string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Bind a socket.
     *
     *  @param sockid the socket ID of the socket to bind.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     */
    virtual XrlCmdError socket6_0_1_bind(
	// Input values,
	const string&	sockid,
	const IPv6&	local_addr,
	const uint32_t&	local_port) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join multicast group on already bound socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param mcast_addr group to join.
     *
     *  @param join_if_addr interface address to perform join on.
     */
    virtual XrlCmdError socket6_0_1_udp_join_group(
	// Input values,
	const string&	sockid,
	const IPv6&	mcast_addr,
	const IPv6&	join_if_addr) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave multicast group on already bound socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param mcast_addr group to leave.
     *
     *  @param leave_if_addr interface address to perform leave on.
     */
    virtual XrlCmdError socket6_0_1_udp_leave_group(
	// Input values,
	const string&	sockid,
	const IPv6&	mcast_addr,
	const IPv6&	leave_if_addr) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Close socket.
     *
     *  @param sockid unique socket ID of socket to be closed.
     */
    virtual XrlCmdError socket6_0_1_close(
	// Input values,
	const string&	sockid) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Listen for inbound connections on socket. When a connection request
     *  received the socket creator will receive notification through
     *  socket6_user/0.1/connect_event.
     *
     *  @param sockid the unique socket ID of the socket to perform listen.
     *
     *  @param backlog the maximum number of pending connections.
     */
    virtual XrlCmdError socket6_0_1_tcp_listen(
	// Input values,
	const string&	sockid,
	const uint32_t&	backlog) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param data block of data to be sent.
     */
    virtual XrlCmdError socket6_0_1_send(
	// Input values,
	const string&	sockid,
	const vector<uint8_t>&	data) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket to a given destination. The packet is not routed as
     *  the forwarding engine sending the packet may not have access to the
     *  full routing table.
     *
     *  @param sockid unique socket ID.
     *
     *  @param remote_addr destination address for data.
     *
     *  @param remote_port destination port for data.
     *
     *  @param data block of data to be sent.
     */
    virtual XrlCmdError socket6_0_1_send_to(
	// Input values,
	const string&	sockid,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	const vector<uint8_t>&	data) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket to a given multicast group from a given interface.
     *
     *  @param sockid unique socket ID.
     *
     *  @param group_addr destination address for data.
     *
     *  @param group_port destination port for data.
     *
     *  @param ifaddr interface address
     */
    virtual XrlCmdError socket6_0_1_send_from_multicast_if(
	// Input values,
	const string&	sockid,
	const IPv6&	group_addr,
	const uint32_t&	group_port,
	const IPv6&	ifaddr,
	const vector<uint8_t>&	data) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set a named socket option.
     *
     *  @param sockid unique socket ID.
     *
     *  @param optname name of option to be set. Valid values are:
     *  "multicast_loopback" "multicast_hops"
     *
     *  @param optval value of option to be set. If value is logically boolean
     *  then zero represents false and any non-zero value true.
     */
    virtual XrlCmdError socket6_0_1_set_socket_option(
	// Input values,
	const string&	sockid,
	const string&	optname,
	const uint32_t&	optval) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_enable(
	// Input values,
	const string&	pname) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_disable(
	// Input values,
	const string&	pname) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get log entries.
     *
     *  @param pname profile variable
     *
     *  @param instance_name to send the profiling info to.
     */
    virtual XrlCmdError profile_0_1_get_entries(
	// Input values,
	const string&	pname,
	const string&	instance_name) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear the profiling entries
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_clear(
	// Input values,
	const string&	pname) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  List all the profiling variables registered with this target.
     */
    virtual XrlCmdError profile_0_1_list(
	// Output values,
	string&	info) = 0;

private:
    const XrlCmdError handle_common_0_1_get_target_name(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_common_0_1_get_version(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_common_0_1_get_status(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_common_0_1_shutdown(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_load_click(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_unload_click(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_enable_click(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_start_click(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_stop_click(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_enable_duplicate_routes_to_kernel(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_enable_kernel_click(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_enable_kernel_click_install_on_startup(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_kernel_click_modules(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_kernel_click_mount_directory(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_kernel_click_config_generator_file(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_enable_user_click(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_user_click_command_file(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_user_click_command_extra_arguments(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_user_click_command_execute_on_startup(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_user_click_control_address(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_user_click_control_socket_port(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_user_click_startup_config_file(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_click_0_1_set_user_click_config_generator_file(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_fib_0_1_add_fib_client4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_fib_0_1_add_fib_client6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_fib_0_1_delete_fib_client4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_fib_0_1_delete_fib_client6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_restore_original_config_on_shutdown(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_interface_names(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_vif_names(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_vif_flags(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_vif_pif_index(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_vif_addresses4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_vif_addresses6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_address_flags4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_address_flags6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_interface_enabled(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_interface_discard(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_mac(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_mtu(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_no_carrier(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_vif_enabled(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_prefix4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_broadcast4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_endpoint4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_prefix6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_endpoint6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_start_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_commit_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_abort_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_create_interface(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_delete_interface(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_configure_all_interfaces_from_system(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_configure_interface_from_system(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_interface_enabled(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_interface_discard(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_mac(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_restore_original_mac(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_mtu(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_restore_original_mtu(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_create_vif(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_delete_vif(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_vif_enabled(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_create_address4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_delete_address4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_address_enabled4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_address_enabled4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_prefix4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_broadcast4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_endpoint4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_create_address6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_delete_address6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_address_enabled6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_get_configured_address_enabled6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_prefix6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_0_1_set_endpoint6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_replicator_0_1_register_ifmgr_mirror(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_ifmgr_replicator_0_1_unregister_ifmgr_mirror(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_lookup_route_by_dest4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_lookup_route_by_dest6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_lookup_route_by_network4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_lookup_route_by_network6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_have_ipv4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_have_ipv6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_get_unicast_forwarding_enabled4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_get_unicast_forwarding_enabled6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_set_unicast_forwarding_enabled4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_set_unicast_forwarding_enabled6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_set_unicast_forwarding_table_id4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fti_0_2_set_unicast_forwarding_table_id6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction4_0_1_start_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction4_0_1_commit_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction4_0_1_abort_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction4_0_1_add_route(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction4_0_1_delete_route(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction4_0_1_delete_all_routes(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction6_0_1_start_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction6_0_1_commit_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction6_0_1_abort_transaction(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction6_0_1_add_route(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction6_0_1_delete_route(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_redist_transaction6_0_1_delete_all_routes(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_link_0_1_send(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_link_0_1_register_receiver(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_link_0_1_unregister_receiver(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_link_0_1_join_multicast_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_link_0_1_leave_multicast_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet4_0_1_send(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet4_0_1_register_receiver(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet4_0_1_unregister_receiver(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet4_0_1_join_multicast_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet4_0_1_leave_multicast_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet6_0_1_send(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet6_0_1_register_receiver(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet6_0_1_unregister_receiver(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet6_0_1_join_multicast_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_raw_packet6_0_1_leave_multicast_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_tcp_open(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_udp_open(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_tcp_open_and_bind(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_udp_open_and_bind(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_udp_open_bind_join(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_tcp_open_bind_connect(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_udp_open_bind_connect(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_bind(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_udp_join_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_udp_leave_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_close(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_tcp_listen(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_send(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_send_to(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_send_from_multicast_if(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket4_0_1_set_socket_option(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_tcp_open(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_udp_open(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_tcp_open_and_bind(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_udp_open_and_bind(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_udp_open_bind_join(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_tcp_open_bind_connect(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_udp_open_bind_connect(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_bind(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_udp_join_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_udp_leave_group(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_close(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_tcp_listen(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_send(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_send_to(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_send_from_multicast_if(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_socket6_0_1_set_socket_option(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_profile_0_1_enable(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_profile_0_1_disable(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_profile_0_1_get_entries(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_profile_0_1_clear(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_profile_0_1_list(const XrlArgs& in, XrlArgs* out);

    void add_handlers();
    void remove_handlers();
};

#endif // __XRL_TARGETS_FEA_BASE_HH__
