/*
 * Copyright (c) 2001-2003 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */

#ident "$XORP: xorp/xrl/targets/ospf_base.cc,v 1.9 2003/11/18 01:47:40 hodson Exp $"


#include "ospf_base.hh"


XrlOspfTargetBase::XrlOspfTargetBase(XrlCmdMap* cmds)
    : _cmds(cmds)
{
    if (_cmds)
	add_handlers();
}

XrlOspfTargetBase::~XrlOspfTargetBase()
{
    if (_cmds)
	remove_handlers();
}

bool
XrlOspfTargetBase::set_command_map(XrlCmdMap* cmds)
{
    if (_cmds == 0 && cmds) {
        _cmds = cmds;
        add_handlers();
        return true;
    }
    if (_cmds && cmds == 0) {
	remove_handlers();
        _cmds = cmds;
        return true;
    }
    return false;
}

const XrlCmdError
XrlOspfTargetBase::handle_common_0_1_get_target_name(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling common/0.1/get_target_name",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string name;
    try {
	XrlCmdError e = common_0_1_get_target_name(
	    name);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for common/0.1/get_target_name failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("name", name);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_common_0_1_get_version(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling common/0.1/get_version",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string version;
    try {
	XrlCmdError e = common_0_1_get_version(
	    version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for common/0.1/get_version failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("version", version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_common_0_1_get_status(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling common/0.1/get_status",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t status;
    string reason;
    try {
	XrlCmdError e = common_0_1_get_status(
	    status,
	    reason);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for common/0.1/get_status failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("status", status);
	pxa_outputs->add("reason", reason);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_common_0_1_shutdown(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling common/0.1/shutdown",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_shutdown();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for common/0.1/shutdown failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_router_id(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_router_id",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_router_id(
	    xa_inputs.get_uint32("id"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_router_id failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_router_id(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_router_id",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t id;
    try {
	XrlCmdError e = ospf_0_1_get_router_id(
	    id);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_router_id failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("id", id);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_lsdb_limit(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_lsdb_limit",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_lsdb_limit(
	    xa_inputs.get_int32("limit"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_lsdb_limit failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_lsdb_limit(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_lsdb_limit",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    int32_t limit;
    try {
	XrlCmdError e = ospf_0_1_get_lsdb_limit(
	    limit);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_lsdb_limit failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("limit", limit);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_mospf(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_mospf",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_mospf(
	    xa_inputs.get_bool("enabled"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_mospf failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_mospf(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_mospf",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = ospf_0_1_get_mospf(
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_mospf failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_interarea_mc(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_interarea_mc",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_interarea_mc(
	    xa_inputs.get_bool("enabled"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_interarea_mc failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_interarea_mc(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_interarea_mc",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = ospf_0_1_get_interarea_mc(
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_interarea_mc failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_overflow_interval(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_overflow_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_overflow_interval(
	    xa_inputs.get_int32("ovfl_int"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_overflow_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_overflow_interval(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_overflow_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    int32_t ovfl_int;
    try {
	XrlCmdError e = ospf_0_1_get_overflow_interval(
	    ovfl_int);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_overflow_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("ovfl_int", ovfl_int);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_flood_rate(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_flood_rate",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_flood_rate(
	    xa_inputs.get_int32("rate"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_flood_rate failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_flood_rate(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_flood_rate",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    int32_t rate;
    try {
	XrlCmdError e = ospf_0_1_get_flood_rate(
	    rate);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_flood_rate failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("rate", rate);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_max_rxmt_window(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_max_rxmt_window",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_max_rxmt_window(
	    xa_inputs.get_uint32("window"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_max_rxmt_window failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_max_rxmt_window(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_max_rxmt_window",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t window;
    try {
	XrlCmdError e = ospf_0_1_get_max_rxmt_window(
	    window);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_max_rxmt_window failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("window", window);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_max_dds(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_max_dds",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_max_dds(
	    xa_inputs.get_uint32("max_dds"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_max_dds failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_max_dds(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_max_dds",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t max_dds;
    try {
	XrlCmdError e = ospf_0_1_get_max_dds(
	    max_dds);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_max_dds failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("max_dds", max_dds);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_lsa_refresh_rate(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_lsa_refresh_rate",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_lsa_refresh_rate(
	    xa_inputs.get_uint32("rate"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_lsa_refresh_rate failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_lsa_refresh_rate(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_lsa_refresh_rate",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t rate;
    try {
	XrlCmdError e = ospf_0_1_get_lsa_refresh_rate(
	    rate);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_lsa_refresh_rate failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("rate", rate);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_p2p_adj_limit(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_p2p_adj_limit",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_p2p_adj_limit(
	    xa_inputs.get_uint32("max_adj"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_p2p_adj_limit failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_p2p_adj_limit(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_p2p_adj_limit",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t max_adj;
    try {
	XrlCmdError e = ospf_0_1_get_p2p_adj_limit(
	    max_adj);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_p2p_adj_limit failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("max_adj", max_adj);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_set_random_refresh(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/set_random_refresh",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_set_random_refresh(
	    xa_inputs.get_bool("enabled"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/set_random_refresh failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_random_refresh(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/get_random_refresh",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = ospf_0_1_get_random_refresh(
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_random_refresh failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_add_or_configure_area(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != 4) handling ospf/0.1/add_or_configure_area",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_add_or_configure_area(
	    xa_inputs.get_uint32("area_id"),
	    xa_inputs.get_bool("is_stub"),
	    xa_inputs.get_uint32("default_cost"),
	    xa_inputs.get_bool("import_summary_routes"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/add_or_configure_area failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_delete_area(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/delete_area",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_delete_area(
	    xa_inputs.get_uint32("area_id"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/delete_area failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_query_area(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/query_area",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool is_stub;
    uint32_t default_cost;
    bool import_summary_routes;
    try {
	XrlCmdError e = ospf_0_1_query_area(
	    xa_inputs.get_uint32("area_id"),
	    is_stub,
	    default_cost,
	    import_summary_routes);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/query_area failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("is_stub", is_stub);
	pxa_outputs->add("default_cost", default_cost);
	pxa_outputs->add("import_summary_routes", import_summary_routes);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_list_area_ids(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/list_area_ids",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList area_ids;
    try {
	XrlCmdError e = ospf_0_1_list_area_ids(
	    area_ids);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/list_area_ids failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("area_ids", area_ids);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_add_or_configure_aggregate(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != 4) handling ospf/0.1/add_or_configure_aggregate",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_add_or_configure_aggregate(
	    xa_inputs.get_uint32("area_id"),
	    xa_inputs.get_ipv4("network"),
	    xa_inputs.get_ipv4("netmask"),
	    xa_inputs.get_bool("suppress_advertisement"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/add_or_configure_aggregate failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_delete_aggregate(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/delete_aggregate",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_delete_aggregate(
	    xa_inputs.get_uint32("area_id"),
	    xa_inputs.get_ipv4("network"),
	    xa_inputs.get_ipv4("netmask"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/delete_aggregate failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_query_aggregate(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/query_aggregate",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool suppress_advertisement;
    try {
	XrlCmdError e = ospf_0_1_query_aggregate(
	    xa_inputs.get_uint32("area_id"),
	    xa_inputs.get_ipv4("network"),
	    xa_inputs.get_ipv4("netmask"),
	    suppress_advertisement);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/query_aggregate failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("suppress_advertisement", suppress_advertisement);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_list_aggregates(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/list_aggregates",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList networks;
    XrlAtomList netmasks;
    try {
	XrlCmdError e = ospf_0_1_list_aggregates(
	    xa_inputs.get_uint32("area_id"),
	    networks,
	    netmasks);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/list_aggregates failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("networks", networks);
	pxa_outputs->add("netmasks", netmasks);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_add_or_configure_host(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != 4) handling ospf/0.1/add_or_configure_host",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_add_or_configure_host(
	    xa_inputs.get_ipv4("network"),
	    xa_inputs.get_ipv4("netmask"),
	    xa_inputs.get_uint32("area_id"),
	    xa_inputs.get_uint32("cost"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/add_or_configure_host failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_delete_host(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/delete_host",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_delete_host(
	    xa_inputs.get_ipv4("network"),
	    xa_inputs.get_ipv4("netmask"),
	    xa_inputs.get_uint32("area_id"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/delete_host failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_query_host(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/query_host",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t cost;
    try {
	XrlCmdError e = ospf_0_1_query_host(
	    xa_inputs.get_ipv4("network"),
	    xa_inputs.get_ipv4("netmask"),
	    xa_inputs.get_uint32("area_id"),
	    cost);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/query_host failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("cost", cost);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_list_hosts(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/list_hosts",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList networks;
    XrlAtomList netmasks;
    try {
	XrlCmdError e = ospf_0_1_list_hosts(
	    xa_inputs.get_uint32("area_id"),
	    networks,
	    netmasks);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/list_hosts failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("networks", networks);
	pxa_outputs->add("netmasks", netmasks);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_add_vlink(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/add_vlink",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_add_vlink(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/add_vlink failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_delete_vlink(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/delete_vlink",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_delete_vlink(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/delete_vlink failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_set_transmit_delay(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/vlink_set_transmit_delay",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_vlink_set_transmit_delay(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    xa_inputs.get_uint32("delay_secs"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_set_transmit_delay failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_get_transmit_delay(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/vlink_get_transmit_delay",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t delay_secs;
    try {
	XrlCmdError e = ospf_0_1_vlink_get_transmit_delay(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    delay_secs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_get_transmit_delay failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("delay_secs", delay_secs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_set_retransmit_interval(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/vlink_set_retransmit_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_vlink_set_retransmit_interval(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    xa_inputs.get_uint32("interval_secs"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_set_retransmit_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_get_retransmit_interval(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/vlink_get_retransmit_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t interval_secs;
    try {
	XrlCmdError e = ospf_0_1_vlink_get_retransmit_interval(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    interval_secs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_get_retransmit_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval_secs", interval_secs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_set_hello_interval(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/vlink_set_hello_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_vlink_set_hello_interval(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    xa_inputs.get_uint32("interval_secs"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_set_hello_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_get_hello_interval(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/vlink_get_hello_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t interval_secs;
    try {
	XrlCmdError e = ospf_0_1_vlink_get_hello_interval(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    interval_secs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_get_hello_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval_secs", interval_secs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_set_router_dead_interval(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/vlink_set_router_dead_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_vlink_set_router_dead_interval(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    xa_inputs.get_uint32("interval_secs"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_set_router_dead_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_get_router_dead_interval(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/vlink_get_router_dead_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t interval_secs;
    try {
	XrlCmdError e = ospf_0_1_vlink_get_router_dead_interval(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    interval_secs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_get_router_dead_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval_secs", interval_secs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_set_authentication(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != 4) handling ospf/0.1/vlink_set_authentication",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_vlink_set_authentication(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    xa_inputs.get_string("type"),
	    xa_inputs.get_string("key"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_set_authentication failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_vlink_get_authentication(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/vlink_get_authentication",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string type;
    string key;
    try {
	XrlCmdError e = ospf_0_1_vlink_get_authentication(
	    xa_inputs.get_uint32("transit_area"),
	    xa_inputs.get_uint32("neighbor_id"),
	    type,
	    key);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/vlink_get_authentication failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("type", type);
	pxa_outputs->add("key", key);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_list_vlinks(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/list_vlinks",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList neighbor_ids;
    try {
	XrlCmdError e = ospf_0_1_list_vlinks(
	    xa_inputs.get_uint32("transit_id"),
	    neighbor_ids);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/list_vlinks failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("neighbor_ids", neighbor_ids);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_add_or_configure_external_route(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != 6) handling ospf/0.1/add_or_configure_external_route",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_add_or_configure_external_route(
	    xa_inputs.get_ipv4net("network"),
	    xa_inputs.get_ipv4("gateway"),
	    xa_inputs.get_uint32("type"),
	    xa_inputs.get_uint32("cost"),
	    xa_inputs.get_bool("multicast"),
	    xa_inputs.get_uint32("external_route_tag"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/add_or_configure_external_route failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_delete_external_route(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/delete_external_route",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_delete_external_route(
	    xa_inputs.get_ipv4net("network"),
	    xa_inputs.get_ipv4("gateway"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/delete_external_route failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_query_external_route(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/query_external_route",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t type;
    uint32_t cost;
    bool multicast;
    uint32_t external_route_tag;
    try {
	XrlCmdError e = ospf_0_1_query_external_route(
	    xa_inputs.get_ipv4net("network"),
	    xa_inputs.get_ipv4("gateway"),
	    type,
	    cost,
	    multicast,
	    external_route_tag);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/query_external_route failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("type", type);
	pxa_outputs->add("cost", cost);
	pxa_outputs->add("multicast", multicast);
	pxa_outputs->add("external_route_tag", external_route_tag);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_list_external_routes(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/list_external_routes",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList gateways;
    try {
	XrlCmdError e = ospf_0_1_list_external_routes(
	    xa_inputs.get_ipv4net("network"),
	    gateways);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/list_external_routes failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("gateways", gateways);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_add_interface(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 8) {
	XLOG_ERROR("Wrong number of arguments (%u != 8) handling ospf/0.1/add_interface",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_add_interface(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("if_index"),
	    xa_inputs.get_uint32("area_id"),
	    xa_inputs.get_uint32("cost"),
	    xa_inputs.get_uint32("mtu"),
	    xa_inputs.get_string("type"),
	    xa_inputs.get_bool("on_demand"),
	    xa_inputs.get_bool("passive"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/add_interface failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_if_index(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_if_index",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_if_index(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("index"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_if_index failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_if_index(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_if_index",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t index;
    try {
	XrlCmdError e = ospf_0_1_interface_get_if_index(
	    xa_inputs.get_string("identifier"),
	    index);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_if_index failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("index", index);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_area_id(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_area_id",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_area_id(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("area_id"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_area_id failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_area_id(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_area_id",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t area_id;
    try {
	XrlCmdError e = ospf_0_1_interface_get_area_id(
	    xa_inputs.get_string("identifier"),
	    area_id);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_area_id failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("area_id", area_id);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_cost(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_cost",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_cost(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("cost"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_cost failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_cost(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_cost",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t cost;
    try {
	XrlCmdError e = ospf_0_1_interface_get_cost(
	    xa_inputs.get_string("identifier"),
	    cost);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_cost failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("cost", cost);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_mtu(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_mtu",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_mtu(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("mtu"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_mtu failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_mtu(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_mtu",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t mtu;
    try {
	XrlCmdError e = ospf_0_1_interface_get_mtu(
	    xa_inputs.get_string("identifier"),
	    mtu);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_mtu failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("mtu", mtu);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_type(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_type",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_type(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_string("type"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_type failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_type(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_type",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string type;
    try {
	XrlCmdError e = ospf_0_1_interface_get_type(
	    xa_inputs.get_string("identifier"),
	    type);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_type failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("type", type);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_dr_priority(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_dr_priority",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_dr_priority(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("dr_priority"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_dr_priority failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_dr_priority(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_dr_priority",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t dr_priority;
    try {
	XrlCmdError e = ospf_0_1_interface_get_dr_priority(
	    xa_inputs.get_string("identifier"),
	    dr_priority);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_dr_priority failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("dr_priority", dr_priority);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_transit_delay(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_transit_delay",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_transit_delay(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("delay_secs"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_transit_delay failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_transit_delay(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_transit_delay",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t delay_secs;
    try {
	XrlCmdError e = ospf_0_1_interface_get_transit_delay(
	    xa_inputs.get_string("identifier"),
	    delay_secs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_transit_delay failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("delay_secs", delay_secs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_retransmit_interval(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_retransmit_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_retransmit_interval(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("interval_secs"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_retransmit_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_retransmit_interval(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_retransmit_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t interval_secs;
    try {
	XrlCmdError e = ospf_0_1_interface_get_retransmit_interval(
	    xa_inputs.get_string("identifier"),
	    interval_secs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_retransmit_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval_secs", interval_secs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_router_dead_interval(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_router_dead_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_router_dead_interval(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("interval_secs"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_router_dead_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_router_dead_interval(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_router_dead_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t interval_secs;
    try {
	XrlCmdError e = ospf_0_1_interface_get_router_dead_interval(
	    xa_inputs.get_string("identifier"),
	    interval_secs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_router_dead_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval_secs", interval_secs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_poll_interval(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_poll_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_poll_interval(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("interval_secs"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_poll_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_poll_interval(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_poll_interval",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t interval_secs;
    try {
	XrlCmdError e = ospf_0_1_interface_get_poll_interval(
	    xa_inputs.get_string("identifier"),
	    interval_secs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_poll_interval failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval_secs", interval_secs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_authentication(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3) handling ospf/0.1/interface_set_authentication",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_authentication(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_string("type"),
	    xa_inputs.get_string("key"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_authentication failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_authentication(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_authentication",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string type;
    string key;
    try {
	XrlCmdError e = ospf_0_1_interface_get_authentication(
	    xa_inputs.get_string("identifier"),
	    type,
	    key);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_authentication failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("type", type);
	pxa_outputs->add("key", key);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_multicast_forwarding(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_multicast_forwarding",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_multicast_forwarding(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_string("type"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_multicast_forwarding failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_multicast_forwarding(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_multicast_forwarding",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string type;
    try {
	XrlCmdError e = ospf_0_1_interface_get_multicast_forwarding(
	    xa_inputs.get_string("identifier"),
	    type);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_multicast_forwarding failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("type", type);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_on_demand(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_on_demand",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_on_demand(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_bool("on_demand"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_on_demand failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_on_demand(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_on_demand",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool on_demand;
    try {
	XrlCmdError e = ospf_0_1_interface_get_on_demand(
	    xa_inputs.get_string("identifier"),
	    on_demand);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_on_demand failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("on_demand", on_demand);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_passive(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_passive",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_passive(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_bool("passive"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_passive failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_passive(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_passive",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool passive;
    try {
	XrlCmdError e = ospf_0_1_interface_get_passive(
	    xa_inputs.get_string("identifier"),
	    passive);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_passive failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("passive", passive);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_set_igmp(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_set_igmp",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_set_igmp(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_bool("enabled"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_set_igmp failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_igmp(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_get_igmp",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = ospf_0_1_interface_get_igmp(
	    xa_inputs.get_string("identifier"),
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_igmp failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_delete_interface(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/delete_interface",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_delete_interface(
	    xa_inputs.get_string("identifier"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/delete_interface failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_list_interfaces(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/list_interfaces",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList identifiers;
    try {
	XrlCmdError e = ospf_0_1_list_interfaces(
	    identifiers);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/list_interfaces failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("identifiers", identifiers);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_add_md5_key(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 7) {
	XLOG_ERROR("Wrong number of arguments (%u != 7) handling ospf/0.1/interface_add_md5_key",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_add_md5_key(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("key_id"),
	    xa_inputs.get_string("md5key"),
	    xa_inputs.get_string("start_receive"),
	    xa_inputs.get_string("stop_receive"),
	    xa_inputs.get_string("start_transmit"),
	    xa_inputs.get_string("stop_transmit"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_add_md5_key failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_get_md5_key(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_get_md5_key",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string md5key;
    string start_receive;
    string stop_receive;
    string start_transmit;
    string stop_transmit;
    try {
	XrlCmdError e = ospf_0_1_interface_get_md5_key(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("key_id"),
	    md5key,
	    start_receive,
	    stop_receive,
	    start_transmit,
	    stop_transmit);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_get_md5_key failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("md5key", md5key);
	pxa_outputs->add("start_receive", start_receive);
	pxa_outputs->add("stop_receive", stop_receive);
	pxa_outputs->add("start_transmit", start_transmit);
	pxa_outputs->add("stop_transmit", stop_transmit);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_delete_md5_key(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/interface_delete_md5_key",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_interface_delete_md5_key(
	    xa_inputs.get_string("identifier"),
	    xa_inputs.get_uint32("key_id"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_delete_md5_key failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_interface_list_md5_keys(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/interface_list_md5_keys",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList key_ids;
    try {
	XrlCmdError e = ospf_0_1_interface_list_md5_keys(
	    xa_inputs.get_string("identifier"),
	    key_ids);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/interface_list_md5_keys failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("key_ids", key_ids);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_add_neighbor(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != 2) handling ospf/0.1/add_neighbor",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_add_neighbor(
	    xa_inputs.get_ipv4("nbr_addr"),
	    xa_inputs.get_bool("dr_eligible"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/add_neighbor failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_get_neighbor(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/get_neighbor",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool dr_eligible;
    try {
	XrlCmdError e = ospf_0_1_get_neighbor(
	    xa_inputs.get_ipv4("nbr_addr"),
	    dr_eligible);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/get_neighbor failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("dr_eligible", dr_eligible);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_delete_neighbor(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1) handling ospf/0.1/delete_neighbor",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ospf_0_1_delete_neighbor(
	    xa_inputs.get_ipv4("nbr_addr"));
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/delete_neighbor failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlOspfTargetBase::handle_ospf_0_1_list_neighbors(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0) handling ospf/0.1/list_neighbors",
            (uint32_t)xa_inputs.size());
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList nbr_addrs;
    try {
	XrlCmdError e = ospf_0_1_list_neighbors(
	    nbr_addrs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for ospf/0.1/list_neighbors failed: %s",
            		 e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::XrlAtomNotFound& e) {
	XLOG_ERROR("Argument not found");
	return XrlCmdError::BAD_ARGS();
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("nbr_addrs", nbr_addrs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

