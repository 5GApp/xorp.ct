/*
 * Copyright (c) 2001-2003 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 *
 * $XORP: xorp/xrl/targets/rib_base.hh,v 1.23 2004/04/10 07:45:14 pavlin Exp $
 */


#ifndef __XRL_INTERFACES_RIB_BASE_HH__
#define __XRL_INTERFACES_RIB_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlRibTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlRibTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlRibTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlRibTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    inline const string& name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    inline const char* version() const { return "rib/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable/start/stop RIB.
     */
    virtual XrlCmdError rib_0_1_enable_rib() = 0;

    virtual XrlCmdError rib_0_1_disable_rib() = 0;

    virtual XrlCmdError rib_0_1_start_rib() = 0;

    virtual XrlCmdError rib_0_1_stop_rib() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete/enable/disable a RIB client. Add/delete/enable/disable a RIB
     *  client for a given target name, address family, and unicast/multicast
     *  flags.
     *
     *  @param target_name the target name of the RIB client.
     *
     *  @param unicast true if a client for the unicast RIB.
     *
     *  @param multicast true if a client for the multicast RIB.
     */
    virtual XrlCmdError rib_0_1_add_rib_client4(
	// Input values,
	const string&	target_name,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_add_rib_client6(
	// Input values,
	const string&	target_name,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_delete_rib_client4(
	// Input values,
	const string&	target_name,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_delete_rib_client6(
	// Input values,
	const string&	target_name,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_enable_rib_client4(
	// Input values,
	const string&	target_name,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_enable_rib_client6(
	// Input values,
	const string&	target_name,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_disable_rib_client4(
	// Input values,
	const string&	target_name,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_disable_rib_client6(
	// Input values,
	const string&	target_name,
	const bool&	unicast,
	const bool&	multicast) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Don't send anything to the FEA - used for testing only
     */
    virtual XrlCmdError rib_0_1_no_fea() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Make errors fatal; used to detect errors we'd normally mask
     */
    virtual XrlCmdError rib_0_1_make_errors_fatal() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete an IGP or EGP table.
     *
     *  @param protocol the name of the protocol.
     *
     *  @param target_class the target class of the protocol.
     *
     *  @param target_instance the target instance of the protocol.
     *
     *  @param unicast true if the table is for the unicast RIB.
     *
     *  @param multicast true if the table is for the multicast RIB.
     */
    virtual XrlCmdError rib_0_1_add_igp_table4(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_add_igp_table6(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_delete_igp_table4(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_delete_igp_table6(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_add_egp_table4(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_add_egp_table6(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_delete_egp_table4(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;

    virtual XrlCmdError rib_0_1_delete_egp_table6(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/replace/delete a route.
     *
     *  @param protocol the name of the protocol this route comes from.
     *
     *  @param unicast true if the route is for the unicast RIB.
     *
     *  @param multicast true if the route is for the multicast RIB.
     *
     *  @param network the network address prefix of the route.
     *
     *  @param nexthop the address of the next-hop router toward the
     *  destination.
     *
     *  @param metric the routing metric.
     */
    virtual XrlCmdError rib_0_1_add_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const uint32_t&	metric) = 0;

    virtual XrlCmdError rib_0_1_add_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const uint32_t&	metric) = 0;

    virtual XrlCmdError rib_0_1_replace_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const uint32_t&	metric) = 0;

    virtual XrlCmdError rib_0_1_replace_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const uint32_t&	metric) = 0;

    virtual XrlCmdError rib_0_1_delete_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network) = 0;

    virtual XrlCmdError rib_0_1_delete_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/replace a route by explicitly specifying the network interface
     *  toward the destination.
     *
     *  @param protocol the name of the protocol this route comes from.
     *
     *  @param unicast true if the route is for the unicast RIB.
     *
     *  @param multicast true if the route is for the multicast RIB.
     *
     *  @param network the network address prefix of the route.
     *
     *  @param nexthop the address of the next-hop router toward the
     *  destination.
     *
     *  @param ifname of the name of the physical interface toward the
     *  destination.
     *
     *  @param vifname of the name of the virtual interface toward the
     *  destination.
     *
     *  @param metric the routing metric.
     */
    virtual XrlCmdError rib_0_1_add_interface_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric) = 0;

    virtual XrlCmdError rib_0_1_add_interface_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric) = 0;

    virtual XrlCmdError rib_0_1_replace_interface_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric) = 0;

    virtual XrlCmdError rib_0_1_replace_interface_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup nexthop.
     *
     *  @param addr address to lookup.
     *
     *  @param unicast look in unicast RIB.
     *
     *  @param multicast look in multicast RIB.
     *
     *  @param nexthop contains the resolved nexthop if successful, IPv4::ZERO
     *  otherwise. It is an error for the unicast and multicast fields to both
     *  be true or both false.
     */
    virtual XrlCmdError rib_0_1_lookup_route4(
	// Input values,
	const IPv4&	addr,
	const bool&	unicast,
	const bool&	multicast,
	// Output values,
	IPv4&	nexthop) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup nexthop.
     *
     *  @param addr address to lookup.
     *
     *  @param unicast look in unicast RIB.
     *
     *  @param multicast look in multicast RIB.
     *
     *  @param nexthop contains the resolved nexthop if successful, IPv6::ZERO
     *  otherwise. It is an error for the unicast and multicast fields to both
     *  be true or both false.
     */
    virtual XrlCmdError rib_0_1_lookup_route6(
	// Input values,
	const IPv6&	addr,
	const bool&	unicast,
	const bool&	multicast,
	// Output values,
	IPv6&	nexthop) = 0;

    virtual XrlCmdError rib_0_1_new_vif(
	// Input values,
	const string&	name) = 0;

    virtual XrlCmdError rib_0_1_add_vif_addr4(
	// Input values,
	const string&	name,
	const IPv4&	addr,
	const IPv4Net&	subnet) = 0;

    virtual XrlCmdError rib_0_1_add_vif_addr6(
	// Input values,
	const string&	name,
	const IPv6&	addr,
	const IPv6Net&	subnet) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable route redistribution from one routing protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist4/0.1.
     *
     *  @param from_protocol the name of the routing process routes are to be
     *  redistributed from.
     *
     *  @param unicast enable for unicast RIBs matching from and to.
     *
     *  @param multicast enable for multicast RIBs matching from and to.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through it redist_client/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_enable4(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable route redistribution from one routing protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist6/0.1.
     *
     *  @param from_protocol the name of the routing process routes are to be
     *  redistributed from.
     *
     *  @param unicast enable for unicast RIBs matching from and to.
     *
     *  @param multicast enable for multicast RIBs matching from and to.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through it redist_client/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_enable6(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable route redistribution from one routing protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist4/0.1 and previously called redist_enable4.
     *
     *  @param unicast disable for unicast RIBs matching from and to.
     *
     *  @param multicast disable for multicast RIBs matching from and to.
     */
    virtual XrlCmdError rib_0_1_redist_disable4(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable route redistribution from one routing protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist6/0.1 and previously called redist_enable6.
     *
     *  @param unicast disable for unicast RIBs matching from and to.
     *
     *  @param multicast disable for multicast RIBs matching from and to.
     */
    virtual XrlCmdError rib_0_1_redist_disable6(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register an interest in a route
     *
     *  @param target the name of the XRL module to notify when the information
     *  returned by this call becomes invalid.
     *
     *  @param addr address of interest
     *
     *  @param resolves returns whether or not the address resolves to a route
     *  that can be used for forwarding.
     *
     *  @param base_addr returns the address of interest (actually the base
     *  address of the subnet covered by addr/prefix_len).
     *
     *  @param prefix_len returns the prefix length that the registration
     *  covers. This response applies to all addresses in addr/prefix_len.
     *
     *  @param real_prefix_len returns the actual prefix length of the route
     *  that will be used to route addr. If real_prefix_len is not the same as
     *  prefix_len, this is because there are some more specific routes that
     *  overlap addr/real_prefix_len. real_prefix_len is primarily given for
     *  debugging reasons.
     *
     *  @param nexthop returns the address of the next hop for packets sent to
     *  addr
     *
     *  @param metric returns the IGP metric for this route
     */
    virtual XrlCmdError rib_0_1_register_interest4(
	// Input values,
	const string&	target,
	const IPv4&	addr,
	// Output values,
	bool&	resolves,
	IPv4&	base_addr,
	uint32_t&	prefix_len,
	uint32_t&	real_prefix_len,
	IPv4&	nexthop,
	uint32_t&	metric) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  De-register an interest in a route
     *
     *  @param target the name of the XRL module that registered the interest
     *
     *  @param addr the address of the previous registered interest. addr
     *  should be the base address of the add/prefix_len subnet.
     *
     *  @param prefix_len the prefix length of the registered interest, as
     *  given in the response from register_interest.
     */
    virtual XrlCmdError rib_0_1_deregister_interest4(
	// Input values,
	const string&	target,
	const IPv4&	addr,
	const uint32_t&	prefix_len) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register an interest in a route
     *
     *  @param target the name of the XRL module to notify when the information
     *  returned by this call becomes invalid.
     *
     *  @param addr address of interest
     *
     *  @param resolves returns whether or not the address resolves to a route
     *  that can be used for forwarding.
     *
     *  @param base_addr returns the address of interest (actually the base
     *  address of the subnet covered by addr/prefix_len).
     *
     *  @param prefix_len returns the prefix length that the registration
     *  covers. This response applies to all addresses in addr/prefix_len.
     *
     *  @param real_prefix_len returns the actual prefix length of the route
     *  that will be used to route addr. If real_prefix_len is not the same as
     *  prefix_len, this is because there are some more specific routes that
     *  overlap addr/real_prefix_len. real_prefix_len is primarily given for
     *  debugging reasons.
     *
     *  @param nexthop returns the address of the next hop for packets sent to
     *  addr
     *
     *  @param metric returns the IGP metric for this route
     */
    virtual XrlCmdError rib_0_1_register_interest6(
	// Input values,
	const string&	target,
	const IPv6&	addr,
	// Output values,
	bool&	resolves,
	IPv6&	base_addr,
	uint32_t&	prefix_len,
	uint32_t&	real_prefix_len,
	IPv6&	nexthop,
	uint32_t&	metric) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  De-register an interest in a route
     *
     *  @param target the name of the XRL module that registered the interest
     *
     *  @param addr the address of the previous registered interest. addr
     *  should be the base address of the add/prefix_len subnet.
     *
     *  @param prefix_len the prefix length of the registered interest, as
     *  given in the response from register_interest.
     */
    virtual XrlCmdError rib_0_1_deregister_interest6(
	// Input values,
	const string&	target,
	const IPv6&	addr,
	const uint32_t&	prefix_len) = 0;

    virtual XrlCmdError fea_ifmgr_client_0_1_interface_update(
	// Input values,
	const string&	ifname,
	const uint32_t&	event) = 0;

    virtual XrlCmdError fea_ifmgr_client_0_1_vif_update(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	event) = 0;

    virtual XrlCmdError fea_ifmgr_client_0_1_vifaddr4_update(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	event) = 0;

    virtual XrlCmdError fea_ifmgr_client_0_1_vifaddr6_update(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	event) = 0;

    virtual XrlCmdError fea_ifmgr_client_0_1_updates_completed() = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;

private:
    const XrlCmdError handle_common_0_1_get_target_name(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_common_0_1_get_version(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_common_0_1_get_status(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_common_0_1_shutdown(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_enable_rib(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_disable_rib(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_start_rib(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_stop_rib(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_rib_client4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_rib_client6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_delete_rib_client4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_delete_rib_client6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_enable_rib_client4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_enable_rib_client6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_disable_rib_client4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_disable_rib_client6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_no_fea(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_make_errors_fatal(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_igp_table4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_igp_table6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_delete_igp_table4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_delete_igp_table6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_egp_table4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_egp_table6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_delete_egp_table4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_delete_egp_table6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_route4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_route6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_replace_route4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_replace_route6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_delete_route4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_delete_route6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_interface_route4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_interface_route6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_replace_interface_route4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_replace_interface_route6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_lookup_route4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_lookup_route6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_new_vif(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_vif_addr4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_add_vif_addr6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_redist_enable4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_redist_enable6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_redist_disable4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_redist_disable6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_register_interest4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_deregister_interest4(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_register_interest6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_rib_0_1_deregister_interest6(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_ifmgr_client_0_1_interface_update(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_ifmgr_client_0_1_vif_update(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_ifmgr_client_0_1_vifaddr4_update(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_ifmgr_client_0_1_vifaddr6_update(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_fea_ifmgr_client_0_1_updates_completed(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlArgs* out);

    const XrlCmdError handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlArgs* out);

    void add_handlers()
    {
	if (_cmds->add_handler("common/0.1/get_target_name",
	    callback(this, &XrlRibTargetBase::handle_common_0_1_get_target_name)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/common/0.1/get_target_name");
	}
	if (_cmds->add_handler("common/0.1/get_version",
	    callback(this, &XrlRibTargetBase::handle_common_0_1_get_version)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/common/0.1/get_version");
	}
	if (_cmds->add_handler("common/0.1/get_status",
	    callback(this, &XrlRibTargetBase::handle_common_0_1_get_status)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/common/0.1/get_status");
	}
	if (_cmds->add_handler("common/0.1/shutdown",
	    callback(this, &XrlRibTargetBase::handle_common_0_1_shutdown)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/common/0.1/shutdown");
	}
	if (_cmds->add_handler("rib/0.1/enable_rib",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_enable_rib)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/enable_rib");
	}
	if (_cmds->add_handler("rib/0.1/disable_rib",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_disable_rib)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/disable_rib");
	}
	if (_cmds->add_handler("rib/0.1/start_rib",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_start_rib)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/start_rib");
	}
	if (_cmds->add_handler("rib/0.1/stop_rib",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_stop_rib)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/stop_rib");
	}
	if (_cmds->add_handler("rib/0.1/add_rib_client4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_rib_client4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_rib_client4");
	}
	if (_cmds->add_handler("rib/0.1/add_rib_client6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_rib_client6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_rib_client6");
	}
	if (_cmds->add_handler("rib/0.1/delete_rib_client4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_delete_rib_client4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/delete_rib_client4");
	}
	if (_cmds->add_handler("rib/0.1/delete_rib_client6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_delete_rib_client6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/delete_rib_client6");
	}
	if (_cmds->add_handler("rib/0.1/enable_rib_client4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_enable_rib_client4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/enable_rib_client4");
	}
	if (_cmds->add_handler("rib/0.1/enable_rib_client6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_enable_rib_client6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/enable_rib_client6");
	}
	if (_cmds->add_handler("rib/0.1/disable_rib_client4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_disable_rib_client4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/disable_rib_client4");
	}
	if (_cmds->add_handler("rib/0.1/disable_rib_client6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_disable_rib_client6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/disable_rib_client6");
	}
	if (_cmds->add_handler("rib/0.1/no_fea",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_no_fea)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/no_fea");
	}
	if (_cmds->add_handler("rib/0.1/make_errors_fatal",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_make_errors_fatal)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/make_errors_fatal");
	}
	if (_cmds->add_handler("rib/0.1/add_igp_table4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_igp_table4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_igp_table4");
	}
	if (_cmds->add_handler("rib/0.1/add_igp_table6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_igp_table6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_igp_table6");
	}
	if (_cmds->add_handler("rib/0.1/delete_igp_table4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_delete_igp_table4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/delete_igp_table4");
	}
	if (_cmds->add_handler("rib/0.1/delete_igp_table6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_delete_igp_table6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/delete_igp_table6");
	}
	if (_cmds->add_handler("rib/0.1/add_egp_table4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_egp_table4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_egp_table4");
	}
	if (_cmds->add_handler("rib/0.1/add_egp_table6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_egp_table6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_egp_table6");
	}
	if (_cmds->add_handler("rib/0.1/delete_egp_table4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_delete_egp_table4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/delete_egp_table4");
	}
	if (_cmds->add_handler("rib/0.1/delete_egp_table6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_delete_egp_table6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/delete_egp_table6");
	}
	if (_cmds->add_handler("rib/0.1/add_route4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_route4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_route4");
	}
	if (_cmds->add_handler("rib/0.1/add_route6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_route6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_route6");
	}
	if (_cmds->add_handler("rib/0.1/replace_route4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_replace_route4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/replace_route4");
	}
	if (_cmds->add_handler("rib/0.1/replace_route6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_replace_route6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/replace_route6");
	}
	if (_cmds->add_handler("rib/0.1/delete_route4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_delete_route4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/delete_route4");
	}
	if (_cmds->add_handler("rib/0.1/delete_route6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_delete_route6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/delete_route6");
	}
	if (_cmds->add_handler("rib/0.1/add_interface_route4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_interface_route4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_interface_route4");
	}
	if (_cmds->add_handler("rib/0.1/add_interface_route6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_interface_route6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_interface_route6");
	}
	if (_cmds->add_handler("rib/0.1/replace_interface_route4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_replace_interface_route4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/replace_interface_route4");
	}
	if (_cmds->add_handler("rib/0.1/replace_interface_route6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_replace_interface_route6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/replace_interface_route6");
	}
	if (_cmds->add_handler("rib/0.1/lookup_route4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_lookup_route4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/lookup_route4");
	}
	if (_cmds->add_handler("rib/0.1/lookup_route6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_lookup_route6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/lookup_route6");
	}
	if (_cmds->add_handler("rib/0.1/new_vif",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_new_vif)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/new_vif");
	}
	if (_cmds->add_handler("rib/0.1/add_vif_addr4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_vif_addr4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_vif_addr4");
	}
	if (_cmds->add_handler("rib/0.1/add_vif_addr6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_add_vif_addr6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/add_vif_addr6");
	}
	if (_cmds->add_handler("rib/0.1/redist_enable4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_redist_enable4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/redist_enable4");
	}
	if (_cmds->add_handler("rib/0.1/redist_enable6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_redist_enable6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/redist_enable6");
	}
	if (_cmds->add_handler("rib/0.1/redist_disable4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_redist_disable4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/redist_disable4");
	}
	if (_cmds->add_handler("rib/0.1/redist_disable6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_redist_disable6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/redist_disable6");
	}
	if (_cmds->add_handler("rib/0.1/register_interest4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_register_interest4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/register_interest4");
	}
	if (_cmds->add_handler("rib/0.1/deregister_interest4",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_deregister_interest4)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/deregister_interest4");
	}
	if (_cmds->add_handler("rib/0.1/register_interest6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_register_interest6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/register_interest6");
	}
	if (_cmds->add_handler("rib/0.1/deregister_interest6",
	    callback(this, &XrlRibTargetBase::handle_rib_0_1_deregister_interest6)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/rib/0.1/deregister_interest6");
	}
	if (_cmds->add_handler("fea_ifmgr_client/0.1/interface_update",
	    callback(this, &XrlRibTargetBase::handle_fea_ifmgr_client_0_1_interface_update)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/fea_ifmgr_client/0.1/interface_update");
	}
	if (_cmds->add_handler("fea_ifmgr_client/0.1/vif_update",
	    callback(this, &XrlRibTargetBase::handle_fea_ifmgr_client_0_1_vif_update)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/fea_ifmgr_client/0.1/vif_update");
	}
	if (_cmds->add_handler("fea_ifmgr_client/0.1/vifaddr4_update",
	    callback(this, &XrlRibTargetBase::handle_fea_ifmgr_client_0_1_vifaddr4_update)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/fea_ifmgr_client/0.1/vifaddr4_update");
	}
	if (_cmds->add_handler("fea_ifmgr_client/0.1/vifaddr6_update",
	    callback(this, &XrlRibTargetBase::handle_fea_ifmgr_client_0_1_vifaddr6_update)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/fea_ifmgr_client/0.1/vifaddr6_update");
	}
	if (_cmds->add_handler("fea_ifmgr_client/0.1/updates_completed",
	    callback(this, &XrlRibTargetBase::handle_fea_ifmgr_client_0_1_updates_completed)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/fea_ifmgr_client/0.1/updates_completed");
	}
	if (_cmds->add_handler("finder_event_observer/0.1/xrl_target_birth",
	    callback(this, &XrlRibTargetBase::handle_finder_event_observer_0_1_xrl_target_birth)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/finder_event_observer/0.1/xrl_target_birth");
	}
	if (_cmds->add_handler("finder_event_observer/0.1/xrl_target_death",
	    callback(this, &XrlRibTargetBase::handle_finder_event_observer_0_1_xrl_target_death)) == false) {
	    XLOG_ERROR("Failed to xrl handler finder://rib/finder_event_observer/0.1/xrl_target_death");
	}
	_cmds->finalize();
    }

    void remove_handlers()
    {
	_cmds->remove_handler("common/0.1/get_target_name");
	_cmds->remove_handler("common/0.1/get_version");
	_cmds->remove_handler("common/0.1/get_status");
	_cmds->remove_handler("common/0.1/shutdown");
	_cmds->remove_handler("rib/0.1/enable_rib");
	_cmds->remove_handler("rib/0.1/disable_rib");
	_cmds->remove_handler("rib/0.1/start_rib");
	_cmds->remove_handler("rib/0.1/stop_rib");
	_cmds->remove_handler("rib/0.1/add_rib_client4");
	_cmds->remove_handler("rib/0.1/add_rib_client6");
	_cmds->remove_handler("rib/0.1/delete_rib_client4");
	_cmds->remove_handler("rib/0.1/delete_rib_client6");
	_cmds->remove_handler("rib/0.1/enable_rib_client4");
	_cmds->remove_handler("rib/0.1/enable_rib_client6");
	_cmds->remove_handler("rib/0.1/disable_rib_client4");
	_cmds->remove_handler("rib/0.1/disable_rib_client6");
	_cmds->remove_handler("rib/0.1/no_fea");
	_cmds->remove_handler("rib/0.1/make_errors_fatal");
	_cmds->remove_handler("rib/0.1/add_igp_table4");
	_cmds->remove_handler("rib/0.1/add_igp_table6");
	_cmds->remove_handler("rib/0.1/delete_igp_table4");
	_cmds->remove_handler("rib/0.1/delete_igp_table6");
	_cmds->remove_handler("rib/0.1/add_egp_table4");
	_cmds->remove_handler("rib/0.1/add_egp_table6");
	_cmds->remove_handler("rib/0.1/delete_egp_table4");
	_cmds->remove_handler("rib/0.1/delete_egp_table6");
	_cmds->remove_handler("rib/0.1/add_route4");
	_cmds->remove_handler("rib/0.1/add_route6");
	_cmds->remove_handler("rib/0.1/replace_route4");
	_cmds->remove_handler("rib/0.1/replace_route6");
	_cmds->remove_handler("rib/0.1/delete_route4");
	_cmds->remove_handler("rib/0.1/delete_route6");
	_cmds->remove_handler("rib/0.1/add_interface_route4");
	_cmds->remove_handler("rib/0.1/add_interface_route6");
	_cmds->remove_handler("rib/0.1/replace_interface_route4");
	_cmds->remove_handler("rib/0.1/replace_interface_route6");
	_cmds->remove_handler("rib/0.1/lookup_route4");
	_cmds->remove_handler("rib/0.1/lookup_route6");
	_cmds->remove_handler("rib/0.1/new_vif");
	_cmds->remove_handler("rib/0.1/add_vif_addr4");
	_cmds->remove_handler("rib/0.1/add_vif_addr6");
	_cmds->remove_handler("rib/0.1/redist_enable4");
	_cmds->remove_handler("rib/0.1/redist_enable6");
	_cmds->remove_handler("rib/0.1/redist_disable4");
	_cmds->remove_handler("rib/0.1/redist_disable6");
	_cmds->remove_handler("rib/0.1/register_interest4");
	_cmds->remove_handler("rib/0.1/deregister_interest4");
	_cmds->remove_handler("rib/0.1/register_interest6");
	_cmds->remove_handler("rib/0.1/deregister_interest6");
	_cmds->remove_handler("fea_ifmgr_client/0.1/interface_update");
	_cmds->remove_handler("fea_ifmgr_client/0.1/vif_update");
	_cmds->remove_handler("fea_ifmgr_client/0.1/vifaddr4_update");
	_cmds->remove_handler("fea_ifmgr_client/0.1/vifaddr6_update");
	_cmds->remove_handler("fea_ifmgr_client/0.1/updates_completed");
	_cmds->remove_handler("finder_event_observer/0.1/xrl_target_birth");
	_cmds->remove_handler("finder_event_observer/0.1/xrl_target_death");
    }
};

#endif /* __XRL_INTERFACES_RIB_BASE_HH__ */
