/*
 * Copyright (c) 2001-2009 XORP, Inc.
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */

#ident "$XORP: xorp/xrl/targets/fea_base.cc,v 1.95 2009/01/05 18:31:15 jtc Exp $"


#include "fea_base.hh"


const struct XrlFeaTargetBase::handler_table XrlFeaTargetBase::handlers[] = {
    { "common/0.1/get_target_name",
      &XrlFeaTargetBase::handle_common_0_1_get_target_name },
    { "common/0.1/get_version",
      &XrlFeaTargetBase::handle_common_0_1_get_version },
    { "common/0.1/get_status",
      &XrlFeaTargetBase::handle_common_0_1_get_status },
    { "common/0.1/shutdown",
      &XrlFeaTargetBase::handle_common_0_1_shutdown },
    { "finder_event_observer/0.1/xrl_target_birth",
      &XrlFeaTargetBase::handle_finder_event_observer_0_1_xrl_target_birth },
    { "finder_event_observer/0.1/xrl_target_death",
      &XrlFeaTargetBase::handle_finder_event_observer_0_1_xrl_target_death },
    { "fea_click/0.1/load_click",
      &XrlFeaTargetBase::handle_fea_click_0_1_load_click },
    { "fea_click/0.1/unload_click",
      &XrlFeaTargetBase::handle_fea_click_0_1_unload_click },
    { "fea_click/0.1/enable_click",
      &XrlFeaTargetBase::handle_fea_click_0_1_enable_click },
    { "fea_click/0.1/start_click",
      &XrlFeaTargetBase::handle_fea_click_0_1_start_click },
    { "fea_click/0.1/stop_click",
      &XrlFeaTargetBase::handle_fea_click_0_1_stop_click },
    { "fea_click/0.1/enable_duplicate_routes_to_kernel",
      &XrlFeaTargetBase::handle_fea_click_0_1_enable_duplicate_routes_to_kernel },
    { "fea_click/0.1/enable_kernel_click",
      &XrlFeaTargetBase::handle_fea_click_0_1_enable_kernel_click },
    { "fea_click/0.1/enable_kernel_click_install_on_startup",
      &XrlFeaTargetBase::handle_fea_click_0_1_enable_kernel_click_install_on_startup },
    { "fea_click/0.1/set_kernel_click_modules",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_kernel_click_modules },
    { "fea_click/0.1/set_kernel_click_mount_directory",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_kernel_click_mount_directory },
    { "fea_click/0.1/set_kernel_click_config_generator_file",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_kernel_click_config_generator_file },
    { "fea_click/0.1/enable_user_click",
      &XrlFeaTargetBase::handle_fea_click_0_1_enable_user_click },
    { "fea_click/0.1/set_user_click_command_file",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_command_file },
    { "fea_click/0.1/set_user_click_command_extra_arguments",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_command_extra_arguments },
    { "fea_click/0.1/set_user_click_command_execute_on_startup",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_command_execute_on_startup },
    { "fea_click/0.1/set_user_click_control_address",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_control_address },
    { "fea_click/0.1/set_user_click_control_socket_port",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_control_socket_port },
    { "fea_click/0.1/set_user_click_startup_config_file",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_startup_config_file },
    { "fea_click/0.1/set_user_click_config_generator_file",
      &XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_config_generator_file },
    { "fea_fib/0.1/add_fib_client4",
      &XrlFeaTargetBase::handle_fea_fib_0_1_add_fib_client4 },
    { "fea_fib/0.1/add_fib_client6",
      &XrlFeaTargetBase::handle_fea_fib_0_1_add_fib_client6 },
    { "fea_fib/0.1/delete_fib_client4",
      &XrlFeaTargetBase::handle_fea_fib_0_1_delete_fib_client4 },
    { "fea_fib/0.1/delete_fib_client6",
      &XrlFeaTargetBase::handle_fea_fib_0_1_delete_fib_client6 },
    { "fea_firewall/0.1/start_transaction",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_start_transaction },
    { "fea_firewall/0.1/commit_transaction",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_commit_transaction },
    { "fea_firewall/0.1/abort_transaction",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_abort_transaction },
    { "fea_firewall/0.1/add_entry4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_add_entry4 },
    { "fea_firewall/0.1/replace_entry4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_replace_entry4 },
    { "fea_firewall/0.1/delete_entry4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_delete_entry4 },
    { "fea_firewall/0.1/delete_all_entries4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_delete_all_entries4 },
    { "fea_firewall/0.1/get_entry_list_start4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_start4 },
    { "fea_firewall/0.1/get_entry_list_next4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_next4 },
    { "fea_firewall/0.1/add_entry6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_add_entry6 },
    { "fea_firewall/0.1/replace_entry6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_replace_entry6 },
    { "fea_firewall/0.1/delete_entry6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_delete_entry6 },
    { "fea_firewall/0.1/delete_all_entries6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_delete_all_entries6 },
    { "fea_firewall/0.1/get_entry_list_start6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_start6 },
    { "fea_firewall/0.1/get_entry_list_next6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_next6 },
    { "ifmgr/0.1/set_restore_original_config_on_shutdown",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_restore_original_config_on_shutdown },
    { "ifmgr/0.1/get_configured_interface_names",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_names },
    { "ifmgr/0.1/get_configured_vif_names",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_names },
    { "ifmgr/0.1/get_configured_vif_flags",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_flags },
    { "ifmgr/0.1/get_configured_vif_pif_index",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_pif_index },
    { "ifmgr/0.1/get_configured_vif_addresses4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_addresses4 },
    { "ifmgr/0.1/get_configured_vif_addresses6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_addresses6 },
    { "ifmgr/0.1/get_configured_address_flags4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_flags4 },
    { "ifmgr/0.1/get_configured_address_flags6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_flags6 },
    { "ifmgr/0.1/get_configured_interface_enabled",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_enabled },
    { "ifmgr/0.1/get_configured_interface_discard",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_discard },
    { "ifmgr/0.1/get_configured_interface_unreachable",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_unreachable },
    { "ifmgr/0.1/get_configured_interface_management",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_management },
    { "ifmgr/0.1/get_configured_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_mac },
    { "ifmgr/0.1/get_configured_mtu",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_mtu },
    { "ifmgr/0.1/get_configured_no_carrier",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_no_carrier },
    { "ifmgr/0.1/get_configured_baudrate",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_baudrate },
    { "ifmgr/0.1/get_configured_vif_enabled",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_enabled },
    { "ifmgr/0.1/get_configured_prefix4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_prefix4 },
    { "ifmgr/0.1/get_configured_broadcast4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_broadcast4 },
    { "ifmgr/0.1/get_configured_endpoint4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_endpoint4 },
    { "ifmgr/0.1/get_configured_prefix6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_prefix6 },
    { "ifmgr/0.1/get_configured_endpoint6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_endpoint6 },
    { "ifmgr/0.1/start_transaction",
      &XrlFeaTargetBase::handle_ifmgr_0_1_start_transaction },
    { "ifmgr/0.1/commit_transaction",
      &XrlFeaTargetBase::handle_ifmgr_0_1_commit_transaction },
    { "ifmgr/0.1/abort_transaction",
      &XrlFeaTargetBase::handle_ifmgr_0_1_abort_transaction },
    { "ifmgr/0.1/create_interface",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_interface },
    { "ifmgr/0.1/delete_interface",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_interface },
    { "ifmgr/0.1/configure_all_interfaces_from_system",
      &XrlFeaTargetBase::handle_ifmgr_0_1_configure_all_interfaces_from_system },
    { "ifmgr/0.1/configure_interface_from_system",
      &XrlFeaTargetBase::handle_ifmgr_0_1_configure_interface_from_system },
    { "ifmgr/0.1/set_interface_enabled",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_enabled },
    { "ifmgr/0.1/set_interface_discard",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_discard },
    { "ifmgr/0.1/set_interface_unreachable",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_unreachable },
    { "ifmgr/0.1/set_interface_management",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_management },
    { "ifmgr/0.1/set_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_mac },
    { "ifmgr/0.1/create_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_mac },
    { "ifmgr/0.1/delete_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_mac },
    { "ifmgr/0.1/restore_original_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_restore_original_mac },
    { "ifmgr/0.1/set_mtu",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_mtu },
    { "ifmgr/0.1/restore_original_mtu",
      &XrlFeaTargetBase::handle_ifmgr_0_1_restore_original_mtu },
    { "ifmgr/0.1/create_vif",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_vif },
    { "ifmgr/0.1/delete_vif",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_vif },
    { "ifmgr/0.1/set_vif_enabled",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_vif_enabled },
    { "ifmgr/0.1/set_vif_vlan",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_vif_vlan },
    { "ifmgr/0.1/create_address4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_address4 },
    { "ifmgr/0.1/delete_address4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_address4 },
    { "ifmgr/0.1/set_address_enabled4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_address_enabled4 },
    { "ifmgr/0.1/get_configured_address_enabled4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_enabled4 },
    { "ifmgr/0.1/set_prefix4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_prefix4 },
    { "ifmgr/0.1/set_broadcast4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_broadcast4 },
    { "ifmgr/0.1/set_endpoint4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_endpoint4 },
    { "ifmgr/0.1/create_address6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_address6 },
    { "ifmgr/0.1/delete_address6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_address6 },
    { "ifmgr/0.1/set_address_enabled6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_address_enabled6 },
    { "ifmgr/0.1/get_configured_address_enabled6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_enabled6 },
    { "ifmgr/0.1/set_prefix6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_prefix6 },
    { "ifmgr/0.1/set_endpoint6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_endpoint6 },
    { "ifmgr_replicator/0.1/register_ifmgr_mirror",
      &XrlFeaTargetBase::handle_ifmgr_replicator_0_1_register_ifmgr_mirror },
    { "ifmgr_replicator/0.1/unregister_ifmgr_mirror",
      &XrlFeaTargetBase::handle_ifmgr_replicator_0_1_unregister_ifmgr_mirror },
    { "fti/0.2/lookup_route_by_dest4",
      &XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_dest4 },
    { "fti/0.2/lookup_route_by_dest6",
      &XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_dest6 },
    { "fti/0.2/lookup_route_by_network4",
      &XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_network4 },
    { "fti/0.2/lookup_route_by_network6",
      &XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_network6 },
    { "fti/0.2/have_ipv4",
      &XrlFeaTargetBase::handle_fti_0_2_have_ipv4 },
    { "fti/0.2/have_ipv6",
      &XrlFeaTargetBase::handle_fti_0_2_have_ipv6 },
    { "fti/0.2/get_unicast_forwarding_enabled4",
      &XrlFeaTargetBase::handle_fti_0_2_get_unicast_forwarding_enabled4 },
    { "fti/0.2/get_unicast_forwarding_enabled6",
      &XrlFeaTargetBase::handle_fti_0_2_get_unicast_forwarding_enabled6 },
    { "fti/0.2/set_unicast_forwarding_enabled4",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_enabled4 },
    { "fti/0.2/set_unicast_forwarding_enabled6",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_enabled6 },
    { "fti/0.2/set_unicast_forwarding_entries_retain_on_startup4",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4 },
    { "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown4",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4 },
    { "fti/0.2/set_unicast_forwarding_entries_retain_on_startup6",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6 },
    { "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown6",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6 },
    { "fti/0.2/set_unicast_forwarding_table_id4",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_table_id4 },
    { "fti/0.2/set_unicast_forwarding_table_id6",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_table_id6 },
    { "redist_transaction4/0.1/start_transaction",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_start_transaction },
    { "redist_transaction4/0.1/commit_transaction",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_commit_transaction },
    { "redist_transaction4/0.1/abort_transaction",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_abort_transaction },
    { "redist_transaction4/0.1/add_route",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_add_route },
    { "redist_transaction4/0.1/delete_route",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_delete_route },
    { "redist_transaction4/0.1/delete_all_routes",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_delete_all_routes },
    { "redist_transaction6/0.1/start_transaction",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_start_transaction },
    { "redist_transaction6/0.1/commit_transaction",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_commit_transaction },
    { "redist_transaction6/0.1/abort_transaction",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_abort_transaction },
    { "redist_transaction6/0.1/add_route",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_add_route },
    { "redist_transaction6/0.1/delete_route",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_delete_route },
    { "redist_transaction6/0.1/delete_all_routes",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_delete_all_routes },
    { "raw_link/0.1/send",
      &XrlFeaTargetBase::handle_raw_link_0_1_send },
    { "raw_link/0.1/register_receiver",
      &XrlFeaTargetBase::handle_raw_link_0_1_register_receiver },
    { "raw_link/0.1/unregister_receiver",
      &XrlFeaTargetBase::handle_raw_link_0_1_unregister_receiver },
    { "raw_link/0.1/join_multicast_group",
      &XrlFeaTargetBase::handle_raw_link_0_1_join_multicast_group },
    { "raw_link/0.1/leave_multicast_group",
      &XrlFeaTargetBase::handle_raw_link_0_1_leave_multicast_group },
    { "raw_packet4/0.1/send",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_send },
    { "raw_packet4/0.1/register_receiver",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_register_receiver },
    { "raw_packet4/0.1/unregister_receiver",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_unregister_receiver },
    { "raw_packet4/0.1/join_multicast_group",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_join_multicast_group },
    { "raw_packet4/0.1/leave_multicast_group",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_leave_multicast_group },
    { "raw_packet6/0.1/send",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_send },
    { "raw_packet6/0.1/register_receiver",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_register_receiver },
    { "raw_packet6/0.1/unregister_receiver",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_unregister_receiver },
    { "raw_packet6/0.1/join_multicast_group",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_join_multicast_group },
    { "raw_packet6/0.1/leave_multicast_group",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_leave_multicast_group },
    { "socket4/0.1/tcp_open",
      &XrlFeaTargetBase::handle_socket4_0_1_tcp_open },
    { "socket4/0.1/udp_open",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open },
    { "socket4/0.1/tcp_open_and_bind",
      &XrlFeaTargetBase::handle_socket4_0_1_tcp_open_and_bind },
    { "socket4/0.1/udp_open_and_bind",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open_and_bind },
    { "socket4/0.1/udp_open_bind_join",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_join },
    { "socket4/0.1/tcp_open_bind_connect",
      &XrlFeaTargetBase::handle_socket4_0_1_tcp_open_bind_connect },
    { "socket4/0.1/udp_open_bind_connect",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_connect },
    { "socket4/0.1/udp_open_bind_broadcast",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_broadcast },
    { "socket4/0.1/bind",
      &XrlFeaTargetBase::handle_socket4_0_1_bind },
    { "socket4/0.1/udp_join_group",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_join_group },
    { "socket4/0.1/udp_leave_group",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_leave_group },
    { "socket4/0.1/close",
      &XrlFeaTargetBase::handle_socket4_0_1_close },
    { "socket4/0.1/tcp_listen",
      &XrlFeaTargetBase::handle_socket4_0_1_tcp_listen },
    { "socket4/0.1/udp_enable_recv",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_enable_recv },
    { "socket4/0.1/send",
      &XrlFeaTargetBase::handle_socket4_0_1_send },
    { "socket4/0.1/send_to",
      &XrlFeaTargetBase::handle_socket4_0_1_send_to },
    { "socket4/0.1/send_from_multicast_if",
      &XrlFeaTargetBase::handle_socket4_0_1_send_from_multicast_if },
    { "socket4/0.1/set_socket_option",
      &XrlFeaTargetBase::handle_socket4_0_1_set_socket_option },
    { "socket4/0.1/set_socket_option_txt",
      &XrlFeaTargetBase::handle_socket4_0_1_set_socket_option_txt },
    { "socket6/0.1/tcp_open",
      &XrlFeaTargetBase::handle_socket6_0_1_tcp_open },
    { "socket6/0.1/udp_open",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_open },
    { "socket6/0.1/tcp_open_and_bind",
      &XrlFeaTargetBase::handle_socket6_0_1_tcp_open_and_bind },
    { "socket6/0.1/udp_open_and_bind",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_open_and_bind },
    { "socket6/0.1/udp_open_bind_join",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_open_bind_join },
    { "socket6/0.1/tcp_open_bind_connect",
      &XrlFeaTargetBase::handle_socket6_0_1_tcp_open_bind_connect },
    { "socket6/0.1/udp_open_bind_connect",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_open_bind_connect },
    { "socket6/0.1/bind",
      &XrlFeaTargetBase::handle_socket6_0_1_bind },
    { "socket6/0.1/udp_join_group",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_join_group },
    { "socket6/0.1/udp_leave_group",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_leave_group },
    { "socket6/0.1/close",
      &XrlFeaTargetBase::handle_socket6_0_1_close },
    { "socket6/0.1/tcp_listen",
      &XrlFeaTargetBase::handle_socket6_0_1_tcp_listen },
    { "socket6/0.1/send",
      &XrlFeaTargetBase::handle_socket6_0_1_send },
    { "socket6/0.1/send_to",
      &XrlFeaTargetBase::handle_socket6_0_1_send_to },
    { "socket6/0.1/send_from_multicast_if",
      &XrlFeaTargetBase::handle_socket6_0_1_send_from_multicast_if },
    { "socket6/0.1/set_socket_option",
      &XrlFeaTargetBase::handle_socket6_0_1_set_socket_option },
    { "profile/0.1/enable",
      &XrlFeaTargetBase::handle_profile_0_1_enable },
    { "profile/0.1/disable",
      &XrlFeaTargetBase::handle_profile_0_1_disable },
    { "profile/0.1/get_entries",
      &XrlFeaTargetBase::handle_profile_0_1_get_entries },
    { "profile/0.1/clear",
      &XrlFeaTargetBase::handle_profile_0_1_clear },
    { "profile/0.1/list",
      &XrlFeaTargetBase::handle_profile_0_1_list },
};

const size_t XrlFeaTargetBase::num_handlers = (sizeof(XrlFeaTargetBase::handlers) / sizeof(XrlFeaTargetBase::handlers[0]));


XrlFeaTargetBase::XrlFeaTargetBase(XrlCmdMap* cmds)
    : _cmds(cmds)
{
    if (_cmds)
	add_handlers();
}

XrlFeaTargetBase::~XrlFeaTargetBase()
{
    if (_cmds)
	remove_handlers();
}

bool
XrlFeaTargetBase::set_command_map(XrlCmdMap* cmds)
{
    if (_cmds == 0 && cmds) {
        _cmds = cmds;
        add_handlers();
        return true;
    }
    if (_cmds && cmds == 0) {
	remove_handlers();
        _cmds = cmds;
        return true;
    }
    return false;
}

const XrlCmdError
XrlFeaTargetBase::handle_common_0_1_get_target_name(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_target_name");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string name;
    try {
	XrlCmdError e = common_0_1_get_target_name(
	    name);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_target_name", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("name", name);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_common_0_1_get_version(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_version");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string version;
    try {
	XrlCmdError e = common_0_1_get_version(
	    version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("version", version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_common_0_1_get_status(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_status");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t status;
    string reason;
    try {
	XrlCmdError e = common_0_1_get_status(
	    status,
	    reason);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_status", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("status", status);
	pxa_outputs->add("reason", reason);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_common_0_1_shutdown(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/shutdown");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_shutdown();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/shutdown", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_birth");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_death");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_load_click(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/load_click");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_load_click();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/load_click", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_unload_click(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/unload_click");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_unload_click();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/unload_click", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_enable_click(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/enable_click");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_enable_click(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/enable_click", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_start_click(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/start_click");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_start_click();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/start_click", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_stop_click(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/stop_click");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_stop_click();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/stop_click", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_enable_duplicate_routes_to_kernel(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/enable_duplicate_routes_to_kernel");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_enable_duplicate_routes_to_kernel(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/enable_duplicate_routes_to_kernel", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_enable_kernel_click(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/enable_kernel_click");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_enable_kernel_click(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/enable_kernel_click", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_enable_kernel_click_install_on_startup(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/enable_kernel_click_install_on_startup");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_enable_kernel_click_install_on_startup(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/enable_kernel_click_install_on_startup", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_kernel_click_modules(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_kernel_click_modules");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_kernel_click_modules(
	    xa_inputs.get(0, "modules").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_kernel_click_modules", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_kernel_click_mount_directory(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_kernel_click_mount_directory");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_kernel_click_mount_directory(
	    xa_inputs.get(0, "directory").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_kernel_click_mount_directory", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_kernel_click_config_generator_file(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_kernel_click_config_generator_file");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_kernel_click_config_generator_file(
	    xa_inputs.get(0, "kernel_click_config_generator_file").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_kernel_click_config_generator_file", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_enable_user_click(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/enable_user_click");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_enable_user_click(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/enable_user_click", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_command_file(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_user_click_command_file");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_user_click_command_file(
	    xa_inputs.get(0, "user_click_command_file").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_user_click_command_file", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_command_extra_arguments(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_user_click_command_extra_arguments");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_user_click_command_extra_arguments(
	    xa_inputs.get(0, "user_click_command_extra_arguments").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_user_click_command_extra_arguments", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_command_execute_on_startup(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_user_click_command_execute_on_startup");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_user_click_command_execute_on_startup(
	    xa_inputs.get(0, "user_click_command_execute_on_startup").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_user_click_command_execute_on_startup", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_control_address(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_user_click_control_address");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_user_click_control_address(
	    xa_inputs.get(0, "user_click_control_address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_user_click_control_address", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_control_socket_port(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_user_click_control_socket_port");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_user_click_control_socket_port(
	    xa_inputs.get(0, "user_click_control_socket_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_user_click_control_socket_port", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_startup_config_file(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_user_click_startup_config_file");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_user_click_startup_config_file(
	    xa_inputs.get(0, "user_click_startup_config_file").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_user_click_startup_config_file", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_click_0_1_set_user_click_config_generator_file(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_click/0.1/set_user_click_config_generator_file");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_click_0_1_set_user_click_config_generator_file(
	    xa_inputs.get(0, "user_click_config_generator_file").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_click/0.1/set_user_click_config_generator_file", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_fib_0_1_add_fib_client4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "fea_fib/0.1/add_fib_client4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_fib_0_1_add_fib_client4(
	    xa_inputs.get(0, "client_target_name").text(),
	    xa_inputs.get(1, "send_updates").boolean(),
	    xa_inputs.get(2, "send_resolves").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_fib/0.1/add_fib_client4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_fib_0_1_add_fib_client6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "fea_fib/0.1/add_fib_client6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_fib_0_1_add_fib_client6(
	    xa_inputs.get(0, "client_target_name").text(),
	    xa_inputs.get(1, "send_updates").boolean(),
	    xa_inputs.get(2, "send_resolves").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_fib/0.1/add_fib_client6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_fib_0_1_delete_fib_client4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_fib/0.1/delete_fib_client4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_fib_0_1_delete_fib_client4(
	    xa_inputs.get(0, "client_target_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_fib/0.1/delete_fib_client4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_fib_0_1_delete_fib_client6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_fib/0.1/delete_fib_client6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_fib_0_1_delete_fib_client6(
	    xa_inputs.get(0, "client_target_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_fib/0.1/delete_fib_client6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_start_transaction(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/start_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t tid;
    try {
	XrlCmdError e = fea_firewall_0_1_start_transaction(
	    tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/commit_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/abort_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_add_entry4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/add_entry4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_add_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/add_entry4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_replace_entry4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/replace_entry4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_replace_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/replace_entry4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_delete_entry4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 11) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(11), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/delete_entry4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_delete_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/delete_entry4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_delete_all_entries4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/delete_all_entries4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_delete_all_entries4(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/delete_all_entries4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_start4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/get_entry_list_start4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t token;
    bool more;
    try {
	XrlCmdError e = fea_firewall_0_1_get_entry_list_start4(
	    token,
	    more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/get_entry_list_start4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("token", token);
	pxa_outputs->add("more", more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_next4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/get_entry_list_next4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t rule_number;
    string ifname;
    string vifname;
    IPv4Net src_network;
    IPv4Net dst_network;
    uint32_t ip_protocol;
    uint32_t src_port_begin;
    uint32_t src_port_end;
    uint32_t dst_port_begin;
    uint32_t dst_port_end;
    string action;
    bool more;
    try {
	XrlCmdError e = fea_firewall_0_1_get_entry_list_next4(
	    xa_inputs.get(0, "token").uint32(),
	    rule_number,
	    ifname,
	    vifname,
	    src_network,
	    dst_network,
	    ip_protocol,
	    src_port_begin,
	    src_port_end,
	    dst_port_begin,
	    dst_port_end,
	    action,
	    more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/get_entry_list_next4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("rule_number", rule_number);
	pxa_outputs->add("ifname", ifname);
	pxa_outputs->add("vifname", vifname);
	pxa_outputs->add("src_network", src_network);
	pxa_outputs->add("dst_network", dst_network);
	pxa_outputs->add("ip_protocol", ip_protocol);
	pxa_outputs->add("src_port_begin", src_port_begin);
	pxa_outputs->add("src_port_end", src_port_end);
	pxa_outputs->add("dst_port_begin", dst_port_begin);
	pxa_outputs->add("dst_port_end", dst_port_end);
	pxa_outputs->add("action", action);
	pxa_outputs->add("more", more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_add_entry6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/add_entry6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_add_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/add_entry6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_replace_entry6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/replace_entry6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_replace_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/replace_entry6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_delete_entry6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 11) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(11), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/delete_entry6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_delete_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/delete_entry6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_delete_all_entries6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/delete_all_entries6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_delete_all_entries6(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/delete_all_entries6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_start6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/get_entry_list_start6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t token;
    bool more;
    try {
	XrlCmdError e = fea_firewall_0_1_get_entry_list_start6(
	    token,
	    more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/get_entry_list_start6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("token", token);
	pxa_outputs->add("more", more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_next6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/get_entry_list_next6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t rule_number;
    string ifname;
    string vifname;
    IPv6Net src_network;
    IPv6Net dst_network;
    uint32_t ip_protocol;
    uint32_t src_port_begin;
    uint32_t src_port_end;
    uint32_t dst_port_begin;
    uint32_t dst_port_end;
    string action;
    bool more;
    try {
	XrlCmdError e = fea_firewall_0_1_get_entry_list_next6(
	    xa_inputs.get(0, "token").uint32(),
	    rule_number,
	    ifname,
	    vifname,
	    src_network,
	    dst_network,
	    ip_protocol,
	    src_port_begin,
	    src_port_end,
	    dst_port_begin,
	    dst_port_end,
	    action,
	    more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/get_entry_list_next6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("rule_number", rule_number);
	pxa_outputs->add("ifname", ifname);
	pxa_outputs->add("vifname", vifname);
	pxa_outputs->add("src_network", src_network);
	pxa_outputs->add("dst_network", dst_network);
	pxa_outputs->add("ip_protocol", ip_protocol);
	pxa_outputs->add("src_port_begin", src_port_begin);
	pxa_outputs->add("src_port_end", src_port_end);
	pxa_outputs->add("dst_port_begin", dst_port_begin);
	pxa_outputs->add("dst_port_end", dst_port_end);
	pxa_outputs->add("action", action);
	pxa_outputs->add("more", more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_restore_original_config_on_shutdown(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_restore_original_config_on_shutdown");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_restore_original_config_on_shutdown(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_restore_original_config_on_shutdown", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_names(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_names");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList ifnames;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_names(
	    ifnames);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_names", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("ifnames", ifnames);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_names(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_names");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList vifs;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_names(
	    xa_inputs.get(0, "ifname").text(),
	    vifs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_names", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("vifs", vifs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_flags(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_flags");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    bool broadcast;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_flags(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    enabled,
	    broadcast,
	    loopback,
	    point_to_point,
	    multicast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_flags", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
	pxa_outputs->add("broadcast", broadcast);
	pxa_outputs->add("loopback", loopback);
	pxa_outputs->add("point_to_point", point_to_point);
	pxa_outputs->add("multicast", multicast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_pif_index(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_pif_index");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t pif_index;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_pif_index(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    pif_index);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_pif_index", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("pif_index", pif_index);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_addresses4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_addresses4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList addresses;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_addresses4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    addresses);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_addresses4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("addresses", addresses);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_addresses6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_addresses6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    XrlAtomList addresses;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_addresses6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    addresses);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_addresses6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("addresses", addresses);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_flags4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_address_flags4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    bool broadcast;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_address_flags4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    enabled,
	    broadcast,
	    loopback,
	    point_to_point,
	    multicast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_address_flags4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
	pxa_outputs->add("broadcast", broadcast);
	pxa_outputs->add("loopback", loopback);
	pxa_outputs->add("point_to_point", point_to_point);
	pxa_outputs->add("multicast", multicast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_flags6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_address_flags6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_address_flags6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(),
	    enabled,
	    loopback,
	    point_to_point,
	    multicast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_address_flags6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
	pxa_outputs->add("loopback", loopback);
	pxa_outputs->add("point_to_point", point_to_point);
	pxa_outputs->add("multicast", multicast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_enabled(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_enabled");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_discard(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_discard");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool discard;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_discard(
	    xa_inputs.get(0, "ifname").text(),
	    discard);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_discard", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("discard", discard);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_unreachable(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_unreachable");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool unreachable;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_unreachable(
	    xa_inputs.get(0, "ifname").text(),
	    unreachable);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_unreachable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("unreachable", unreachable);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_management(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_management");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool management;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_management(
	    xa_inputs.get(0, "ifname").text(),
	    management);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_management", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("management", management);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_mac(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_mac");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    Mac mac;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_mac(
	    xa_inputs.get(0, "ifname").text(),
	    mac);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("mac", mac);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_mtu(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_mtu");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t mtu;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_mtu(
	    xa_inputs.get(0, "ifname").text(),
	    mtu);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_mtu", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("mtu", mtu);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_no_carrier(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_no_carrier");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool no_carrier;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_no_carrier(
	    xa_inputs.get(0, "ifname").text(),
	    no_carrier);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_no_carrier", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("no_carrier", no_carrier);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_baudrate(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_baudrate");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint64_t baudrate;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_baudrate(
	    xa_inputs.get(0, "ifname").text(),
	    baudrate);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_baudrate", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("baudrate", baudrate);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_enabled(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_enabled");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_prefix4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_prefix4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t prefix_len;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_prefix4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    prefix_len);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_prefix4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("prefix_len", prefix_len);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_broadcast4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_broadcast4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    IPv4 broadcast;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_broadcast4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    broadcast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_broadcast4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("broadcast", broadcast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_endpoint4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_endpoint4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    IPv4 endpoint;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_endpoint4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    endpoint);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_endpoint4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("endpoint", endpoint);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_prefix6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_prefix6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t prefix_len;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_prefix6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(),
	    prefix_len);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_prefix6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("prefix_len", prefix_len);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_endpoint6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_endpoint6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    IPv6 endpoint;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_endpoint6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(),
	    endpoint);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_endpoint6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("endpoint", endpoint);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_start_transaction(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/start_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t tid;
    try {
	XrlCmdError e = ifmgr_0_1_start_transaction(
	    tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/commit_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/abort_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_create_interface(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_interface");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_interface(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_interface", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_delete_interface(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_interface");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_interface(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_interface", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_configure_all_interfaces_from_system(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/configure_all_interfaces_from_system");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_configure_all_interfaces_from_system(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/configure_all_interfaces_from_system", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_configure_interface_from_system(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/configure_interface_from_system");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_configure_interface_from_system(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/configure_interface_from_system", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_enabled(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_interface_enabled");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_interface_enabled(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_interface_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_discard(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_interface_discard");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_interface_discard(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "discard").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_interface_discard", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_unreachable(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_interface_unreachable");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_interface_unreachable(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "unreachable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_interface_unreachable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_management(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_interface_management");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_interface_management(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "management").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_interface_management", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_mac(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_mac");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_mac(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "mac").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_create_mac(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_mac");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_mac(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "mac").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_delete_mac(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_mac");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_mac(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "mac").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_restore_original_mac(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/restore_original_mac");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_restore_original_mac(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/restore_original_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_mtu(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_mtu");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_mtu(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "mtu").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_mtu", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_restore_original_mtu(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/restore_original_mtu");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_restore_original_mtu(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/restore_original_mtu", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_create_vif(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_vif");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_vif(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_delete_vif(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_vif");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_vif(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_vif_enabled(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_vif_enabled");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_vif_enabled(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_vif_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_vif_vlan(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_vif_vlan");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_vif_vlan(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "vlan_id").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_vif_vlan", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_create_address4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_address4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_address4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_address4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_delete_address4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_address4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_address4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_address4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_address_enabled4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_address_enabled4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_address_enabled4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_address_enabled4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_enabled4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_address_enabled4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_address_enabled4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_address_enabled4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_prefix4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_prefix4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_prefix4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "prefix_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_prefix4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_broadcast4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_broadcast4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_broadcast4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "broadcast").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_broadcast4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_endpoint4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_endpoint4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_endpoint4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "endpoint").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_endpoint4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_create_address6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_address6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_address6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_address6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_delete_address6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_address6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_address6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_address6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_address_enabled6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_address_enabled6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_address_enabled6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_address_enabled6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_enabled6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_address_enabled6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_address_enabled6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(),
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_address_enabled6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_prefix6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_prefix6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_prefix6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "prefix_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_prefix6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_0_1_set_endpoint6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_endpoint6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_endpoint6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "endpoint").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_endpoint6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_replicator_0_1_register_ifmgr_mirror(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr_replicator/0.1/register_ifmgr_mirror");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_replicator_0_1_register_ifmgr_mirror(
	    xa_inputs.get(0, "clientname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr_replicator/0.1/register_ifmgr_mirror", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_ifmgr_replicator_0_1_unregister_ifmgr_mirror(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr_replicator/0.1/unregister_ifmgr_mirror");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_replicator_0_1_unregister_ifmgr_mirror(
	    xa_inputs.get(0, "clientname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr_replicator/0.1/unregister_ifmgr_mirror", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_dest4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/lookup_route_by_dest4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    IPv4Net netmask;
    IPv4 nexthop;
    string ifname;
    string vifname;
    uint32_t metric;
    uint32_t admin_distance;
    string protocol_origin;
    try {
	XrlCmdError e = fti_0_2_lookup_route_by_dest4(
	    xa_inputs.get(0, "dst").ipv4(),
	    netmask,
	    nexthop,
	    ifname,
	    vifname,
	    metric,
	    admin_distance,
	    protocol_origin);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/lookup_route_by_dest4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("netmask", netmask);
	pxa_outputs->add("nexthop", nexthop);
	pxa_outputs->add("ifname", ifname);
	pxa_outputs->add("vifname", vifname);
	pxa_outputs->add("metric", metric);
	pxa_outputs->add("admin_distance", admin_distance);
	pxa_outputs->add("protocol_origin", protocol_origin);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_dest6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/lookup_route_by_dest6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    IPv6Net netmask;
    IPv6 nexthop;
    string ifname;
    string vifname;
    uint32_t metric;
    uint32_t admin_distance;
    string protocol_origin;
    try {
	XrlCmdError e = fti_0_2_lookup_route_by_dest6(
	    xa_inputs.get(0, "dst").ipv6(),
	    netmask,
	    nexthop,
	    ifname,
	    vifname,
	    metric,
	    admin_distance,
	    protocol_origin);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/lookup_route_by_dest6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("netmask", netmask);
	pxa_outputs->add("nexthop", nexthop);
	pxa_outputs->add("ifname", ifname);
	pxa_outputs->add("vifname", vifname);
	pxa_outputs->add("metric", metric);
	pxa_outputs->add("admin_distance", admin_distance);
	pxa_outputs->add("protocol_origin", protocol_origin);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_network4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/lookup_route_by_network4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    IPv4 nexthop;
    string ifname;
    string vifname;
    uint32_t metric;
    uint32_t admin_distance;
    string protocol_origin;
    try {
	XrlCmdError e = fti_0_2_lookup_route_by_network4(
	    xa_inputs.get(0, "dst").ipv4net(),
	    nexthop,
	    ifname,
	    vifname,
	    metric,
	    admin_distance,
	    protocol_origin);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/lookup_route_by_network4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("nexthop", nexthop);
	pxa_outputs->add("ifname", ifname);
	pxa_outputs->add("vifname", vifname);
	pxa_outputs->add("metric", metric);
	pxa_outputs->add("admin_distance", admin_distance);
	pxa_outputs->add("protocol_origin", protocol_origin);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_network6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/lookup_route_by_network6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    IPv6 nexthop;
    string ifname;
    string vifname;
    uint32_t metric;
    uint32_t admin_distance;
    string protocol_origin;
    try {
	XrlCmdError e = fti_0_2_lookup_route_by_network6(
	    xa_inputs.get(0, "dst").ipv6net(),
	    nexthop,
	    ifname,
	    vifname,
	    metric,
	    admin_distance,
	    protocol_origin);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/lookup_route_by_network6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("nexthop", nexthop);
	pxa_outputs->add("ifname", ifname);
	pxa_outputs->add("vifname", vifname);
	pxa_outputs->add("metric", metric);
	pxa_outputs->add("admin_distance", admin_distance);
	pxa_outputs->add("protocol_origin", protocol_origin);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_have_ipv4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/have_ipv4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool result;
    try {
	XrlCmdError e = fti_0_2_have_ipv4(
	    result);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/have_ipv4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("result", result);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_have_ipv6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/have_ipv6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool result;
    try {
	XrlCmdError e = fti_0_2_have_ipv6(
	    result);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/have_ipv6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("result", result);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_get_unicast_forwarding_enabled4(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/get_unicast_forwarding_enabled4");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = fti_0_2_get_unicast_forwarding_enabled4(
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/get_unicast_forwarding_enabled4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_get_unicast_forwarding_enabled6(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/get_unicast_forwarding_enabled6");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    bool enabled;
    try {
	XrlCmdError e = fti_0_2_get_unicast_forwarding_enabled6(
	    enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/get_unicast_forwarding_enabled6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_enabled4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_enabled4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_enabled4(
	    xa_inputs.get(0, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_enabled4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_enabled6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_enabled6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_enabled6(
	    xa_inputs.get(0, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_enabled6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_entries_retain_on_startup4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(
	    xa_inputs.get(0, "retain").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_entries_retain_on_startup4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(
	    xa_inputs.get(0, "retain").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_entries_retain_on_startup6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(
	    xa_inputs.get(0, "retain").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_entries_retain_on_startup6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(
	    xa_inputs.get(0, "retain").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_table_id4(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_table_id4");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_table_id4(
	    xa_inputs.get(0, "is_configured").boolean(),
	    xa_inputs.get(1, "table_id").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_table_id4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_table_id6(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_table_id6");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_table_id6(
	    xa_inputs.get(0, "is_configured").boolean(),
	    xa_inputs.get(1, "table_id").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_table_id6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction4_0_1_start_transaction(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/start_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t tid;
    try {
	XrlCmdError e = redist_transaction4_0_1_start_transaction(
	    tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction4_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/commit_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction4_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/abort_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction4_0_1_add_route(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/add_route");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/add_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction4_0_1_delete_route(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/delete_route");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/delete_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction4_0_1_delete_all_routes(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/delete_all_routes");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/delete_all_routes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction6_0_1_start_transaction(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/start_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    uint32_t tid;
    try {
	XrlCmdError e = redist_transaction6_0_1_start_transaction(
	    tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction6_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/commit_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction6_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/abort_transaction");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction6_0_1_add_route(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/add_route");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/add_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction6_0_1_delete_route(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/delete_route");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/delete_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_redist_transaction6_0_1_delete_all_routes(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/delete_all_routes");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/delete_all_routes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_link_0_1_send(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/send");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").mac(),
	    xa_inputs.get(3, "dst_address").mac(),
	    xa_inputs.get(4, "ether_type").uint32(),
	    xa_inputs.get(5, "payload").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_link_0_1_register_receiver(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/register_receiver");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "enable_multicast_loopback").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/register_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_link_0_1_unregister_receiver(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/unregister_receiver");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/unregister_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_link_0_1_join_multicast_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/join_multicast_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "group_address").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/join_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_link_0_1_leave_multicast_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/leave_multicast_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "group_address").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/leave_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet4_0_1_send(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 10) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(10), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/send");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv4(),
	    xa_inputs.get(3, "dst_address").ipv4(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "payload").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet4_0_1_register_receiver(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/register_receiver");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "enable_multicast_loopback").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/register_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet4_0_1_unregister_receiver(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/unregister_receiver");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/unregister_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet4_0_1_join_multicast_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/join_multicast_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/join_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet4_0_1_leave_multicast_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/leave_multicast_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/leave_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet6_0_1_send(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/send");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv6(),
	    xa_inputs.get(3, "dst_address").ipv6(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "ext_headers_type").list(),
	    xa_inputs.get(10, "ext_headers_payload").list(),
	    xa_inputs.get(11, "payload").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet6_0_1_register_receiver(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/register_receiver");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "enable_multicast_loopback").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/register_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet6_0_1_unregister_receiver(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/unregister_receiver");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/unregister_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet6_0_1_join_multicast_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/join_multicast_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/join_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_raw_packet6_0_1_leave_multicast_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/leave_multicast_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/leave_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_tcp_open(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/tcp_open");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket4_0_1_tcp_open(
	    xa_inputs.get(0, "creator").text(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/tcp_open", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_udp_open(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open(
	    xa_inputs.get(0, "creator").text(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_tcp_open_and_bind(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/tcp_open_and_bind");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket4_0_1_tcp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/tcp_open_and_bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_udp_open_and_bind(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open_and_bind");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open_and_bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_join(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open_bind_join");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open_bind_join(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "mcast_addr").ipv4(),
	    xa_inputs.get(4, "ttl").uint32(),
	    xa_inputs.get(5, "reuse").boolean(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open_bind_join", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_tcp_open_bind_connect(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/tcp_open_bind_connect");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket4_0_1_tcp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv4(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/tcp_open_bind_connect", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_connect(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open_bind_connect");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv4(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open_bind_connect", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_broadcast(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 8) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(8), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open_bind_broadcast");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open_bind_broadcast(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vifname").text(),
	    xa_inputs.get(3, "local_port").uint32(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    xa_inputs.get(5, "reuse").boolean(),
	    xa_inputs.get(6, "limited").boolean(),
	    xa_inputs.get(7, "connected").boolean(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open_bind_broadcast", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_bind(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/bind");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_bind(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_udp_join_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_join_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_udp_join_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv4(),
	    xa_inputs.get(2, "join_if_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_join_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_udp_leave_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_leave_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_udp_leave_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv4(),
	    xa_inputs.get(2, "leave_if_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_leave_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_close(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/close");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_close(
	    xa_inputs.get(0, "sockid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/close", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_tcp_listen(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/tcp_listen");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_tcp_listen(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "backlog").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/tcp_listen", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_udp_enable_recv(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_enable_recv");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_udp_enable_recv(
	    xa_inputs.get(0, "sockid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_enable_recv", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_send(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/send");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_send(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_send_to(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/send_to");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_send_to(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "remote_addr").ipv4(),
	    xa_inputs.get(2, "remote_port").uint32(),
	    xa_inputs.get(3, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/send_to", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_send_from_multicast_if(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/send_from_multicast_if");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_send_from_multicast_if(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "group_addr").ipv4(),
	    xa_inputs.get(2, "group_port").uint32(),
	    xa_inputs.get(3, "ifaddr").ipv4(),
	    xa_inputs.get(4, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/send_from_multicast_if", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_set_socket_option(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/set_socket_option");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_set_socket_option(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/set_socket_option", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket4_0_1_set_socket_option_txt(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/set_socket_option_txt");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_set_socket_option_txt(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/set_socket_option_txt", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_tcp_open(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/tcp_open");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket6_0_1_tcp_open(
	    xa_inputs.get(0, "creator").text(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/tcp_open", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_udp_open(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_open");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket6_0_1_udp_open(
	    xa_inputs.get(0, "creator").text(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_open", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_tcp_open_and_bind(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/tcp_open_and_bind");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket6_0_1_tcp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/tcp_open_and_bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_udp_open_and_bind(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_open_and_bind");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket6_0_1_udp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_open_and_bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_udp_open_bind_join(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_open_bind_join");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket6_0_1_udp_open_bind_join(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "mcast_addr").ipv6(),
	    xa_inputs.get(4, "ttl").uint32(),
	    xa_inputs.get(5, "reuse").boolean(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_open_bind_join", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_tcp_open_bind_connect(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/tcp_open_bind_connect");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket6_0_1_tcp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv6(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/tcp_open_bind_connect", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_udp_open_bind_connect(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_open_bind_connect");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string sockid;
    try {
	XrlCmdError e = socket6_0_1_udp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv6(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_open_bind_connect", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_bind(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/bind");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_bind(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_udp_join_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_join_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_udp_join_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv6(),
	    xa_inputs.get(2, "join_if_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_join_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_udp_leave_group(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_leave_group");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_udp_leave_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv6(),
	    xa_inputs.get(2, "leave_if_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_leave_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_close(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/close");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_close(
	    xa_inputs.get(0, "sockid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/close", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_tcp_listen(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/tcp_listen");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_tcp_listen(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "backlog").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/tcp_listen", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_send(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/send");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_send(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_send_to(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/send_to");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_send_to(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "remote_addr").ipv6(),
	    xa_inputs.get(2, "remote_port").uint32(),
	    xa_inputs.get(3, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/send_to", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_send_from_multicast_if(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/send_from_multicast_if");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_send_from_multicast_if(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "group_addr").ipv6(),
	    xa_inputs.get(2, "group_port").uint32(),
	    xa_inputs.get(3, "ifaddr").ipv6(),
	    xa_inputs.get(4, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/send_from_multicast_if", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_socket6_0_1_set_socket_option(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/set_socket_option");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_set_socket_option(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/set_socket_option", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_profile_0_1_enable(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/enable");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_enable(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/enable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_profile_0_1_disable(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/disable");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_disable(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/disable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_profile_0_1_get_entries(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/get_entries");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_get_entries(
	    xa_inputs.get(0, "pname").text(),
	    xa_inputs.get(1, "instance_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/get_entries", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_profile_0_1_clear(const XrlArgs& xa_inputs, XrlArgs* /* pxa_outputs */)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/clear");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_clear(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/clear", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
}

const XrlCmdError
XrlFeaTargetBase::handle_profile_0_1_list(const XrlArgs& xa_inputs, XrlArgs* pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/list");
	return XrlCmdError::BAD_ARGS();
    }

    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }

    /* Return value declarations */
    string info;
    try {
	XrlCmdError e = profile_0_1_list(
	    info);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("info", info);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
}

void
XrlFeaTargetBase::add_handlers()
{
    for (size_t i = 0; i < num_handlers; ++i) {
        if (!_cmds->add_handler(handlers[i].name,
                                callback(this, handlers[i].method))) {
            XLOG_ERROR("Failed to register xrl handler finder://%s/%s", "fea", handlers[i].name);
        }
    }
    _cmds->finalize();
}

void
XrlFeaTargetBase::remove_handlers()
{
     for (size_t i = 0; i < num_handlers; ++i) {
         _cmds->remove_handler(handlers[i].name);
     }
}
