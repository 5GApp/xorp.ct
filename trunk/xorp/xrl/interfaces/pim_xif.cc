/*
 * Copyright (c) 2002 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by '../scripts/clnt-gen'.
 */

#ident "$XORP: xorp/xrl/interfaces/pim_xif.cc,v 1.1.1.1 2002/12/11 23:56:18 hodson Exp $"

#include "pim_xif.hh"

bool
XrlPimV0p1Client::send_enable_vif(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB0&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_vif");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall0, cb));
}


/* Unmarshall enable_vif */
void
XrlPimV0p1Client::unmarshall0(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB0		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_disable_vif(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB1&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_vif");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall1, cb));
}


/* Unmarshall disable_vif */
void
XrlPimV0p1Client::unmarshall1(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB1		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_start_vif(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB2&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_vif");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall2, cb));
}


/* Unmarshall start_vif */
void
XrlPimV0p1Client::unmarshall2(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB2		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_stop_vif(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB3&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_vif");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall3, cb));
}


/* Unmarshall stop_vif */
void
XrlPimV0p1Client::unmarshall3(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB3		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_enable_all_vifs(
	const char*	the_tgt, 
	const CB4&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_all_vifs");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall4, cb));
}


/* Unmarshall enable_all_vifs */
void
XrlPimV0p1Client::unmarshall4(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB4		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_disable_all_vifs(
	const char*	the_tgt, 
	const CB5&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_all_vifs");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall5, cb));
}


/* Unmarshall disable_all_vifs */
void
XrlPimV0p1Client::unmarshall5(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB5		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_start_all_vifs(
	const char*	the_tgt, 
	const CB6&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_all_vifs");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall6, cb));
}


/* Unmarshall start_all_vifs */
void
XrlPimV0p1Client::unmarshall6(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB6		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_stop_all_vifs(
	const char*	the_tgt, 
	const CB7&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_all_vifs");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall7, cb));
}


/* Unmarshall stop_all_vifs */
void
XrlPimV0p1Client::unmarshall7(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB7		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_enable_pim(
	const char*	the_tgt, 
	const CB8&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_pim");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall8, cb));
}


/* Unmarshall enable_pim */
void
XrlPimV0p1Client::unmarshall8(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB8		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_disable_pim(
	const char*	the_tgt, 
	const CB9&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_pim");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall9, cb));
}


/* Unmarshall disable_pim */
void
XrlPimV0p1Client::unmarshall9(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB9		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_enable_cli(
	const char*	the_tgt, 
	const CB10&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_cli");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall10, cb));
}


/* Unmarshall enable_cli */
void
XrlPimV0p1Client::unmarshall10(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB10		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_disable_cli(
	const char*	the_tgt, 
	const CB11&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_cli");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall11, cb));
}


/* Unmarshall disable_cli */
void
XrlPimV0p1Client::unmarshall11(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB11		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_start_pim(
	const char*	the_tgt, 
	const CB12&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_pim");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall12, cb));
}


/* Unmarshall start_pim */
void
XrlPimV0p1Client::unmarshall12(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB12		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_stop_pim(
	const char*	the_tgt, 
	const CB13&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_pim");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall13, cb));
}


/* Unmarshall stop_pim */
void
XrlPimV0p1Client::unmarshall13(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB13		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_start_cli(
	const char*	the_tgt, 
	const CB14&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_cli");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall14, cb));
}


/* Unmarshall start_cli */
void
XrlPimV0p1Client::unmarshall14(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB14		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_stop_cli(
	const char*	the_tgt, 
	const CB15&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_cli");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall15, cb));
}


/* Unmarshall stop_cli */
void
XrlPimV0p1Client::unmarshall15(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB15		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_enable_bsr(
	const char*	the_tgt, 
	const CB16&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_bsr");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall16, cb));
}


/* Unmarshall enable_bsr */
void
XrlPimV0p1Client::unmarshall16(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB16		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_disable_bsr(
	const char*	the_tgt, 
	const CB17&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_bsr");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall17, cb));
}


/* Unmarshall disable_bsr */
void
XrlPimV0p1Client::unmarshall17(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB17		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_start_bsr(
	const char*	the_tgt, 
	const CB18&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_bsr");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall18, cb));
}


/* Unmarshall start_bsr */
void
XrlPimV0p1Client::unmarshall18(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB18		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_stop_bsr(
	const char*	the_tgt, 
	const CB19&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_bsr");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall19, cb));
}


/* Unmarshall stop_bsr */
void
XrlPimV0p1Client::unmarshall19(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB19		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr_by_vif_name4(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv4Net&	admin_scope_zone_id, 
	const string&	vif_name, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const CB20&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_bsr_by_vif_name4");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("admin_scope_zone_id", admin_scope_zone_id);
    x.args().add("vif_name", vif_name);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall20, cb));
}


/* Unmarshall add_config_cand_bsr_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall20(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB20		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr_by_vif_name6(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv6Net&	admin_scope_zone_id, 
	const string&	vif_name, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const CB21&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_bsr_by_vif_name6");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("admin_scope_zone_id", admin_scope_zone_id);
    x.args().add("vif_name", vif_name);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall21, cb));
}


/* Unmarshall add_config_cand_bsr_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall21(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB21		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr_by_addr4(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv4Net&	admin_scope_zone_id, 
	const IPv4&	cand_bsr_addr, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const CB22&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_bsr_by_addr4");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("admin_scope_zone_id", admin_scope_zone_id);
    x.args().add("cand_bsr_addr", cand_bsr_addr);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall22, cb));
}


/* Unmarshall add_config_cand_bsr_by_addr4 */
void
XrlPimV0p1Client::unmarshall22(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB22		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr_by_addr6(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv6Net&	admin_scope_zone_id, 
	const IPv6&	cand_bsr_addr, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const CB23&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_bsr_by_addr6");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("admin_scope_zone_id", admin_scope_zone_id);
    x.args().add("cand_bsr_addr", cand_bsr_addr);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall23, cb));
}


/* Unmarshall add_config_cand_bsr_by_addr6 */
void
XrlPimV0p1Client::unmarshall23(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB23		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_delete_config_cand_bsr4(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv4Net&	admin_scope_zone_id, 
	const CB24&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_bsr4");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("admin_scope_zone_id", admin_scope_zone_id);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall24, cb));
}


/* Unmarshall delete_config_cand_bsr4 */
void
XrlPimV0p1Client::unmarshall24(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB24		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_delete_config_cand_bsr6(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv6Net&	admin_scope_zone_id, 
	const CB25&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_bsr6");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("admin_scope_zone_id", admin_scope_zone_id);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall25, cb));
}


/* Unmarshall delete_config_cand_bsr6 */
void
XrlPimV0p1Client::unmarshall25(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB25		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp_by_vif_name4(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv4Net&	group_prefix, 
	const string&	vif_name, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const CB26&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_rp_by_vif_name4");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("vif_name", vif_name);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall26, cb));
}


/* Unmarshall add_config_cand_rp_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall26(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB26		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp_by_vif_name6(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv6Net&	group_prefix, 
	const string&	vif_name, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const CB27&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_rp_by_vif_name6");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("vif_name", vif_name);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall27, cb));
}


/* Unmarshall add_config_cand_rp_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall27(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB27		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp_by_addr4(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv4Net&	group_prefix, 
	const IPv4&	cand_rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const CB28&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_rp_by_addr4");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("cand_rp_addr", cand_rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall28, cb));
}


/* Unmarshall add_config_cand_rp_by_addr4 */
void
XrlPimV0p1Client::unmarshall28(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB28		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp_by_addr6(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv6Net&	group_prefix, 
	const IPv6&	cand_rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const CB29&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_rp_by_addr6");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("cand_rp_addr", cand_rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall29, cb));
}


/* Unmarshall add_config_cand_rp_by_addr6 */
void
XrlPimV0p1Client::unmarshall29(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB29		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp_by_vif_name4(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv4Net&	group_prefix, 
	const string&	vif_name, 
	const CB30&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_rp_by_vif_name4");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall30, cb));
}


/* Unmarshall delete_config_cand_rp_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall30(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB30		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp_by_vif_name6(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv6Net&	group_prefix, 
	const string&	vif_name, 
	const CB31&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_rp_by_vif_name6");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall31, cb));
}


/* Unmarshall delete_config_cand_rp_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall31(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB31		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp_by_addr4(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv4Net&	group_prefix, 
	const IPv4&	cand_rp_addr, 
	const CB32&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_rp_by_addr4");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("cand_rp_addr", cand_rp_addr);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall32, cb));
}


/* Unmarshall delete_config_cand_rp_by_addr4 */
void
XrlPimV0p1Client::unmarshall32(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB32		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp_by_addr6(
	const char*	the_tgt, 
	const bool&	is_admin_scope_zone, 
	const IPv6Net&	group_prefix, 
	const IPv6&	cand_rp_addr, 
	const CB33&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_rp_by_addr6");
    x.args().add("is_admin_scope_zone", is_admin_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("cand_rp_addr", cand_rp_addr);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall33, cb));
}


/* Unmarshall delete_config_cand_rp_by_addr6 */
void
XrlPimV0p1Client::unmarshall33(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB33		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_rp4(
	const char*	the_tgt, 
	const IPv4Net&	group_prefix, 
	const IPv4&	rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	hash_masklen, 
	const CB34&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_rp4");
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall34, cb));
}


/* Unmarshall add_config_rp4 */
void
XrlPimV0p1Client::unmarshall34(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB34		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_config_rp6(
	const char*	the_tgt, 
	const IPv6Net&	group_prefix, 
	const IPv6&	rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	hash_masklen, 
	const CB35&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_rp6");
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall35, cb));
}


/* Unmarshall add_config_rp6 */
void
XrlPimV0p1Client::unmarshall35(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB35		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_delete_config_rp4(
	const char*	the_tgt, 
	const IPv4Net&	group_prefix, 
	const IPv4&	rp_addr, 
	const CB36&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_rp4");
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall36, cb));
}


/* Unmarshall delete_config_rp4 */
void
XrlPimV0p1Client::unmarshall36(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB36		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_delete_config_rp6(
	const char*	the_tgt, 
	const IPv6Net&	group_prefix, 
	const IPv6&	rp_addr, 
	const CB37&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_rp6");
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall37, cb));
}


/* Unmarshall delete_config_rp6 */
void
XrlPimV0p1Client::unmarshall37(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB37		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_config_rp_done(
	const char*	the_tgt, 
	const CB38&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/config_rp_done");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall38, cb));
}


/* Unmarshall config_rp_done */
void
XrlPimV0p1Client::unmarshall38(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB38		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_proto_version(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB39&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_proto_version");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall39, cb));
}


/* Unmarshall get_vif_proto_version */
void
XrlPimV0p1Client::unmarshall39(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB39		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    uint32_t proto_version;
    bool fail;
    string reason;
    try {
	a->get("proto_version", proto_version);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &proto_version, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_proto_version(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	proto_version, 
	const CB40&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_proto_version");
    x.args().add("vif_name", vif_name);
    x.args().add("proto_version", proto_version);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall40, cb));
}


/* Unmarshall set_vif_proto_version */
void
XrlPimV0p1Client::unmarshall40(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB40		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_proto_version(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB41&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_proto_version");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall41, cb));
}


/* Unmarshall reset_vif_proto_version */
void
XrlPimV0p1Client::unmarshall41(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB41		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_hello_triggered_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB42&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_hello_triggered_delay");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall42, cb));
}


/* Unmarshall get_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall42(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB42		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    uint32_t hello_triggered_delay;
    bool fail;
    string reason;
    try {
	a->get("hello_triggered_delay", hello_triggered_delay);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &hello_triggered_delay, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_hello_triggered_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	hello_triggered_delay, 
	const CB43&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_hello_triggered_delay");
    x.args().add("vif_name", vif_name);
    x.args().add("hello_triggered_delay", hello_triggered_delay);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall43, cb));
}


/* Unmarshall set_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall43(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB43		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_triggered_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB44&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_hello_triggered_delay");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall44, cb));
}


/* Unmarshall reset_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall44(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB44		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_hello_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB45&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_hello_period");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall45, cb));
}


/* Unmarshall get_vif_hello_period */
void
XrlPimV0p1Client::unmarshall45(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB45		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    uint32_t hello_period;
    bool fail;
    string reason;
    try {
	a->get("hello_period", hello_period);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &hello_period, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_hello_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	hello_period, 
	const CB46&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_hello_period");
    x.args().add("vif_name", vif_name);
    x.args().add("hello_period", hello_period);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall46, cb));
}


/* Unmarshall set_vif_hello_period */
void
XrlPimV0p1Client::unmarshall46(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB46		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB47&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_hello_period");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall47, cb));
}


/* Unmarshall reset_vif_hello_period */
void
XrlPimV0p1Client::unmarshall47(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB47		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_hello_holdtime(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB48&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_hello_holdtime");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall48, cb));
}


/* Unmarshall get_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall48(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB48		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    uint32_t hello_holdtime;
    bool fail;
    string reason;
    try {
	a->get("hello_holdtime", hello_holdtime);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &hello_holdtime, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_hello_holdtime(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	hello_holdtime, 
	const CB49&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_hello_holdtime");
    x.args().add("vif_name", vif_name);
    x.args().add("hello_holdtime", hello_holdtime);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall49, cb));
}


/* Unmarshall set_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall49(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB49		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_holdtime(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB50&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_hello_holdtime");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall50, cb));
}


/* Unmarshall reset_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall50(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB50		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_dr_priority(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB51&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_dr_priority");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall51, cb));
}


/* Unmarshall get_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall51(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB51		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    uint32_t dr_priority;
    bool fail;
    string reason;
    try {
	a->get("dr_priority", dr_priority);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &dr_priority, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_dr_priority(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	dr_priority, 
	const CB52&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_dr_priority");
    x.args().add("vif_name", vif_name);
    x.args().add("dr_priority", dr_priority);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall52, cb));
}


/* Unmarshall set_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall52(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB52		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_dr_priority(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB53&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_dr_priority");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall53, cb));
}


/* Unmarshall reset_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall53(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB53		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_lan_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB54&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_lan_delay");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall54, cb));
}


/* Unmarshall get_vif_lan_delay */
void
XrlPimV0p1Client::unmarshall54(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB54		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    uint32_t lan_delay;
    bool fail;
    string reason;
    try {
	a->get("lan_delay", lan_delay);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &lan_delay, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_lan_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	lan_delay, 
	const CB55&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_lan_delay");
    x.args().add("vif_name", vif_name);
    x.args().add("lan_delay", lan_delay);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall55, cb));
}


/* Unmarshall set_vif_lan_delay */
void
XrlPimV0p1Client::unmarshall55(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB55		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_lan_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB56&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_lan_delay");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall56, cb));
}


/* Unmarshall reset_vif_lan_delay */
void
XrlPimV0p1Client::unmarshall56(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB56		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_override_interval(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB57&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_override_interval");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall57, cb));
}


/* Unmarshall get_vif_override_interval */
void
XrlPimV0p1Client::unmarshall57(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB57		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    uint32_t override_interval;
    bool fail;
    string reason;
    try {
	a->get("override_interval", override_interval);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &override_interval, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_override_interval(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	override_interval, 
	const CB58&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_override_interval");
    x.args().add("vif_name", vif_name);
    x.args().add("override_interval", override_interval);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall58, cb));
}


/* Unmarshall set_vif_override_interval */
void
XrlPimV0p1Client::unmarshall58(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB58		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_override_interval(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB59&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_override_interval");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall59, cb));
}


/* Unmarshall reset_vif_override_interval */
void
XrlPimV0p1Client::unmarshall59(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB59		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_is_tracking_support_disabled(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB60&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_is_tracking_support_disabled");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall60, cb));
}


/* Unmarshall get_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall60(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB60		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    bool is_tracking_support_disabled;
    bool fail;
    string reason;
    try {
	a->get("is_tracking_support_disabled", is_tracking_support_disabled);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &is_tracking_support_disabled, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_is_tracking_support_disabled(
	const char*	the_tgt, 
	const string&	vif_name, 
	const bool&	is_tracking_support_disabled, 
	const CB61&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_is_tracking_support_disabled");
    x.args().add("vif_name", vif_name);
    x.args().add("is_tracking_support_disabled", is_tracking_support_disabled);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall61, cb));
}


/* Unmarshall set_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall61(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB61		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_is_tracking_support_disabled(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB62&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_is_tracking_support_disabled");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall62, cb));
}


/* Unmarshall reset_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall62(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB62		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_accept_nohello_neighbors(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB63&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_accept_nohello_neighbors");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall63, cb));
}


/* Unmarshall get_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall63(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB63		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    bool accept_nohello_neighbors;
    bool fail;
    string reason;
    try {
	a->get("accept_nohello_neighbors", accept_nohello_neighbors);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &accept_nohello_neighbors, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_accept_nohello_neighbors(
	const char*	the_tgt, 
	const string&	vif_name, 
	const bool&	accept_nohello_neighbors, 
	const CB64&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_accept_nohello_neighbors");
    x.args().add("vif_name", vif_name);
    x.args().add("accept_nohello_neighbors", accept_nohello_neighbors);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall64, cb));
}


/* Unmarshall set_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall64(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB64		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_accept_nohello_neighbors(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB65&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_accept_nohello_neighbors");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall65, cb));
}


/* Unmarshall reset_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall65(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB65		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_get_vif_join_prune_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB66&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_join_prune_period");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall66, cb));
}


/* Unmarshall get_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall66(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB66		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%d != 3)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    uint32_t join_prune_period;
    bool fail;
    string reason;
    try {
	a->get("join_prune_period", join_prune_period);
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &join_prune_period, &fail, &reason);
}

bool
XrlPimV0p1Client::send_set_vif_join_prune_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	join_prune_period, 
	const CB67&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_join_prune_period");
    x.args().add("vif_name", vif_name);
    x.args().add("join_prune_period", join_prune_period);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall67, cb));
}


/* Unmarshall set_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall67(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB67		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_reset_vif_join_prune_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const CB68&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_join_prune_period");
    x.args().add("vif_name", vif_name);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall68, cb));
}


/* Unmarshall reset_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall68(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB68		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_test_jp_entry4(
	const char*	the_tgt, 
	const IPv4&	source_addr, 
	const IPv4&	group_addr, 
	const uint32_t&	group_masklen, 
	const string&	mrt_entry_type, 
	const string&	action_jp, 
	const uint32_t&	holdtime, 
	const bool&	new_group_bool, 
	const CB69&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_jp_entry4");
    x.args().add("source_addr", source_addr);
    x.args().add("group_addr", group_addr);
    x.args().add("group_masklen", group_masklen);
    x.args().add("mrt_entry_type", mrt_entry_type);
    x.args().add("action_jp", action_jp);
    x.args().add("holdtime", holdtime);
    x.args().add("new_group_bool", new_group_bool);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall69, cb));
}


/* Unmarshall add_test_jp_entry4 */
void
XrlPimV0p1Client::unmarshall69(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB69		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_add_test_jp_entry6(
	const char*	the_tgt, 
	const IPv6&	source_addr, 
	const IPv6&	group_addr, 
	const uint32_t&	group_masklen, 
	const string&	mrt_entry_type, 
	const string&	action_jp, 
	const uint32_t&	holdtime, 
	const bool&	new_group_bool, 
	const CB70&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_jp_entry6");
    x.args().add("source_addr", source_addr);
    x.args().add("group_addr", group_addr);
    x.args().add("group_masklen", group_masklen);
    x.args().add("mrt_entry_type", mrt_entry_type);
    x.args().add("action_jp", action_jp);
    x.args().add("holdtime", holdtime);
    x.args().add("new_group_bool", new_group_bool);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall70, cb));
}


/* Unmarshall add_test_jp_entry6 */
void
XrlPimV0p1Client::unmarshall70(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB70		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_send_test_jp_entry4(
	const char*	the_tgt, 
	const IPv4&	nbr_addr, 
	const CB71&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_jp_entry4");
    x.args().add("nbr_addr", nbr_addr);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall71, cb));
}


/* Unmarshall send_test_jp_entry4 */
void
XrlPimV0p1Client::unmarshall71(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB71		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_send_test_jp_entry6(
	const char*	the_tgt, 
	const IPv6&	nbr_addr, 
	const CB72&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_jp_entry6");
    x.args().add("nbr_addr", nbr_addr);
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall72, cb));
}


/* Unmarshall send_test_jp_entry6 */
void
XrlPimV0p1Client::unmarshall72(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB72		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_enable_log_trace(
	const char*	the_tgt, 
	const CB73&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_log_trace");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall73, cb));
}


/* Unmarshall enable_log_trace */
void
XrlPimV0p1Client::unmarshall73(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB73		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}

bool
XrlPimV0p1Client::send_disable_log_trace(
	const char*	the_tgt, 
	const CB74&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_log_trace");
    return _router->send(x, callback(this, &XrlPimV0p1Client::unmarshall74, cb));
}


/* Unmarshall disable_log_trace */
void
XrlPimV0p1Client::unmarshall74(
	const XrlError&	e, 
	XrlRouter&	/* r */, 
	const Xrl&	/* x */, 
	XrlArgs*	a, 
	CB74		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%d != 2)", a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    bool fail;
    string reason;
    try {
	a->get("fail", fail);
	a->get("reason", reason);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &fail, &reason);
}
