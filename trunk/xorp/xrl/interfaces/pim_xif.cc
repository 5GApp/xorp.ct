/*
 * Copyright (c) 2001-2003 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#ident "$XORP$"

#include "pim_xif.hh"

bool
XrlPimV0p1Client::send_enable_vif(
	const char*	the_tgt, 
	const string&	vif_name, 
	const EnableVifCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_vif");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_enable_vif, cb));
}


/* Unmarshall enable_vif */
void
XrlPimV0p1Client::unmarshall_enable_vif(
	const XrlError&	e, 
	XrlArgs*	a, 
	EnableVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_disable_vif(
	const char*	the_tgt, 
	const string&	vif_name, 
	const DisableVifCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_vif");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_disable_vif, cb));
}


/* Unmarshall disable_vif */
void
XrlPimV0p1Client::unmarshall_disable_vif(
	const XrlError&	e, 
	XrlArgs*	a, 
	DisableVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_vif(
	const char*	the_tgt, 
	const string&	vif_name, 
	const StartVifCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_vif");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_start_vif, cb));
}


/* Unmarshall start_vif */
void
XrlPimV0p1Client::unmarshall_start_vif(
	const XrlError&	e, 
	XrlArgs*	a, 
	StartVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_vif(
	const char*	the_tgt, 
	const string&	vif_name, 
	const StopVifCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_vif");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_stop_vif, cb));
}


/* Unmarshall stop_vif */
void
XrlPimV0p1Client::unmarshall_stop_vif(
	const XrlError&	e, 
	XrlArgs*	a, 
	StopVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_all_vifs(
	const char*	the_tgt, 
	const EnableAllVifsCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_all_vifs");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_enable_all_vifs, cb));
}


/* Unmarshall enable_all_vifs */
void
XrlPimV0p1Client::unmarshall_enable_all_vifs(
	const XrlError&	e, 
	XrlArgs*	a, 
	EnableAllVifsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_disable_all_vifs(
	const char*	the_tgt, 
	const DisableAllVifsCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_all_vifs");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_disable_all_vifs, cb));
}


/* Unmarshall disable_all_vifs */
void
XrlPimV0p1Client::unmarshall_disable_all_vifs(
	const XrlError&	e, 
	XrlArgs*	a, 
	DisableAllVifsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_all_vifs(
	const char*	the_tgt, 
	const StartAllVifsCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_all_vifs");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_start_all_vifs, cb));
}


/* Unmarshall start_all_vifs */
void
XrlPimV0p1Client::unmarshall_start_all_vifs(
	const XrlError&	e, 
	XrlArgs*	a, 
	StartAllVifsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_all_vifs(
	const char*	the_tgt, 
	const StopAllVifsCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_all_vifs");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_stop_all_vifs, cb));
}


/* Unmarshall stop_all_vifs */
void
XrlPimV0p1Client::unmarshall_stop_all_vifs(
	const XrlError&	e, 
	XrlArgs*	a, 
	StopAllVifsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_pim(
	const char*	the_tgt, 
	const EnablePimCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_pim");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_enable_pim, cb));
}


/* Unmarshall enable_pim */
void
XrlPimV0p1Client::unmarshall_enable_pim(
	const XrlError&	e, 
	XrlArgs*	a, 
	EnablePimCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_disable_pim(
	const char*	the_tgt, 
	const DisablePimCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_pim");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_disable_pim, cb));
}


/* Unmarshall disable_pim */
void
XrlPimV0p1Client::unmarshall_disable_pim(
	const XrlError&	e, 
	XrlArgs*	a, 
	DisablePimCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_cli(
	const char*	the_tgt, 
	const EnableCliCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_cli");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_enable_cli, cb));
}


/* Unmarshall enable_cli */
void
XrlPimV0p1Client::unmarshall_enable_cli(
	const XrlError&	e, 
	XrlArgs*	a, 
	EnableCliCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_disable_cli(
	const char*	the_tgt, 
	const DisableCliCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_cli");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_disable_cli, cb));
}


/* Unmarshall disable_cli */
void
XrlPimV0p1Client::unmarshall_disable_cli(
	const XrlError&	e, 
	XrlArgs*	a, 
	DisableCliCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_pim(
	const char*	the_tgt, 
	const StartPimCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_pim");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_start_pim, cb));
}


/* Unmarshall start_pim */
void
XrlPimV0p1Client::unmarshall_start_pim(
	const XrlError&	e, 
	XrlArgs*	a, 
	StartPimCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_pim(
	const char*	the_tgt, 
	const StopPimCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_pim");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_stop_pim, cb));
}


/* Unmarshall stop_pim */
void
XrlPimV0p1Client::unmarshall_stop_pim(
	const XrlError&	e, 
	XrlArgs*	a, 
	StopPimCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_cli(
	const char*	the_tgt, 
	const StartCliCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_cli");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_start_cli, cb));
}


/* Unmarshall start_cli */
void
XrlPimV0p1Client::unmarshall_start_cli(
	const XrlError&	e, 
	XrlArgs*	a, 
	StartCliCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_cli(
	const char*	the_tgt, 
	const StopCliCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_cli");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_stop_cli, cb));
}


/* Unmarshall stop_cli */
void
XrlPimV0p1Client::unmarshall_stop_cli(
	const XrlError&	e, 
	XrlArgs*	a, 
	StopCliCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_bsr(
	const char*	the_tgt, 
	const EnableBsrCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_bsr");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_enable_bsr, cb));
}


/* Unmarshall enable_bsr */
void
XrlPimV0p1Client::unmarshall_enable_bsr(
	const XrlError&	e, 
	XrlArgs*	a, 
	EnableBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_disable_bsr(
	const char*	the_tgt, 
	const DisableBsrCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_bsr");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_disable_bsr, cb));
}


/* Unmarshall disable_bsr */
void
XrlPimV0p1Client::unmarshall_disable_bsr(
	const XrlError&	e, 
	XrlArgs*	a, 
	DisableBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_bsr(
	const char*	the_tgt, 
	const StartBsrCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/start_bsr");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_start_bsr, cb));
}


/* Unmarshall start_bsr */
void
XrlPimV0p1Client::unmarshall_start_bsr(
	const XrlError&	e, 
	XrlArgs*	a, 
	StartBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_bsr(
	const char*	the_tgt, 
	const StopBsrCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/stop_bsr");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_stop_bsr, cb));
}


/* Unmarshall stop_bsr */
void
XrlPimV0p1Client::unmarshall_stop_bsr(
	const XrlError&	e, 
	XrlArgs*	a, 
	StopBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_scope_zone_by_vif_name4(
	const char*	the_tgt, 
	const IPv4Net&	scope_zone_id, 
	const string&	vif_name, 
	const AddConfigScopeZoneByVifName4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_scope_zone_by_vif_name4");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_name4, cb));
}


/* Unmarshall add_config_scope_zone_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_name4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigScopeZoneByVifName4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_scope_zone_by_vif_name6(
	const char*	the_tgt, 
	const IPv6Net&	scope_zone_id, 
	const string&	vif_name, 
	const AddConfigScopeZoneByVifName6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_scope_zone_by_vif_name6");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_name6, cb));
}


/* Unmarshall add_config_scope_zone_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_name6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigScopeZoneByVifName6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_scope_zone_by_vif_addr4(
	const char*	the_tgt, 
	const IPv4Net&	scope_zone_id, 
	const IPv4&	vif_addr, 
	const AddConfigScopeZoneByVifAddr4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_scope_zone_by_vif_addr4");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("vif_addr", vif_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_addr4, cb));
}


/* Unmarshall add_config_scope_zone_by_vif_addr4 */
void
XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_addr4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigScopeZoneByVifAddr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_scope_zone_by_vif_addr6(
	const char*	the_tgt, 
	const IPv6Net&	scope_zone_id, 
	const IPv6&	vif_addr, 
	const AddConfigScopeZoneByVifAddr6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_scope_zone_by_vif_addr6");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("vif_addr", vif_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_addr6, cb));
}


/* Unmarshall add_config_scope_zone_by_vif_addr6 */
void
XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_addr6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigScopeZoneByVifAddr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_scope_zone_by_vif_name4(
	const char*	the_tgt, 
	const IPv4Net&	scope_zone_id, 
	const string&	vif_name, 
	const DeleteConfigScopeZoneByVifName4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_scope_zone_by_vif_name4");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_name4, cb));
}


/* Unmarshall delete_config_scope_zone_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_name4(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigScopeZoneByVifName4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_scope_zone_by_vif_name6(
	const char*	the_tgt, 
	const IPv6Net&	scope_zone_id, 
	const string&	vif_name, 
	const DeleteConfigScopeZoneByVifName6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_scope_zone_by_vif_name6");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_name6, cb));
}


/* Unmarshall delete_config_scope_zone_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_name6(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigScopeZoneByVifName6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_scope_zone_by_vif_addr4(
	const char*	the_tgt, 
	const IPv4Net&	scope_zone_id, 
	const IPv4&	vif_addr, 
	const DeleteConfigScopeZoneByVifAddr4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_scope_zone_by_vif_addr4");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("vif_addr", vif_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_addr4, cb));
}


/* Unmarshall delete_config_scope_zone_by_vif_addr4 */
void
XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_addr4(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigScopeZoneByVifAddr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_scope_zone_by_vif_addr6(
	const char*	the_tgt, 
	const IPv6Net&	scope_zone_id, 
	const IPv6&	vif_addr, 
	const DeleteConfigScopeZoneByVifAddr6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_scope_zone_by_vif_addr6");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("vif_addr", vif_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_addr6, cb));
}


/* Unmarshall delete_config_scope_zone_by_vif_addr6 */
void
XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_addr6(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigScopeZoneByVifAddr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr_by_vif_name4(
	const char*	the_tgt, 
	const IPv4Net&	scope_zone_id, 
	const bool&	is_scope_zone, 
	const string&	vif_name, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const AddConfigCandBsrByVifName4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_bsr_by_vif_name4");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("vif_name", vif_name);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_cand_bsr_by_vif_name4, cb));
}


/* Unmarshall add_config_cand_bsr_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_bsr_by_vif_name4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigCandBsrByVifName4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr_by_vif_name6(
	const char*	the_tgt, 
	const IPv6Net&	scope_zone_id, 
	const bool&	is_scope_zone, 
	const string&	vif_name, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const AddConfigCandBsrByVifName6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_bsr_by_vif_name6");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("vif_name", vif_name);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_cand_bsr_by_vif_name6, cb));
}


/* Unmarshall add_config_cand_bsr_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_bsr_by_vif_name6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigCandBsrByVifName6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr_by_addr4(
	const char*	the_tgt, 
	const IPv4Net&	scope_zone_id, 
	const bool&	is_scope_zone, 
	const IPv4&	cand_bsr_addr, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const AddConfigCandBsrByAddr4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_bsr_by_addr4");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("cand_bsr_addr", cand_bsr_addr);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_cand_bsr_by_addr4, cb));
}


/* Unmarshall add_config_cand_bsr_by_addr4 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_bsr_by_addr4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigCandBsrByAddr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr_by_addr6(
	const char*	the_tgt, 
	const IPv6Net&	scope_zone_id, 
	const bool&	is_scope_zone, 
	const IPv6&	cand_bsr_addr, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const AddConfigCandBsrByAddr6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_bsr_by_addr6");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("cand_bsr_addr", cand_bsr_addr);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_cand_bsr_by_addr6, cb));
}


/* Unmarshall add_config_cand_bsr_by_addr6 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_bsr_by_addr6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigCandBsrByAddr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_bsr4(
	const char*	the_tgt, 
	const IPv4Net&	scope_zone_id, 
	const bool&	is_scope_zone, 
	const DeleteConfigCandBsr4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_bsr4");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("is_scope_zone", is_scope_zone);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_cand_bsr4, cb));
}


/* Unmarshall delete_config_cand_bsr4 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_bsr4(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigCandBsr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_bsr6(
	const char*	the_tgt, 
	const IPv6Net&	scope_zone_id, 
	const bool&	is_scope_zone, 
	const DeleteConfigCandBsr6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_bsr6");
    x.args().add("scope_zone_id", scope_zone_id);
    x.args().add("is_scope_zone", is_scope_zone);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_cand_bsr6, cb));
}


/* Unmarshall delete_config_cand_bsr6 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_bsr6(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigCandBsr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp_by_vif_name4(
	const char*	the_tgt, 
	const IPv4Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const string&	vif_name, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const AddConfigCandRpByVifName4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_rp_by_vif_name4");
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("vif_name", vif_name);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_cand_rp_by_vif_name4, cb));
}


/* Unmarshall add_config_cand_rp_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_rp_by_vif_name4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigCandRpByVifName4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp_by_vif_name6(
	const char*	the_tgt, 
	const IPv6Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const string&	vif_name, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const AddConfigCandRpByVifName6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_rp_by_vif_name6");
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("vif_name", vif_name);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_cand_rp_by_vif_name6, cb));
}


/* Unmarshall add_config_cand_rp_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_rp_by_vif_name6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigCandRpByVifName6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp_by_addr4(
	const char*	the_tgt, 
	const IPv4Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const IPv4&	cand_rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const AddConfigCandRpByAddr4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_rp_by_addr4");
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("cand_rp_addr", cand_rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_cand_rp_by_addr4, cb));
}


/* Unmarshall add_config_cand_rp_by_addr4 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_rp_by_addr4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigCandRpByAddr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp_by_addr6(
	const char*	the_tgt, 
	const IPv6Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const IPv6&	cand_rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const AddConfigCandRpByAddr6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_cand_rp_by_addr6");
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("cand_rp_addr", cand_rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_cand_rp_by_addr6, cb));
}


/* Unmarshall add_config_cand_rp_by_addr6 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_rp_by_addr6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigCandRpByAddr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp_by_vif_name4(
	const char*	the_tgt, 
	const IPv4Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const string&	vif_name, 
	const DeleteConfigCandRpByVifName4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_rp_by_vif_name4");
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_cand_rp_by_vif_name4, cb));
}


/* Unmarshall delete_config_cand_rp_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_rp_by_vif_name4(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigCandRpByVifName4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp_by_vif_name6(
	const char*	the_tgt, 
	const IPv6Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const string&	vif_name, 
	const DeleteConfigCandRpByVifName6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_rp_by_vif_name6");
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_cand_rp_by_vif_name6, cb));
}


/* Unmarshall delete_config_cand_rp_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_rp_by_vif_name6(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigCandRpByVifName6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp_by_addr4(
	const char*	the_tgt, 
	const IPv4Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const IPv4&	cand_rp_addr, 
	const DeleteConfigCandRpByAddr4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_rp_by_addr4");
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("cand_rp_addr", cand_rp_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_cand_rp_by_addr4, cb));
}


/* Unmarshall delete_config_cand_rp_by_addr4 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_rp_by_addr4(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigCandRpByAddr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp_by_addr6(
	const char*	the_tgt, 
	const IPv6Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const IPv6&	cand_rp_addr, 
	const DeleteConfigCandRpByAddr6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_cand_rp_by_addr6");
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("cand_rp_addr", cand_rp_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_cand_rp_by_addr6, cb));
}


/* Unmarshall delete_config_cand_rp_by_addr6 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_rp_by_addr6(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigCandRpByAddr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_static_rp4(
	const char*	the_tgt, 
	const IPv4Net&	group_prefix, 
	const IPv4&	rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	hash_masklen, 
	const AddConfigStaticRp4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_static_rp4");
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_static_rp4, cb));
}


/* Unmarshall add_config_static_rp4 */
void
XrlPimV0p1Client::unmarshall_add_config_static_rp4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigStaticRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_static_rp6(
	const char*	the_tgt, 
	const IPv6Net&	group_prefix, 
	const IPv6&	rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	hash_masklen, 
	const AddConfigStaticRp6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_config_static_rp6");
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("hash_masklen", hash_masklen);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_config_static_rp6, cb));
}


/* Unmarshall add_config_static_rp6 */
void
XrlPimV0p1Client::unmarshall_add_config_static_rp6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddConfigStaticRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_static_rp4(
	const char*	the_tgt, 
	const IPv4Net&	group_prefix, 
	const IPv4&	rp_addr, 
	const DeleteConfigStaticRp4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_static_rp4");
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_static_rp4, cb));
}


/* Unmarshall delete_config_static_rp4 */
void
XrlPimV0p1Client::unmarshall_delete_config_static_rp4(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigStaticRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_static_rp6(
	const char*	the_tgt, 
	const IPv6Net&	group_prefix, 
	const IPv6&	rp_addr, 
	const DeleteConfigStaticRp6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/delete_config_static_rp6");
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_delete_config_static_rp6, cb));
}


/* Unmarshall delete_config_static_rp6 */
void
XrlPimV0p1Client::unmarshall_delete_config_static_rp6(
	const XrlError&	e, 
	XrlArgs*	a, 
	DeleteConfigStaticRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_config_static_rp_done(
	const char*	the_tgt, 
	const ConfigStaticRpDoneCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/config_static_rp_done");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_config_static_rp_done, cb));
}


/* Unmarshall config_static_rp_done */
void
XrlPimV0p1Client::unmarshall_config_static_rp_done(
	const XrlError&	e, 
	XrlArgs*	a, 
	ConfigStaticRpDoneCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_proto_version(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifProtoVersionCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_proto_version");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_proto_version, cb));
}


/* Unmarshall get_vif_proto_version */
void
XrlPimV0p1Client::unmarshall_get_vif_proto_version(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifProtoVersionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t proto_version;
    try {
	a->get("proto_version", proto_version);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &proto_version);
}

bool
XrlPimV0p1Client::send_set_vif_proto_version(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	proto_version, 
	const SetVifProtoVersionCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_proto_version");
    x.args().add("vif_name", vif_name);
    x.args().add("proto_version", proto_version);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_proto_version, cb));
}


/* Unmarshall set_vif_proto_version */
void
XrlPimV0p1Client::unmarshall_set_vif_proto_version(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifProtoVersionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_proto_version(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifProtoVersionCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_proto_version");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_proto_version, cb));
}


/* Unmarshall reset_vif_proto_version */
void
XrlPimV0p1Client::unmarshall_reset_vif_proto_version(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifProtoVersionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_hello_triggered_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifHelloTriggeredDelayCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_hello_triggered_delay");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_hello_triggered_delay, cb));
}


/* Unmarshall get_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall_get_vif_hello_triggered_delay(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifHelloTriggeredDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t hello_triggered_delay;
    try {
	a->get("hello_triggered_delay", hello_triggered_delay);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &hello_triggered_delay);
}

bool
XrlPimV0p1Client::send_set_vif_hello_triggered_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	hello_triggered_delay, 
	const SetVifHelloTriggeredDelayCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_hello_triggered_delay");
    x.args().add("vif_name", vif_name);
    x.args().add("hello_triggered_delay", hello_triggered_delay);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_hello_triggered_delay, cb));
}


/* Unmarshall set_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall_set_vif_hello_triggered_delay(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifHelloTriggeredDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_triggered_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifHelloTriggeredDelayCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_hello_triggered_delay");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_hello_triggered_delay, cb));
}


/* Unmarshall reset_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall_reset_vif_hello_triggered_delay(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifHelloTriggeredDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_hello_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifHelloPeriodCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_hello_period");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_hello_period, cb));
}


/* Unmarshall get_vif_hello_period */
void
XrlPimV0p1Client::unmarshall_get_vif_hello_period(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifHelloPeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t hello_period;
    try {
	a->get("hello_period", hello_period);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &hello_period);
}

bool
XrlPimV0p1Client::send_set_vif_hello_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	hello_period, 
	const SetVifHelloPeriodCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_hello_period");
    x.args().add("vif_name", vif_name);
    x.args().add("hello_period", hello_period);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_hello_period, cb));
}


/* Unmarshall set_vif_hello_period */
void
XrlPimV0p1Client::unmarshall_set_vif_hello_period(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifHelloPeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifHelloPeriodCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_hello_period");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_hello_period, cb));
}


/* Unmarshall reset_vif_hello_period */
void
XrlPimV0p1Client::unmarshall_reset_vif_hello_period(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifHelloPeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_hello_holdtime(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifHelloHoldtimeCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_hello_holdtime");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_hello_holdtime, cb));
}


/* Unmarshall get_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall_get_vif_hello_holdtime(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifHelloHoldtimeCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t hello_holdtime;
    try {
	a->get("hello_holdtime", hello_holdtime);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &hello_holdtime);
}

bool
XrlPimV0p1Client::send_set_vif_hello_holdtime(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	hello_holdtime, 
	const SetVifHelloHoldtimeCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_hello_holdtime");
    x.args().add("vif_name", vif_name);
    x.args().add("hello_holdtime", hello_holdtime);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_hello_holdtime, cb));
}


/* Unmarshall set_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall_set_vif_hello_holdtime(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifHelloHoldtimeCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_holdtime(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifHelloHoldtimeCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_hello_holdtime");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_hello_holdtime, cb));
}


/* Unmarshall reset_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall_reset_vif_hello_holdtime(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifHelloHoldtimeCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_dr_priority(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifDrPriorityCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_dr_priority");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_dr_priority, cb));
}


/* Unmarshall get_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall_get_vif_dr_priority(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifDrPriorityCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t dr_priority;
    try {
	a->get("dr_priority", dr_priority);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &dr_priority);
}

bool
XrlPimV0p1Client::send_set_vif_dr_priority(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	dr_priority, 
	const SetVifDrPriorityCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_dr_priority");
    x.args().add("vif_name", vif_name);
    x.args().add("dr_priority", dr_priority);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_dr_priority, cb));
}


/* Unmarshall set_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall_set_vif_dr_priority(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifDrPriorityCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_dr_priority(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifDrPriorityCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_dr_priority");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_dr_priority, cb));
}


/* Unmarshall reset_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall_reset_vif_dr_priority(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifDrPriorityCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_lan_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifLanDelayCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_lan_delay");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_lan_delay, cb));
}


/* Unmarshall get_vif_lan_delay */
void
XrlPimV0p1Client::unmarshall_get_vif_lan_delay(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifLanDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t lan_delay;
    try {
	a->get("lan_delay", lan_delay);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &lan_delay);
}

bool
XrlPimV0p1Client::send_set_vif_lan_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	lan_delay, 
	const SetVifLanDelayCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_lan_delay");
    x.args().add("vif_name", vif_name);
    x.args().add("lan_delay", lan_delay);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_lan_delay, cb));
}


/* Unmarshall set_vif_lan_delay */
void
XrlPimV0p1Client::unmarshall_set_vif_lan_delay(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifLanDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_lan_delay(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifLanDelayCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_lan_delay");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_lan_delay, cb));
}


/* Unmarshall reset_vif_lan_delay */
void
XrlPimV0p1Client::unmarshall_reset_vif_lan_delay(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifLanDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_override_interval(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifOverrideIntervalCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_override_interval");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_override_interval, cb));
}


/* Unmarshall get_vif_override_interval */
void
XrlPimV0p1Client::unmarshall_get_vif_override_interval(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifOverrideIntervalCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t override_interval;
    try {
	a->get("override_interval", override_interval);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &override_interval);
}

bool
XrlPimV0p1Client::send_set_vif_override_interval(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	override_interval, 
	const SetVifOverrideIntervalCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_override_interval");
    x.args().add("vif_name", vif_name);
    x.args().add("override_interval", override_interval);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_override_interval, cb));
}


/* Unmarshall set_vif_override_interval */
void
XrlPimV0p1Client::unmarshall_set_vif_override_interval(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifOverrideIntervalCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_override_interval(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifOverrideIntervalCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_override_interval");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_override_interval, cb));
}


/* Unmarshall reset_vif_override_interval */
void
XrlPimV0p1Client::unmarshall_reset_vif_override_interval(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifOverrideIntervalCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_is_tracking_support_disabled(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifIsTrackingSupportDisabledCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_is_tracking_support_disabled");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_is_tracking_support_disabled, cb));
}


/* Unmarshall get_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall_get_vif_is_tracking_support_disabled(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifIsTrackingSupportDisabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool is_tracking_support_disabled;
    try {
	a->get("is_tracking_support_disabled", is_tracking_support_disabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &is_tracking_support_disabled);
}

bool
XrlPimV0p1Client::send_set_vif_is_tracking_support_disabled(
	const char*	the_tgt, 
	const string&	vif_name, 
	const bool&	is_tracking_support_disabled, 
	const SetVifIsTrackingSupportDisabledCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_is_tracking_support_disabled");
    x.args().add("vif_name", vif_name);
    x.args().add("is_tracking_support_disabled", is_tracking_support_disabled);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_is_tracking_support_disabled, cb));
}


/* Unmarshall set_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall_set_vif_is_tracking_support_disabled(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifIsTrackingSupportDisabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_is_tracking_support_disabled(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifIsTrackingSupportDisabledCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_is_tracking_support_disabled");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_is_tracking_support_disabled, cb));
}


/* Unmarshall reset_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall_reset_vif_is_tracking_support_disabled(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifIsTrackingSupportDisabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_accept_nohello_neighbors(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifAcceptNohelloNeighborsCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_accept_nohello_neighbors");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_accept_nohello_neighbors, cb));
}


/* Unmarshall get_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall_get_vif_accept_nohello_neighbors(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifAcceptNohelloNeighborsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool accept_nohello_neighbors;
    try {
	a->get("accept_nohello_neighbors", accept_nohello_neighbors);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &accept_nohello_neighbors);
}

bool
XrlPimV0p1Client::send_set_vif_accept_nohello_neighbors(
	const char*	the_tgt, 
	const string&	vif_name, 
	const bool&	accept_nohello_neighbors, 
	const SetVifAcceptNohelloNeighborsCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_accept_nohello_neighbors");
    x.args().add("vif_name", vif_name);
    x.args().add("accept_nohello_neighbors", accept_nohello_neighbors);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_accept_nohello_neighbors, cb));
}


/* Unmarshall set_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall_set_vif_accept_nohello_neighbors(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifAcceptNohelloNeighborsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_accept_nohello_neighbors(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifAcceptNohelloNeighborsCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_accept_nohello_neighbors");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_accept_nohello_neighbors, cb));
}


/* Unmarshall reset_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall_reset_vif_accept_nohello_neighbors(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifAcceptNohelloNeighborsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_join_prune_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const GetVifJoinPrunePeriodCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_vif_join_prune_period");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_vif_join_prune_period, cb));
}


/* Unmarshall get_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall_get_vif_join_prune_period(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetVifJoinPrunePeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t join_prune_period;
    try {
	a->get("join_prune_period", join_prune_period);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &join_prune_period);
}

bool
XrlPimV0p1Client::send_set_vif_join_prune_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const uint32_t&	join_prune_period, 
	const SetVifJoinPrunePeriodCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_vif_join_prune_period");
    x.args().add("vif_name", vif_name);
    x.args().add("join_prune_period", join_prune_period);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_vif_join_prune_period, cb));
}


/* Unmarshall set_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall_set_vif_join_prune_period(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetVifJoinPrunePeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_join_prune_period(
	const char*	the_tgt, 
	const string&	vif_name, 
	const ResetVifJoinPrunePeriodCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_vif_join_prune_period");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_vif_join_prune_period, cb));
}


/* Unmarshall reset_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall_reset_vif_join_prune_period(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetVifJoinPrunePeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_switch_to_spt_threshold(
	const char*	the_tgt, 
	const GetSwitchToSptThresholdCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/get_switch_to_spt_threshold");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_get_switch_to_spt_threshold, cb));
}


/* Unmarshall get_switch_to_spt_threshold */
void
XrlPimV0p1Client::unmarshall_get_switch_to_spt_threshold(
	const XrlError&	e, 
	XrlArgs*	a, 
	GetSwitchToSptThresholdCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    bool is_enabled;
    uint32_t interval_sec;
    uint32_t bytes;
    try {
	a->get("is_enabled", is_enabled);
	a->get("interval_sec", interval_sec);
	a->get("bytes", bytes);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &is_enabled, &interval_sec, &bytes);
}

bool
XrlPimV0p1Client::send_set_switch_to_spt_threshold(
	const char*	the_tgt, 
	const bool&	is_enabled, 
	const uint32_t&	interval_sec, 
	const uint32_t&	bytes, 
	const SetSwitchToSptThresholdCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/set_switch_to_spt_threshold");
    x.args().add("is_enabled", is_enabled);
    x.args().add("interval_sec", interval_sec);
    x.args().add("bytes", bytes);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_set_switch_to_spt_threshold, cb));
}


/* Unmarshall set_switch_to_spt_threshold */
void
XrlPimV0p1Client::unmarshall_set_switch_to_spt_threshold(
	const XrlError&	e, 
	XrlArgs*	a, 
	SetSwitchToSptThresholdCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_switch_to_spt_threshold(
	const char*	the_tgt, 
	const ResetSwitchToSptThresholdCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/reset_switch_to_spt_threshold");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_reset_switch_to_spt_threshold, cb));
}


/* Unmarshall reset_switch_to_spt_threshold */
void
XrlPimV0p1Client::unmarshall_reset_switch_to_spt_threshold(
	const XrlError&	e, 
	XrlArgs*	a, 
	ResetSwitchToSptThresholdCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_log_trace(
	const char*	the_tgt, 
	const EnableLogTraceCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/enable_log_trace");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_enable_log_trace, cb));
}


/* Unmarshall enable_log_trace */
void
XrlPimV0p1Client::unmarshall_enable_log_trace(
	const XrlError&	e, 
	XrlArgs*	a, 
	EnableLogTraceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_disable_log_trace(
	const char*	the_tgt, 
	const DisableLogTraceCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/disable_log_trace");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_disable_log_trace, cb));
}


/* Unmarshall disable_log_trace */
void
XrlPimV0p1Client::unmarshall_disable_log_trace(
	const XrlError&	e, 
	XrlArgs*	a, 
	DisableLogTraceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_jp_entry4(
	const char*	the_tgt, 
	const IPv4&	source_addr, 
	const IPv4&	group_addr, 
	const uint32_t&	group_masklen, 
	const string&	mrt_entry_type, 
	const string&	action_jp, 
	const uint32_t&	holdtime, 
	const bool&	new_group_bool, 
	const AddTestJpEntry4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_jp_entry4");
    x.args().add("source_addr", source_addr);
    x.args().add("group_addr", group_addr);
    x.args().add("group_masklen", group_masklen);
    x.args().add("mrt_entry_type", mrt_entry_type);
    x.args().add("action_jp", action_jp);
    x.args().add("holdtime", holdtime);
    x.args().add("new_group_bool", new_group_bool);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_test_jp_entry4, cb));
}


/* Unmarshall add_test_jp_entry4 */
void
XrlPimV0p1Client::unmarshall_add_test_jp_entry4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddTestJpEntry4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_jp_entry6(
	const char*	the_tgt, 
	const IPv6&	source_addr, 
	const IPv6&	group_addr, 
	const uint32_t&	group_masklen, 
	const string&	mrt_entry_type, 
	const string&	action_jp, 
	const uint32_t&	holdtime, 
	const bool&	new_group_bool, 
	const AddTestJpEntry6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_jp_entry6");
    x.args().add("source_addr", source_addr);
    x.args().add("group_addr", group_addr);
    x.args().add("group_masklen", group_masklen);
    x.args().add("mrt_entry_type", mrt_entry_type);
    x.args().add("action_jp", action_jp);
    x.args().add("holdtime", holdtime);
    x.args().add("new_group_bool", new_group_bool);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_test_jp_entry6, cb));
}


/* Unmarshall add_test_jp_entry6 */
void
XrlPimV0p1Client::unmarshall_add_test_jp_entry6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddTestJpEntry6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_jp_entry4(
	const char*	the_tgt, 
	const IPv4&	nbr_addr, 
	const SendTestJpEntry4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_jp_entry4");
    x.args().add("nbr_addr", nbr_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_send_test_jp_entry4, cb));
}


/* Unmarshall send_test_jp_entry4 */
void
XrlPimV0p1Client::unmarshall_send_test_jp_entry4(
	const XrlError&	e, 
	XrlArgs*	a, 
	SendTestJpEntry4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_jp_entry6(
	const char*	the_tgt, 
	const IPv6&	nbr_addr, 
	const SendTestJpEntry6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_jp_entry6");
    x.args().add("nbr_addr", nbr_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_send_test_jp_entry6, cb));
}


/* Unmarshall send_test_jp_entry6 */
void
XrlPimV0p1Client::unmarshall_send_test_jp_entry6(
	const XrlError&	e, 
	XrlArgs*	a, 
	SendTestJpEntry6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_assert4(
	const char*	the_tgt, 
	const string&	vif_name, 
	const IPv4&	source_addr, 
	const IPv4&	group_addr, 
	const bool&	rpt_bit, 
	const uint32_t&	metric_preference, 
	const uint32_t&	metric, 
	const SendTestAssert4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_assert4");
    x.args().add("vif_name", vif_name);
    x.args().add("source_addr", source_addr);
    x.args().add("group_addr", group_addr);
    x.args().add("rpt_bit", rpt_bit);
    x.args().add("metric_preference", metric_preference);
    x.args().add("metric", metric);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_send_test_assert4, cb));
}


/* Unmarshall send_test_assert4 */
void
XrlPimV0p1Client::unmarshall_send_test_assert4(
	const XrlError&	e, 
	XrlArgs*	a, 
	SendTestAssert4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_assert6(
	const char*	the_tgt, 
	const string&	vif_name, 
	const IPv6&	source_addr, 
	const IPv6&	group_addr, 
	const bool&	rpt_bit, 
	const uint32_t&	metric_preference, 
	const uint32_t&	metric, 
	const SendTestAssert6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_assert6");
    x.args().add("vif_name", vif_name);
    x.args().add("source_addr", source_addr);
    x.args().add("group_addr", group_addr);
    x.args().add("rpt_bit", rpt_bit);
    x.args().add("metric_preference", metric_preference);
    x.args().add("metric", metric);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_send_test_assert6, cb));
}


/* Unmarshall send_test_assert6 */
void
XrlPimV0p1Client::unmarshall_send_test_assert6(
	const XrlError&	e, 
	XrlArgs*	a, 
	SendTestAssert6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_zone4(
	const char*	the_tgt, 
	const IPv4Net&	zone_id_scope_zone_prefix, 
	const bool&	zone_id_is_scope_zone, 
	const IPv4&	bsr_addr, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const uint32_t&	fragment_tag, 
	const AddTestBsrZone4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_bsr_zone4");
    x.args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
    x.args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
    x.args().add("bsr_addr", bsr_addr);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    x.args().add("fragment_tag", fragment_tag);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_test_bsr_zone4, cb));
}


/* Unmarshall add_test_bsr_zone4 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_zone4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddTestBsrZone4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_zone6(
	const char*	the_tgt, 
	const IPv6Net&	zone_id_scope_zone_prefix, 
	const bool&	zone_id_is_scope_zone, 
	const IPv6&	bsr_addr, 
	const uint32_t&	bsr_priority, 
	const uint32_t&	hash_masklen, 
	const uint32_t&	fragment_tag, 
	const AddTestBsrZone6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_bsr_zone6");
    x.args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
    x.args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
    x.args().add("bsr_addr", bsr_addr);
    x.args().add("bsr_priority", bsr_priority);
    x.args().add("hash_masklen", hash_masklen);
    x.args().add("fragment_tag", fragment_tag);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_test_bsr_zone6, cb));
}


/* Unmarshall add_test_bsr_zone6 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_zone6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddTestBsrZone6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_group_prefix4(
	const char*	the_tgt, 
	const IPv4Net&	zone_id_scope_zone_prefix, 
	const bool&	zone_id_is_scope_zone, 
	const IPv4Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const uint32_t&	expected_rp_count, 
	const AddTestBsrGroupPrefix4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_bsr_group_prefix4");
    x.args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
    x.args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("expected_rp_count", expected_rp_count);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_test_bsr_group_prefix4, cb));
}


/* Unmarshall add_test_bsr_group_prefix4 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_group_prefix4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddTestBsrGroupPrefix4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_group_prefix6(
	const char*	the_tgt, 
	const IPv6Net&	zone_id_scope_zone_prefix, 
	const bool&	zone_id_is_scope_zone, 
	const IPv6Net&	group_prefix, 
	const bool&	is_scope_zone, 
	const uint32_t&	expected_rp_count, 
	const AddTestBsrGroupPrefix6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_bsr_group_prefix6");
    x.args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
    x.args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("is_scope_zone", is_scope_zone);
    x.args().add("expected_rp_count", expected_rp_count);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_test_bsr_group_prefix6, cb));
}


/* Unmarshall add_test_bsr_group_prefix6 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_group_prefix6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddTestBsrGroupPrefix6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_rp4(
	const char*	the_tgt, 
	const IPv4Net&	zone_id_scope_zone_prefix, 
	const bool&	zone_id_is_scope_zone, 
	const IPv4Net&	group_prefix, 
	const IPv4&	rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const AddTestBsrRp4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_bsr_rp4");
    x.args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
    x.args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_test_bsr_rp4, cb));
}


/* Unmarshall add_test_bsr_rp4 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_rp4(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddTestBsrRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_rp6(
	const char*	the_tgt, 
	const IPv6Net&	zone_id_scope_zone_prefix, 
	const bool&	zone_id_is_scope_zone, 
	const IPv6Net&	group_prefix, 
	const IPv6&	rp_addr, 
	const uint32_t&	rp_priority, 
	const uint32_t&	rp_holdtime, 
	const AddTestBsrRp6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/add_test_bsr_rp6");
    x.args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
    x.args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
    x.args().add("group_prefix", group_prefix);
    x.args().add("rp_addr", rp_addr);
    x.args().add("rp_priority", rp_priority);
    x.args().add("rp_holdtime", rp_holdtime);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_add_test_bsr_rp6, cb));
}


/* Unmarshall add_test_bsr_rp6 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_rp6(
	const XrlError&	e, 
	XrlArgs*	a, 
	AddTestBsrRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_bootstrap(
	const char*	the_tgt, 
	const string&	vif_name, 
	const SendTestBootstrapCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_bootstrap");
    x.args().add("vif_name", vif_name);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_send_test_bootstrap, cb));
}


/* Unmarshall send_test_bootstrap */
void
XrlPimV0p1Client::unmarshall_send_test_bootstrap(
	const XrlError&	e, 
	XrlArgs*	a, 
	SendTestBootstrapCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_bootstrap_by_dest4(
	const char*	the_tgt, 
	const string&	vif_name, 
	const IPv4&	dest_addr, 
	const SendTestBootstrapByDest4CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_bootstrap_by_dest4");
    x.args().add("vif_name", vif_name);
    x.args().add("dest_addr", dest_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_send_test_bootstrap_by_dest4, cb));
}


/* Unmarshall send_test_bootstrap_by_dest4 */
void
XrlPimV0p1Client::unmarshall_send_test_bootstrap_by_dest4(
	const XrlError&	e, 
	XrlArgs*	a, 
	SendTestBootstrapByDest4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_bootstrap_by_dest6(
	const char*	the_tgt, 
	const string&	vif_name, 
	const IPv6&	dest_addr, 
	const SendTestBootstrapByDest6CB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_bootstrap_by_dest6");
    x.args().add("vif_name", vif_name);
    x.args().add("dest_addr", dest_addr);
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_send_test_bootstrap_by_dest6, cb));
}


/* Unmarshall send_test_bootstrap_by_dest6 */
void
XrlPimV0p1Client::unmarshall_send_test_bootstrap_by_dest6(
	const XrlError&	e, 
	XrlArgs*	a, 
	SendTestBootstrapByDest6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_cand_rp_adv(
	const char*	the_tgt, 
	const SendTestCandRpAdvCB&	cb
)
{
    Xrl x(the_tgt, "pim/0.1/send_test_cand_rp_adv");
    return _sender->send(x, callback(this, &XrlPimV0p1Client::unmarshall_send_test_cand_rp_adv, cb));
}


/* Unmarshall send_test_cand_rp_adv */
void
XrlPimV0p1Client::unmarshall_send_test_cand_rp_adv(
	const XrlError&	e, 
	XrlArgs*	a, 
	SendTestCandRpAdvCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}
