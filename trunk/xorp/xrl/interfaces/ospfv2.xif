/* $XORP: xorp/xrl/interfaces/ospfv2.xif,v 1.18 2006/03/10 04:35:22 atanu Exp $ */

/*
 * OSPF v2 protocol XRL interface.
 */

interface ospfv2/0.1 {
    
    /**
     * Set router id 
     */
    set_router_id ? id:ipv4

    /**
     * Set RFC 1583 compatibility.
     */
    set_rfc1583_compatibility ? compatibility:bool

    /**
     * Set the router alert in the IP options.
     */
    set_ip_router_alert ? ip_router_alert:bool

    /**
     * Create an area.
     *
     * @param area id of the area
     * @param type of area "border", "stub", "nssa"
     */
    create_area_router ? area:ipv4 \
		       & type:txt

    /**
     * Change area type.
     *
     * @param area id of the area
     * @param type of area "border", "stub", "nssa"
     */
    change_area_router_type ?  area:ipv4 \
		       & type:txt

    /**
     * Destroy area.
     *
     * @param area id of the area
     */
    destroy_area_router ? area:ipv4

    /**
     * Create a binding to an interface.
     *
     * @param ifname the interface that owns vif that has address.
     * @param vifname virtual interface owning address.
     * @param addr the address to be added.
     * @param prefix_len the prefix length XXX temporary.
     * @param mtu maximum transmission unit XXX temporary.
     * @param type of link "p2p", "broadcast", "nbma", "p2m", "vlink"
     */
    create_peer ? ifname:txt \
		& vifname:txt \
		& addr:ipv4 \
		& prefix_len:u32 \
		& mtu:u32 \
		& type:txt \
		& area:ipv4  

    /**
     * Delete peer.
     *
     */
    delete_peer ? ifname:txt \
		& vifname:txt

    /**
     * Set the peer state up or down.
     */
    set_peer_state ? ifname:txt \
		   & vifname:txt \
		   & enable:bool

    /**
     * Add a neighbour to the peer.
     */
    add_neighbour ? ifname:txt \
		  & vifname:txt \
		  & area:ipv4 \
		  & neighbour_address:ipv4 \
		  & neighbour_id:ipv4

    /**
     * Remove a neighbour from the peer.
     */
    remove_neighbour ? ifname:txt \
		  & vifname:txt \
		  & area:ipv4 \
		  & neighbour_address:ipv4 \
		  & neighbour_id:ipv4

    /**
     * Create a virtual link.
     *
     * @param neighbour_id the router ID of the other end of the link.
     * @param area in which an attempt has been made to configure a virtual
     *	link it has to be the backbone. Its just being passed in so it can
     * be checked by the protocol.
     */
    create_virtual_link ? neighbour_id:ipv4 \
			& area:ipv4

    /**
     * Delete virtual link
     *
     * @param neighbour_id the router ID of the other end of the link.
     */
    delete_virtual_link ? neighbour_id:ipv4
     
    /**
     * The area through which the virtual link transits.
     *
     * @param neighbour_id the router ID of the other end of the link.
     * @param transit_area that the virtual link transits.
     */
    transit_area_virtual_link ? neighbour_id:ipv4 \
			& transit_area:ipv4

    /**
     * The edge cost of this interface.
     */
    set_interface_cost ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & cost:u32

    /**
     * 	RxmtInterval
     *	    The number of seconds between LSA retransmissions, for
     *	    adjacencies belonging to this interface.  Also used when
     *	    retransmitting Database Description and Link State Request
     *	    Packets.  This should be well over the expected round-trip
     *	    delay between any two routers on the attached network.  The
     *	    setting of this value should be conservative or needless
     *	    retransmissions will result.  Sample value for a local area
     *	    network: 5 seconds.
     *
     */
    set_retransmit_interval ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & interval:u32

    /**
     * The estimated number of seconds it takes to transmit a Link
     * State Update Packet over this interface.  LSAs contained in the
     * Link State Update packet will have their age incremented by this
     * amount before transmission.  This value should take into account
     * transmission and propagation delays; it must be greater than
     * zero.
     */
    set_inftransdelay ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & delay:u32
    /**
     * Used in the designated router election.
     */
    set_router_priority ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & priority:u32

    /**
     * The interval between hello messages.
     */
    set_hello_interval ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & interval:u32

    /**
     * The period to wait before considering a router dead.
     */
    set_router_dead_interval ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & interval:u32

    /**
     * Set simple password authentication key.
     *
     * @param ifname the interface name.
     * @param vifname the vif name.
     * @param area the area ID.
     * @param password the authentication password.
     */
    set_simple_authentication_key	? ifname:txt			\
					& vifname:txt			\
					& area:ipv4			\
					& password:txt

    /**
     * Delete simple password authentication key.
     *
     * @param ifname the interface name.
     * @param vifname the vif name.
     * @param area the area ID.
     */
    delete_simple_authentication_key	? ifname:txt			\
					& vifname:txt			\
					& area:ipv4

    /**
     * Set MD5 authentication key.
     *
     * @param ifname the interface name.
     * @param vifname the vif name.
     * @param area the area ID.
     * @param key_id the key ID (must be an integer in the interval [0, 255]).
     * @param password the authentication password.
     * @param start_time the authentication start time (YYYY-MM-DD.HH:MM).
     * @param end_time the authentication end time (YYYY-MM-DD.HH:MM).
     */
    set_md5_authentication_key		? ifname:txt			\
					& vifname:txt			\
					& area:ipv4			\
					& key_id:u32			\
					& password:txt			\
					& start_time:txt		\
					& end_time:txt

    /**
     * Delete MD5 authentication key.
     *
     * @param ifname the interface name.
     * @param vifname the vif name.
     * @param area the area ID.
     * @param key_id the key ID (must be an integer in the interval [0, 255]).
     */
    delete_md5_authentication_key	? ifname:txt			\
					& vifname:txt			\
					& area:ipv4			\
					& key_id:u32


    /**
     * Toggle the passive status of an interface.
     */
    set_passive ? ifname:txt \
		& vifname:txt \
		& area:ipv4 \
		& passive:bool
	
    /**
     * If this is a "stub" or "nssa" area toggle the sending of a
     *	default route.
     */
    originate_default_route ? area:ipv4 \
		& enable:bool

    /**
     * Set the StubDefaultCost, the default cost sent in a default route in
     * a "stub" or "nssa" area.
     */
    stub_default_cost ? area:ipv4 \
		& cost:u32

    /**
     * Toggle the sending of summaries into "stub" or "nssa" areas.
     */
    summaries ? area:ipv4 \
		& enable:bool

    /**
     * Add area range.
     */
    area_range_add ? area:ipv4 \
		   & net:ipv4net \
		   & advertise:bool	

    /**
     * Delete area range.
     */
    area_range_delete ? area:ipv4 \
		      & net:ipv4net \

    /**
     *  Change the advertised state of this area.
     */
    area_range_change_state ? area:ipv4 \
			    & net:ipv4net \
			    & advertise:bool	


     /**
      * Enable/Disable tracing.
      *
      * @param tvar trace variable.
      * @param enable set to true to enable false to disable.
      */
     trace ? tvar:txt \
	& enable:bool

    /**
     * Get a single lsa from an area.
     *
     * A stateless mechanism to get LSAs. The client of this interface
     * should start from zero and continue to request LSAs
     * (incrementing index) until toohigh becomes true.
     *
     * @param area database that is being searched.
     * @param index into database starting from 0.
     * @param valid true if a LSA has been returned. Some index values
     *        do not contain LSAs. This should not be considered an error.
     * @param toohigh true if no more LSA exist after this index.
     * @param self if true this LSA was originated by this router.
     * @param lsa if valid is true the LSA at index.
     */
    get_lsa ? area:ipv4 \
	    & index:u32 \
	    -> \
	    valid:bool \
	    & toohigh:bool \
	    & self:bool \
	    & lsa:binary

    /**
     * Get a list of all the configured areas.
     *
     * @return area_ids list of value area_ids.  Each id is a u32.
     */
    get_area_list -> areas:list

    /**
     * Get the list of neighbours.
     *
     * @return a list of u32s that are an internal identifier that can be used
     *         with the get neighbour info call.
     */
    get_neighbour_list -> areas:list

    /**
     * Get information on a neighbour.
     *
     * @param nid neighbour ID returned by the get_neighbour_list.
     * @param address of neighbour in txt to allow IPv4 and IPv6.
     * @param interface with which the neighbour forms the adjacency.
     * @param state of the adjacency.
     * @param rid router ID of the neighbour.
     * @param priority of the neighbour (used for DR election).
     * @param deadtime time until neighbour is considered dead.
     * @param dead time in second before the adjacency will be considered down.
     * @param area the neighbour is in.
     * @param opt value in the neighbours hello packet.
     * @param dr designated router.
     * @param bdr backup designated router.
     * @param up time in seconds that the neigbour has been up.
     * @param adjacent time in seconds that there has been an adjacency.
     */
    get_neighbour_info ? nid:u32 \
	-> \
	address:txt \
	& interface:txt \
	& state:txt \
	& rid:ipv4 \
	& priority:u32 \
	& deadtime:u32 \
	& area:ipv4 \
	& opt:u32 \
	& dr:ipv4 \
	& bdr:ipv4 \
	& up:u32 \
	& adjacent:u32
}
