/* $XORP: xorp/xrl/interfaces/ospfv2.xif,v 1.5 2005/10/13 16:39:05 atanu Exp $ */

/*
 * OSPF v2 protocol XRL interface.
 */

interface ospfv2/0.1 {
    
    /**
     * Set router id 
     */
    set_router_id ? id:ipv4

    /**
     * Create an area.
     *
     * @param area id of the area
     * @param type of area "border", "stub", "nssa"
     */
    create_area_router ? area:ipv4 \
		       & type:txt \

    /**
     * Destroy area.
     *
     * @param area id of the area
     */
    destroy_area_router ? area:ipv4

    /**
     * Create a binding to an interface.
     *
     * @param ifname the interface that owns vif that has address.
     * @param vifname virtual interface owning address.
     * @param addr the address to be added.
     * @param prefix_len the prefix length XXX temporary.
     * @param mtu maximum transmission unit XXX temporary.
     * @param type of link "p2p", "broadcast", "nbma", "p2m", "vlink"
     */
    create_peer ? ifname:txt \
		& vifname:txt \
		& addr:ipv4 \
		& prefix_len:u32 \
		& mtu:u32 \
		& type:txt \
		& area:ipv4  

    /**
     * Delete peer.
     *
     */
    delete_peer ? ifname:txt \
		& vifname:txt

    /**
     * Set the peer state up or down.
     */
    set_peer_state ? ifname:txt \
		   & vifname:txt \
		   & enable:bool

    /**
     * Add a neighbour to the peer.
     */
    add_neighbour ? ifname:txt \
		  & vifname:txt \
		  & area:ipv4 \
		  & neighbour_address:ipv4 \
		  & neighbour_id:ipv4

    /**
     * Remove a neighbour from the peer.
     */
    remove_neighbour ? ifname:txt \
		  & vifname:txt \
		  & area:ipv4 \
		  & neighbour_address:ipv4 \
		  & neighbour_id:ipv4

    /**
     * Used in the designated router election.
     */
    set_router_priority ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & priority:u32

    /**
     * The interval between hello messages.
     */
    set_hello_interval ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & interval:u32

    /**
     * The period to wait before considering a router dead.
     */
    set_router_dead_interval ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & interval:u32

    /**
     * The edge cost of this interface.
     */
    set_interface_cost ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & cost:u32

    /**
     * The estimated number of seconds it takes to transmit a Link
     * State Update Packet over this interface.  LSAs contained in the
     * Link State Update packet will have their age incremented by this
     * amount before transmission.  This value should take into account
     * transmission and propagation delays; it must be greater than
     * zero.
     */
    set_inftransdelay ? ifname:txt \
		       & vifname:txt \
		       & area:ipv4 \
		       & delay:u32

    /**
     * Add area range.
     */
    area_range_add ? area:ipv4 \
		   & net:ipv4net \
		   & advertise:bool	

    /**
     * Delete area range.
     */
    area_range_delete ? area:ipv4 \
		      & net:ipv4net \

    /**
     *  Change the advertised state of this area.
     */
    area_range_change_state ? area:ipv4 \
			    & net:ipv4net \
			    & advertise:bool	


    /**
     * Get a single lsa from an area.
     *
     * A stateless mechanism to get LSAs. The client of this interface
     * should start from zero and continue to request LSAs
     * (incrementing index) until toohigh becomes true.
     *
     * @param area database that is being searched.
     * @param index into database starting from 0.
     * @param valid true if a LSA has been returned. Some index values
     *        do not contain LSAs. This should not be considered an error.
     * @param toohigh true if no more LSA exist after this index.
     * @param self if true this LSA was originated by this router.
     * @param lsa if valid is true the LSA at index.
     */
    get_lsa ? area:ipv4 \
	    & index:u32 \
	    -> \
	    valid:bool \
	    & toohigh:bool \
	    & self:bool \
	    & lsa:binary

    /**
     * Get a list of all the configured areas.
     *
     * @return area_ids list of value area_ids.  Each id is a u32.
     */
    get_area_list -> areas:list
}