/*
 * Copyright (c) 2001-2004 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#ident "$XORP: xorp/xrl/interfaces/policy_xif.cc,v 1.2 2004/12/14 18:37:07 atanu Exp $"

#include "policy_xif.hh"

bool
XrlPolicyV0p1Client::send_create_term(
	const char*	the_tgt,
	const string&	policy,
	const string&	term,
	const CreateTermCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/create_term");
    x.args().add("policy", policy);
    x.args().add("term", term);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_create_term, cb));
}


/* Unmarshall create_term */
void
XrlPolicyV0p1Client::unmarshall_create_term(
	const XrlError&	e,
	XrlArgs*	a,
	CreateTermCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_delete_term(
	const char*	the_tgt,
	const string&	policy,
	const string&	term,
	const DeleteTermCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/delete_term");
    x.args().add("policy", policy);
    x.args().add("term", term);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_delete_term, cb));
}


/* Unmarshall delete_term */
void
XrlPolicyV0p1Client::unmarshall_delete_term(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteTermCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_update_term_source(
	const char*	the_tgt,
	const string&	policy,
	const string&	term,
	const string&	source,
	const UpdateTermSourceCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/update_term_source");
    x.args().add("policy", policy);
    x.args().add("term", term);
    x.args().add("source", source);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_update_term_source, cb));
}


/* Unmarshall update_term_source */
void
XrlPolicyV0p1Client::unmarshall_update_term_source(
	const XrlError&	e,
	XrlArgs*	a,
	UpdateTermSourceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_update_term_dest(
	const char*	the_tgt,
	const string&	policy,
	const string&	term,
	const string&	dest,
	const UpdateTermDestCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/update_term_dest");
    x.args().add("policy", policy);
    x.args().add("term", term);
    x.args().add("dest", dest);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_update_term_dest, cb));
}


/* Unmarshall update_term_dest */
void
XrlPolicyV0p1Client::unmarshall_update_term_dest(
	const XrlError&	e,
	XrlArgs*	a,
	UpdateTermDestCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_update_term_action(
	const char*	the_tgt,
	const string&	policy,
	const string&	term,
	const string&	action,
	const UpdateTermActionCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/update_term_action");
    x.args().add("policy", policy);
    x.args().add("term", term);
    x.args().add("action", action);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_update_term_action, cb));
}


/* Unmarshall update_term_action */
void
XrlPolicyV0p1Client::unmarshall_update_term_action(
	const XrlError&	e,
	XrlArgs*	a,
	UpdateTermActionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_create_policy(
	const char*	the_tgt,
	const string&	policy,
	const CreatePolicyCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/create_policy");
    x.args().add("policy", policy);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_create_policy, cb));
}


/* Unmarshall create_policy */
void
XrlPolicyV0p1Client::unmarshall_create_policy(
	const XrlError&	e,
	XrlArgs*	a,
	CreatePolicyCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_delete_policy(
	const char*	the_tgt,
	const string&	policy,
	const DeletePolicyCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/delete_policy");
    x.args().add("policy", policy);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_delete_policy, cb));
}


/* Unmarshall delete_policy */
void
XrlPolicyV0p1Client::unmarshall_delete_policy(
	const XrlError&	e,
	XrlArgs*	a,
	DeletePolicyCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_create_set(
	const char*	the_tgt,
	const string&	set,
	const CreateSetCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/create_set");
    x.args().add("set", set);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_create_set, cb));
}


/* Unmarshall create_set */
void
XrlPolicyV0p1Client::unmarshall_create_set(
	const XrlError&	e,
	XrlArgs*	a,
	CreateSetCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_update_set(
	const char*	the_tgt,
	const string&	set,
	const string&	elements,
	const UpdateSetCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/update_set");
    x.args().add("set", set);
    x.args().add("elements", elements);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_update_set, cb));
}


/* Unmarshall update_set */
void
XrlPolicyV0p1Client::unmarshall_update_set(
	const XrlError&	e,
	XrlArgs*	a,
	UpdateSetCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_delete_set(
	const char*	the_tgt,
	const string&	set,
	const DeleteSetCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/delete_set");
    x.args().add("set", set);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_delete_set, cb));
}


/* Unmarshall delete_set */
void
XrlPolicyV0p1Client::unmarshall_delete_set(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteSetCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_done_global_policy_conf(
	const char*	the_tgt,
	const DoneGlobalPolicyConfCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/done_global_policy_conf");
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_done_global_policy_conf, cb));
}


/* Unmarshall done_global_policy_conf */
void
XrlPolicyV0p1Client::unmarshall_done_global_policy_conf(
	const XrlError&	e,
	XrlArgs*	a,
	DoneGlobalPolicyConfCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_import(
	const char*	the_tgt,
	const string&	protocol,
	const string&	policies,
	const ImportCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/import");
    x.args().add("protocol", protocol);
    x.args().add("policies", policies);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_import, cb));
}


/* Unmarshall import */
void
XrlPolicyV0p1Client::unmarshall_import(
	const XrlError&	e,
	XrlArgs*	a,
	ImportCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_export(
	const char*	the_tgt,
	const string&	protocol,
	const string&	policies,
	const ExportCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/export");
    x.args().add("protocol", protocol);
    x.args().add("policies", policies);
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_export, cb));
}


/* Unmarshall export */
void
XrlPolicyV0p1Client::unmarshall_export(
	const XrlError&	e,
	XrlArgs*	a,
	ExportCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPolicyV0p1Client::send_get_conf(
	const char*	the_tgt,
	const GetConfCB&	cb
)
{
    Xrl x(the_tgt, "policy/0.1/get_conf");
    return _sender->send(x, callback(this, &XrlPolicyV0p1Client::unmarshall_get_conf, cb));
}


/* Unmarshall get_conf */
void
XrlPolicyV0p1Client::unmarshall_get_conf(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string conf;
    try {
	a->get("conf", conf);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &conf);
}
