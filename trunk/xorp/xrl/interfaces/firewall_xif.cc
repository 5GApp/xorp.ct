/*
 * Copyright (c) 2001-2004 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#ident "$XORP$"

#include "firewall_xif.hh"

bool
XrlFirewallV0p1Client::send_get_fw_enabled(
	const char*	the_tgt,
	const GetFwEnabledCB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_fw_enabled");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_fw_enabled, cb));
}


/* Unmarshall get_fw_enabled */
void
XrlFirewallV0p1Client::unmarshall_get_fw_enabled(
	const XrlError&	e,
	XrlArgs*	a,
	GetFwEnabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 1);
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlFirewallV0p1Client::send_set_fw_enabled(
	const char*	the_tgt,
	const bool&	enabled,
	const SetFwEnabledCB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/set_fw_enabled");
    x.args().add("enabled", enabled);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_set_fw_enabled, cb));
}


/* Unmarshall set_fw_enabled */
void
XrlFirewallV0p1Client::unmarshall_set_fw_enabled(
	const XrlError&	e,
	XrlArgs*	a,
	SetFwEnabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFirewallV0p1Client::send_get_fw_default_drop(
	const char*	the_tgt,
	const GetFwDefaultDropCB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_fw_default_drop");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_fw_default_drop, cb));
}


/* Unmarshall get_fw_default_drop */
void
XrlFirewallV0p1Client::unmarshall_get_fw_default_drop(
	const XrlError&	e,
	XrlArgs*	a,
	GetFwDefaultDropCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 1);
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool drop;
    try {
	a->get("drop", drop);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &drop);
}

bool
XrlFirewallV0p1Client::send_set_fw_default_drop(
	const char*	the_tgt,
	const bool&	drop,
	const SetFwDefaultDropCB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/set_fw_default_drop");
    x.args().add("drop", drop);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_set_fw_default_drop, cb));
}


/* Unmarshall set_fw_default_drop */
void
XrlFirewallV0p1Client::unmarshall_set_fw_default_drop(
	const XrlError&	e,
	XrlArgs*	a,
	SetFwDefaultDropCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFirewallV0p1Client::send_get_fw_provider(
	const char*	the_tgt,
	const GetFwProviderCB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_fw_provider");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_fw_provider, cb));
}


/* Unmarshall get_fw_provider */
void
XrlFirewallV0p1Client::unmarshall_get_fw_provider(
	const XrlError&	e,
	XrlArgs*	a,
	GetFwProviderCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 1);
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string provider;
    try {
	a->get("provider", provider);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &provider);
}

bool
XrlFirewallV0p1Client::send_set_fw_provider(
	const char*	the_tgt,
	const string&	provider,
	const SetFwProviderCB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/set_fw_provider");
    x.args().add("provider", provider);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_set_fw_provider, cb));
}


/* Unmarshall set_fw_provider */
void
XrlFirewallV0p1Client::unmarshall_set_fw_provider(
	const XrlError&	e,
	XrlArgs*	a,
	SetFwProviderCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFirewallV0p1Client::send_get_fw_version(
	const char*	the_tgt,
	const GetFwVersionCB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_fw_version");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_fw_version, cb));
}


/* Unmarshall get_fw_version */
void
XrlFirewallV0p1Client::unmarshall_get_fw_version(
	const XrlError&	e,
	XrlArgs*	a,
	GetFwVersionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 1);
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string version;
    try {
	a->get("version", version);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &version);
}

bool
XrlFirewallV0p1Client::send_get_num_xorp_rules4(
	const char*	the_tgt,
	const GetNumXorpRules4CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_num_xorp_rules4");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_num_xorp_rules4, cb));
}


/* Unmarshall get_num_xorp_rules4 */
void
XrlFirewallV0p1Client::unmarshall_get_num_xorp_rules4(
	const XrlError&	e,
	XrlArgs*	a,
	GetNumXorpRules4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 1);
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t nrules;
    try {
	a->get("nrules", nrules);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &nrules);
}

bool
XrlFirewallV0p1Client::send_get_num_provider_rules4(
	const char*	the_tgt,
	const GetNumProviderRules4CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_num_provider_rules4");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_num_provider_rules4, cb));
}


/* Unmarshall get_num_provider_rules4 */
void
XrlFirewallV0p1Client::unmarshall_get_num_provider_rules4(
	const XrlError&	e,
	XrlArgs*	a,
	GetNumProviderRules4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 1);
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t nrules;
    try {
	a->get("nrules", nrules);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &nrules);
}

bool
XrlFirewallV0p1Client::send_get_num_xorp_rules6(
	const char*	the_tgt,
	const GetNumXorpRules6CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_num_xorp_rules6");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_num_xorp_rules6, cb));
}


/* Unmarshall get_num_xorp_rules6 */
void
XrlFirewallV0p1Client::unmarshall_get_num_xorp_rules6(
	const XrlError&	e,
	XrlArgs*	a,
	GetNumXorpRules6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 1);
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t nrules;
    try {
	a->get("nrules", nrules);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &nrules);
}

bool
XrlFirewallV0p1Client::send_get_num_provider_rules6(
	const char*	the_tgt,
	const GetNumProviderRules6CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_num_provider_rules6");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_num_provider_rules6, cb));
}


/* Unmarshall get_num_provider_rules6 */
void
XrlFirewallV0p1Client::unmarshall_get_num_provider_rules6(
	const XrlError&	e,
	XrlArgs*	a,
	GetNumProviderRules6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 1);
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t nrules;
    try {
	a->get("nrules", nrules);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &nrules);
}

bool
XrlFirewallV0p1Client::send_add_filter4(
	const char*	the_tgt,
	const string&	ifname,
	const string&	vifname,
	const IPv4Net&	src,
	const IPv4Net&	dst,
	const uint32_t&	proto,
	const uint32_t&	sport,
	const uint32_t&	dport,
	const string&	action,
	const AddFilter4CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/add_filter4");
    x.args().add("ifname", ifname);
    x.args().add("vifname", vifname);
    x.args().add("src", src);
    x.args().add("dst", dst);
    x.args().add("proto", proto);
    x.args().add("sport", sport);
    x.args().add("dport", dport);
    x.args().add("action", action);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_add_filter4, cb));
}


/* Unmarshall add_filter4 */
void
XrlFirewallV0p1Client::unmarshall_add_filter4(
	const XrlError&	e,
	XrlArgs*	a,
	AddFilter4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFirewallV0p1Client::send_add_filter6(
	const char*	the_tgt,
	const string&	ifname,
	const string&	vifname,
	const IPv6Net&	src,
	const IPv6Net&	dst,
	const uint32_t&	proto,
	const uint32_t&	sport,
	const uint32_t&	dport,
	const string&	action,
	const AddFilter6CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/add_filter6");
    x.args().add("ifname", ifname);
    x.args().add("vifname", vifname);
    x.args().add("src", src);
    x.args().add("dst", dst);
    x.args().add("proto", proto);
    x.args().add("sport", sport);
    x.args().add("dport", dport);
    x.args().add("action", action);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_add_filter6, cb));
}


/* Unmarshall add_filter6 */
void
XrlFirewallV0p1Client::unmarshall_add_filter6(
	const XrlError&	e,
	XrlArgs*	a,
	AddFilter6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFirewallV0p1Client::send_delete_filter4(
	const char*	the_tgt,
	const string&	ifname,
	const string&	vifname,
	const IPv4Net&	src,
	const IPv4Net&	dst,
	const uint32_t&	proto,
	const uint32_t&	sport,
	const uint32_t&	dport,
	const DeleteFilter4CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/delete_filter4");
    x.args().add("ifname", ifname);
    x.args().add("vifname", vifname);
    x.args().add("src", src);
    x.args().add("dst", dst);
    x.args().add("proto", proto);
    x.args().add("sport", sport);
    x.args().add("dport", dport);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_delete_filter4, cb));
}


/* Unmarshall delete_filter4 */
void
XrlFirewallV0p1Client::unmarshall_delete_filter4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteFilter4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFirewallV0p1Client::send_delete_filter6(
	const char*	the_tgt,
	const string&	ifname,
	const string&	vifname,
	const IPv6Net&	src,
	const IPv6Net&	dst,
	const uint32_t&	proto,
	const uint32_t&	sport,
	const uint32_t&	dport,
	const DeleteFilter6CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/delete_filter6");
    x.args().add("ifname", ifname);
    x.args().add("vifname", vifname);
    x.args().add("src", src);
    x.args().add("dst", dst);
    x.args().add("proto", proto);
    x.args().add("sport", sport);
    x.args().add("dport", dport);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_delete_filter6, cb));
}


/* Unmarshall delete_filter6 */
void
XrlFirewallV0p1Client::unmarshall_delete_filter6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteFilter6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFirewallV0p1Client::send_get_filter_list_start4(
	const char*	the_tgt,
	const GetFilterListStart4CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_filter_list_start4");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_filter_list_start4, cb));
}


/* Unmarshall get_filter_list_start4 */
void
XrlFirewallV0p1Client::unmarshall_get_filter_list_start4(
	const XrlError&	e,
	XrlArgs*	a,
	GetFilterListStart4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 2);
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    uint32_t token;
    bool more;
    try {
	a->get("token", token);
	a->get("more", more);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &token, &more);
}

bool
XrlFirewallV0p1Client::send_get_filter_list_next4(
	const char*	the_tgt,
	const uint32_t&	token,
	const GetFilterListNext4CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_filter_list_next4");
    x.args().add("token", token);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_filter_list_next4, cb));
}


/* Unmarshall get_filter_list_next4 */
void
XrlFirewallV0p1Client::unmarshall_get_filter_list_next4(
	const XrlError&	e,
	XrlArgs*	a,
	GetFilterListNext4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 9);
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    bool more;
    string ifname;
    string vifname;
    IPv4Net src;
    IPv4Net dst;
    uint32_t proto;
    uint32_t sport;
    uint32_t dport;
    string action;
    try {
	a->get("more", more);
	a->get("ifname", ifname);
	a->get("vifname", vifname);
	a->get("src", src);
	a->get("dst", dst);
	a->get("proto", proto);
	a->get("sport", sport);
	a->get("dport", dport);
	a->get("action", action);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &more, &ifname, &vifname, &src, &dst, &proto, &sport, &dport, &action);
}

bool
XrlFirewallV0p1Client::send_get_filter_list_start6(
	const char*	the_tgt,
	const GetFilterListStart6CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_filter_list_start6");
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_filter_list_start6, cb));
}


/* Unmarshall get_filter_list_start6 */
void
XrlFirewallV0p1Client::unmarshall_get_filter_list_start6(
	const XrlError&	e,
	XrlArgs*	a,
	GetFilterListStart6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0);
	return;
    } else if (a && a->size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 2);
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    uint32_t token;
    bool more;
    try {
	a->get("token", token);
	a->get("more", more);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0);
	return;
    }
    cb->dispatch(e, &token, &more);
}

bool
XrlFirewallV0p1Client::send_get_filter_list_next6(
	const char*	the_tgt,
	const uint32_t&	token,
	const GetFilterListNext6CB&	cb
)
{
    Xrl x(the_tgt, "firewall/0.1/get_filter_list_next6");
    x.args().add("token", token);
    return _sender->send(x, callback(this, &XrlFirewallV0p1Client::unmarshall_get_filter_list_next6, cb));
}


/* Unmarshall get_filter_list_next6 */
void
XrlFirewallV0p1Client::unmarshall_get_filter_list_next6(
	const XrlError&	e,
	XrlArgs*	a,
	GetFilterListNext6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 9);
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    bool more;
    string ifname;
    string vifname;
    IPv6Net src;
    IPv6Net dst;
    uint32_t proto;
    uint32_t sport;
    uint32_t dport;
    string action;
    try {
	a->get("more", more);
	a->get("ifname", ifname);
	a->get("vifname", vifname);
	a->get("src", src);
	a->get("dst", dst);
	a->get("proto", proto);
	a->get("sport", sport);
	a->get("dport", dport);
	a->get("action", action);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &more, &ifname, &vifname, &src, &dst, &proto, &sport, &dport, &action);
}
