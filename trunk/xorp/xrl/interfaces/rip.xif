interface rip/0.1 {

    /**
     * Add an address to run RIP process on.  The addition of address is
     * not instantaneous, RIP has to instantiate state in the FEA to send
     * and receive packets.  Once instantiated the address must be
     * explicitly enabled with set_rip_address_enabled.
     *
     * @param ifname the interface that owns vif that has address.
     * @param vifname virtual interface owning address.
     * @param addr the address to be added.
     */
    add_rip_address ? ifname:txt					\
		    & vifname:txt					\
		    & addr:ipv4

    /**
     * Remove an address RIP process is running on.
     *
     * @param ifname the interface that owns vif that has address.
     * @param vifname virtual interface owning address.
     * @param addr the address to be removed.
     */
    remove_rip_address ? ifname:txt & vifname:txt & addr:ipv4

    set_rip_address_enabled ? ifname:txt 	  			\
			    & vifname:txt				\
			    & addr:ipv4 				\
			    & enabled:bool

    rip_address_enabled	    ? ifname:txt				\
			    & vifname:txt				\
			    & addr:ipv4					\
			    -> enabled:bool

    /**
     * Set cost metric associated with address.
     */
    set_cost		    ? ifname:txt				\
			    & vifname:txt				\
			    & addr:ipv4 				\
			    & cost:u32

    /**
     * Get cost metric associated with address.
     */
    cost		    ? ifname:txt				\
			    & vifname:txt				\
			    & addr:ipv4					\
			    -> cost:u32

    /**
     * Set horizon type applied to routes advertised from address.
     * @param horizon name of horizon type.
     * Permitted values: "none",
     *			 "poison-reverse"
     *			 "split-horizon-poison-reverse"
     */
    set_horizon		    ? ifname:txt				\
			    & vifname:txt				\
			    & addr:ipv4 				\
			    & horizon:txt

    /**
     * Get horizon type applied to routes advertised from address.
     */
    horizon		    ? ifname:txt				\
			    & vifname:txt				\
			    & addr:ipv4 				\
			    -> horizon:txt

    /**
     * Make RIP passive (receive only) on interface/vif/address.
     */
    set_passive		    ? ifname:txt				\
			    & vifname:txt				\
			    & addr:ipv4					\
			    & passive:bool

    /**
     * Get value indicating whether RIP is passive (receive only)
     * on interface/vif/address.
     */
    passive		    ? ifname:txt				\
			    & vifname:txt				\
			    & addr:ipv4					\
			    -> passive:bool

    /**
     * Accept and respond to non-RIP requests.
     */
    set_accept_non_rip_requests		? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					& accept:bool

    /**
     * Get value indicating whether non-RIP requests are accepted and
     * responded to on interface/vif/address.
     */
    accept_non_rip_requests	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				-> accept:bool

    /**
     * Accept default route from peers.
     */
    set_accept_default_route	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				& accept:bool

    /**
     * Accessor for whether default route is accepted from peers.
     */
    accept_default_route	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				-> accept:bool

    /**
     * Advertise default route (if present).
     */
    set_advertise_default_route	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				& advertise:bool

    /**
     * Accessor for whether default route is advertised.
     */
    advertise_default_route	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				-> advertise:bool

    /**
     * Set period that routes associated with reception address will
     * expire in the absence of updates.
     */
    set_route_expiry_seconds	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				& t_secs:u32

    /**
     * Get period that routes associated with reception address will
     * expire in the absence of updates.
     */
    route_expiry_seconds	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				-> t_secs:u32

    /**
     * Set period that routes associated with reception address will be
     * deleted after they've expired.
     */
    set_route_deletion_seconds	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				& t_secs:u32

    /**
     * Get period that routes associated with reception address will be
     * deleted after they've expired.
     */
     route_deletion_seconds	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				-> t_secs:u32

    /**
     * Set period that route table requests should be sent from address
     * when no peers are associated with it.
     */
    set_table_request_seconds	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				& t_secs:u32

    /**
     * Set period that route table requests should be sent from address
     * when no peers are associated with it.
     */
    table_request_seconds	? ifname:txt				\
				& vifname:txt				\
				& addr:ipv4				\
				-> t_secs:u32

    /**
     * Set minimum period between the unsolicited sending of the routing
     * table from address.
     */
    set_unsolicited_response_min_seconds  ? ifname:txt			\
					  & vifname:txt			\
					  & addr:ipv4			\
					  & t_secs:u32
    /**
     * Get minimum period between the unsolicited sending of the routing
     * table from address.
     */
    unsolicited_response_min_seconds	? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					-> t_secs:u32

    /**
     * Set maximum period between the unsolicited sending of the routing
     * table from address.
     */
    set_unsolicited_response_max_seconds	? ifname:txt		\
						& vifname:txt		\
						& addr:ipv4		\
						& t_secs:u32

    /**
     * Get maximum period between the unsolicited sending of the routing
     * table from address.
     */
    unsolicited_response_max_seconds  ?	ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					-> t_secs:u32

    /**
     * Set minimum period between sending triggered updates from address.
     */
    set_triggered_update_min_seconds	? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					& t_secs:u32

    /**
     * Get minimum period between sending triggered updates from address.
     */
    triggered_update_min_seconds	? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					-> t_secs:u32

    /**
     * Set maximum period between sending triggered updates from address.
     */
    set_triggered_update_max_seconds  ? ifname:txt			\
				      & vifname:txt			\
				      & addr:ipv4			\
				      & t_secs:u32

    /**
     * Get maximum period between sending triggered updates from address.
     */
    triggered_update_max_seconds  ? ifname:txt			\
				      & vifname:txt			\
				      & addr:ipv4			\
				      -> t_secs:u32

    /**
     * Set the inter-packet delay between the output of packets from
     * address.
     */
    set_interpacket_delay_milliseconds	? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					& t_msecs:u32

    /**
     * Get the inter-packet delay between the output of packets from
     * address.
     */
    interpacket_delay_milliseconds	? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					-> t_msecs:u32

    /**
     * Set authentication scheme.
     */
    set_authentication			? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					& type:txt			\
					& password:txt

    /**
     * Get authentication scheme.
     */
    authentication			? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					-> type:txt			\
					 & password:txt

    /**
     * Get a textual description of the status of address RIP is running
     * upon.
     *
     * @param ifname the interface that owns vif that has the address.
     * @param vifname virtual interface owns the address.
     * @param addr the address to query.
     */
    rip_address_status			? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					-> status:txt

    /**
     * Get counters associated with interface / vif /address.
     */
     get_counters			? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					-> counter_descriptions:list	\
					&  counter_values:list

    /**
     * Get the list of peers associated with interface / vif / address.
     */
    get_peers				? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					-> peers:list

    /**
     * Get list of all peers known to RIP.  There is a 1-to-1 correspondence
     * between the items in the lists of peers, ifnames, vifnames, addrs.
     */
    get_all_peers			-> peers:list			\
					& ifnames:list			\
					& vifnames:list			\
					& addrs:list

    /**
     * Get counters associated with peer of interface / vif /address.
     */
     get_peer_counters			? ifname:txt			\
					& vifname:txt			\
					& addr:ipv4			\
					& peer:ipv4			\
					-> counter_descriptions:list	\
					&  counter_values:list

    /**
     * Add a static route.
     *
     * @param network route target.
     * @param nexthop path to direct packets for @ref network to.
     * @param cost RIP cost [0--15].
     */
    add_static_route ? network:ipv4net					\
		     & nexthop:ipv4					\
		     & cost:u32

    /**
     * Remove static route.
     *
     * @param network route target.
     *
     * This method will fail if network was not previously added with
     * add_static_route.
     */
     delete_static_route ? network:ipv4net

}
