/*
 * Copyright (c) 2001-2003 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#ident "$XORP: xorp/xrl/interfaces/fea_ifmgr_xif.cc,v 1.9 2003/05/19 06:41:51 pavlin Exp $"

#include "fea_ifmgr_xif.hh"

bool
XrlIfmgrV0p1Client::send_get_all_interface_names(
	const char*	the_tgt, 
	const CB0&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_interface_names");
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall0, cb));
}


/* Unmarshall get_all_interface_names */
void
XrlIfmgrV0p1Client::unmarshall0(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB0		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList ifnames;
    try {
	a->get("ifnames", ifnames);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &ifnames);
}

bool
XrlIfmgrV0p1Client::send_get_configured_interface_names(
	const char*	the_tgt, 
	const CB1&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_interface_names");
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall1, cb));
}


/* Unmarshall get_configured_interface_names */
void
XrlIfmgrV0p1Client::unmarshall1(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB1		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList ifnames;
    try {
	a->get("ifnames", ifnames);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &ifnames);
}

bool
XrlIfmgrV0p1Client::send_get_all_vif_names(
	const char*	the_tgt, 
	const string&	ifname, 
	const CB2&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_vif_names");
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall2, cb));
}


/* Unmarshall get_all_vif_names */
void
XrlIfmgrV0p1Client::unmarshall2(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB2		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList vifs;
    try {
	a->get("vifs", vifs);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &vifs);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_names(
	const char*	the_tgt, 
	const string&	ifname, 
	const CB3&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_vif_names");
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall3, cb));
}


/* Unmarshall get_configured_vif_names */
void
XrlIfmgrV0p1Client::unmarshall3(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB3		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList vifs;
    try {
	a->get("vifs", vifs);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &vifs);
}

bool
XrlIfmgrV0p1Client::send_get_all_vif_flags(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const CB4&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_vif_flags");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall4, cb));
}


/* Unmarshall get_all_vif_flags */
void
XrlIfmgrV0p1Client::unmarshall4(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB4		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != 5)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool broadcast;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("broadcast", broadcast);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &broadcast, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_flags(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const CB5&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_vif_flags");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall5, cb));
}


/* Unmarshall get_configured_vif_flags */
void
XrlIfmgrV0p1Client::unmarshall5(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB5		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != 5)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool broadcast;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("broadcast", broadcast);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &broadcast, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_all_vif_addresses4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const CB6&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_vif_addresses4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall6, cb));
}


/* Unmarshall get_all_vif_addresses4 */
void
XrlIfmgrV0p1Client::unmarshall6(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB6		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList addresses;
    try {
	a->get("addresses", addresses);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &addresses);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_addresses4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const CB7&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_vif_addresses4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall7, cb));
}


/* Unmarshall get_configured_vif_addresses4 */
void
XrlIfmgrV0p1Client::unmarshall7(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB7		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList addresses;
    try {
	a->get("addresses", addresses);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &addresses);
}

bool
XrlIfmgrV0p1Client::send_get_all_vif_addresses6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const CB8&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_vif_addresses6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall8, cb));
}


/* Unmarshall get_all_vif_addresses6 */
void
XrlIfmgrV0p1Client::unmarshall8(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB8		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList addresses;
    try {
	a->get("addresses", addresses);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &addresses);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_addresses6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const CB9&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_vif_addresses6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall9, cb));
}


/* Unmarshall get_configured_vif_addresses6 */
void
XrlIfmgrV0p1Client::unmarshall9(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB9		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList addresses;
    try {
	a->get("addresses", addresses);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &addresses);
}

bool
XrlIfmgrV0p1Client::send_get_all_address_flags4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB10&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_address_flags4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall10, cb));
}


/* Unmarshall get_all_address_flags4 */
void
XrlIfmgrV0p1Client::unmarshall10(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB10		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != 5)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool broadcast;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("broadcast", broadcast);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &broadcast, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_configured_address_flags4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB11&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_address_flags4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall11, cb));
}


/* Unmarshall get_configured_address_flags4 */
void
XrlIfmgrV0p1Client::unmarshall11(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB11		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != 5)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool broadcast;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("broadcast", broadcast);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &broadcast, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_all_address_flags6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB12&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_address_flags6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall12, cb));
}


/* Unmarshall get_all_address_flags6 */
void
XrlIfmgrV0p1Client::unmarshall12(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB12		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != 4)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_configured_address_flags6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB13&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_address_flags6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall13, cb));
}


/* Unmarshall get_configured_address_flags6 */
void
XrlIfmgrV0p1Client::unmarshall13(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB13		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != 4)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_all_interface_enabled(
	const char*	the_tgt, 
	const string&	ifname, 
	const CB14&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_interface_enabled");
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall14, cb));
}


/* Unmarshall get_all_interface_enabled */
void
XrlIfmgrV0p1Client::unmarshall14(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB14		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_get_configured_interface_enabled(
	const char*	the_tgt, 
	const string&	ifname, 
	const CB15&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_interface_enabled");
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall15, cb));
}


/* Unmarshall get_configured_interface_enabled */
void
XrlIfmgrV0p1Client::unmarshall15(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB15		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_get_all_mac(
	const char*	the_tgt, 
	const string&	ifname, 
	const CB16&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_mac");
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall16, cb));
}


/* Unmarshall get_all_mac */
void
XrlIfmgrV0p1Client::unmarshall16(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB16		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    Mac mac;
    try {
	a->get("mac", mac);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &mac);
}

bool
XrlIfmgrV0p1Client::send_get_configured_mac(
	const char*	the_tgt, 
	const string&	ifname, 
	const CB17&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_mac");
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall17, cb));
}


/* Unmarshall get_configured_mac */
void
XrlIfmgrV0p1Client::unmarshall17(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB17		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    Mac mac;
    try {
	a->get("mac", mac);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &mac);
}

bool
XrlIfmgrV0p1Client::send_get_all_mtu(
	const char*	the_tgt, 
	const string&	ifname, 
	const CB18&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_mtu");
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall18, cb));
}


/* Unmarshall get_all_mtu */
void
XrlIfmgrV0p1Client::unmarshall18(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB18		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t mtu;
    try {
	a->get("mtu", mtu);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &mtu);
}

bool
XrlIfmgrV0p1Client::send_get_configured_mtu(
	const char*	the_tgt, 
	const string&	ifname, 
	const CB19&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_mtu");
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall19, cb));
}


/* Unmarshall get_configured_mtu */
void
XrlIfmgrV0p1Client::unmarshall19(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB19		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t mtu;
    try {
	a->get("mtu", mtu);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &mtu);
}

bool
XrlIfmgrV0p1Client::send_get_all_vif_enabled(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const CB20&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_vif_enabled");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall20, cb));
}


/* Unmarshall get_all_vif_enabled */
void
XrlIfmgrV0p1Client::unmarshall20(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB20		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_enabled(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const CB21&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_vif_enabled");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall21, cb));
}


/* Unmarshall get_configured_vif_enabled */
void
XrlIfmgrV0p1Client::unmarshall21(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB21		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_get_all_prefix4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB22&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_prefix4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall22, cb));
}


/* Unmarshall get_all_prefix4 */
void
XrlIfmgrV0p1Client::unmarshall22(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB22		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t prefix;
    try {
	a->get("prefix", prefix);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &prefix);
}

bool
XrlIfmgrV0p1Client::send_get_configured_prefix4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB23&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_prefix4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall23, cb));
}


/* Unmarshall get_configured_prefix4 */
void
XrlIfmgrV0p1Client::unmarshall23(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB23		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t prefix;
    try {
	a->get("prefix", prefix);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &prefix);
}

bool
XrlIfmgrV0p1Client::send_get_all_broadcast4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB24&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_broadcast4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall24, cb));
}


/* Unmarshall get_all_broadcast4 */
void
XrlIfmgrV0p1Client::unmarshall24(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB24		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv4 broadcast;
    try {
	a->get("broadcast", broadcast);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &broadcast);
}

bool
XrlIfmgrV0p1Client::send_get_configured_broadcast4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB25&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_broadcast4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall25, cb));
}


/* Unmarshall get_configured_broadcast4 */
void
XrlIfmgrV0p1Client::unmarshall25(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB25		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv4 broadcast;
    try {
	a->get("broadcast", broadcast);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &broadcast);
}

bool
XrlIfmgrV0p1Client::send_get_all_endpoint4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB26&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_endpoint4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall26, cb));
}


/* Unmarshall get_all_endpoint4 */
void
XrlIfmgrV0p1Client::unmarshall26(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB26		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv4 endpoint;
    try {
	a->get("endpoint", endpoint);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &endpoint);
}

bool
XrlIfmgrV0p1Client::send_get_configured_endpoint4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB27&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_endpoint4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall27, cb));
}


/* Unmarshall get_configured_endpoint4 */
void
XrlIfmgrV0p1Client::unmarshall27(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB27		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv4 endpoint;
    try {
	a->get("endpoint", endpoint);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &endpoint);
}

bool
XrlIfmgrV0p1Client::send_get_all_prefix6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB28&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_prefix6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall28, cb));
}


/* Unmarshall get_all_prefix6 */
void
XrlIfmgrV0p1Client::unmarshall28(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB28		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t prefix;
    try {
	a->get("prefix", prefix);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &prefix);
}

bool
XrlIfmgrV0p1Client::send_get_configured_prefix6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB29&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_prefix6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall29, cb));
}


/* Unmarshall get_configured_prefix6 */
void
XrlIfmgrV0p1Client::unmarshall29(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB29		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t prefix;
    try {
	a->get("prefix", prefix);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &prefix);
}

bool
XrlIfmgrV0p1Client::send_get_all_endpoint6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB30&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_endpoint6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall30, cb));
}


/* Unmarshall get_all_endpoint6 */
void
XrlIfmgrV0p1Client::unmarshall30(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB30		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv6 endpoint;
    try {
	a->get("endpoint", endpoint);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &endpoint);
}

bool
XrlIfmgrV0p1Client::send_get_configured_endpoint6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB31&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_endpoint6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall31, cb));
}


/* Unmarshall get_configured_endpoint6 */
void
XrlIfmgrV0p1Client::unmarshall31(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB31		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv6 endpoint;
    try {
	a->get("endpoint", endpoint);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &endpoint);
}

bool
XrlIfmgrV0p1Client::send_start_transaction(
	const char*	the_tgt, 
	const CB32&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/start_transaction");
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall32, cb));
}


/* Unmarshall start_transaction */
void
XrlIfmgrV0p1Client::unmarshall32(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB32		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t tid;
    try {
	a->get("tid", tid);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &tid);
}

bool
XrlIfmgrV0p1Client::send_commit_transaction(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const CB33&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/commit_transaction");
    x.args().add("tid", tid);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall33, cb));
}


/* Unmarshall commit_transaction */
void
XrlIfmgrV0p1Client::unmarshall33(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB33		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_abort_transaction(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const CB34&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/abort_transaction");
    x.args().add("tid", tid);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall34, cb));
}


/* Unmarshall abort_transaction */
void
XrlIfmgrV0p1Client::unmarshall34(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB34		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_interface(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const CB35&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/create_interface");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall35, cb));
}


/* Unmarshall create_interface */
void
XrlIfmgrV0p1Client::unmarshall35(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB35		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_interface(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const CB36&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/delete_interface");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall36, cb));
}


/* Unmarshall delete_interface */
void
XrlIfmgrV0p1Client::unmarshall36(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB36		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_interface_enabled(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const bool&	enabled, 
	const CB37&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_interface_enabled");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("enabled", enabled);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall37, cb));
}


/* Unmarshall set_interface_enabled */
void
XrlIfmgrV0p1Client::unmarshall37(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB37		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_mac(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const Mac&	mac, 
	const CB38&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_mac");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("mac", mac);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall38, cb));
}


/* Unmarshall set_mac */
void
XrlIfmgrV0p1Client::unmarshall38(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB38		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_mtu(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const uint32_t&	mtu, 
	const CB39&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_mtu");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("mtu", mtu);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall39, cb));
}


/* Unmarshall set_mtu */
void
XrlIfmgrV0p1Client::unmarshall39(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB39		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_vif(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const CB40&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/create_vif");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall40, cb));
}


/* Unmarshall create_vif */
void
XrlIfmgrV0p1Client::unmarshall40(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB40		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_vif(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const CB41&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/delete_vif");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall41, cb));
}


/* Unmarshall delete_vif */
void
XrlIfmgrV0p1Client::unmarshall41(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB41		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_vif_enabled(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const bool&	enabled, 
	const CB42&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_vif_enabled");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("enabled", enabled);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall42, cb));
}


/* Unmarshall set_vif_enabled */
void
XrlIfmgrV0p1Client::unmarshall42(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB42		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_address4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB43&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/create_address4");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall43, cb));
}


/* Unmarshall create_address4 */
void
XrlIfmgrV0p1Client::unmarshall43(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB43		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_address4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB44&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/delete_address4");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall44, cb));
}


/* Unmarshall delete_address4 */
void
XrlIfmgrV0p1Client::unmarshall44(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB44		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_address_enabled4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const bool&	enabled, 
	const CB45&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_address_enabled4");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    x.args().add("enabled", enabled);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall45, cb));
}


/* Unmarshall set_address_enabled4 */
void
XrlIfmgrV0p1Client::unmarshall45(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB45		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_get_all_address_enabled4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB46&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_address_enabled4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall46, cb));
}


/* Unmarshall get_all_address_enabled4 */
void
XrlIfmgrV0p1Client::unmarshall46(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB46		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_get_configured_address_enabled4(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const CB47&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_address_enabled4");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall47, cb));
}


/* Unmarshall get_configured_address_enabled4 */
void
XrlIfmgrV0p1Client::unmarshall47(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB47		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_set_prefix4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const uint32_t&	prefix, 
	const CB48&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_prefix4");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    x.args().add("prefix", prefix);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall48, cb));
}


/* Unmarshall set_prefix4 */
void
XrlIfmgrV0p1Client::unmarshall48(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB48		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_broadcast4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const IPv4&	broadcast, 
	const CB49&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_broadcast4");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    x.args().add("broadcast", broadcast);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall49, cb));
}


/* Unmarshall set_broadcast4 */
void
XrlIfmgrV0p1Client::unmarshall49(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB49		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_endpoint4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv4&	address, 
	const IPv4&	endpoint, 
	const CB50&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_endpoint4");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    x.args().add("endpoint", endpoint);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall50, cb));
}


/* Unmarshall set_endpoint4 */
void
XrlIfmgrV0p1Client::unmarshall50(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB50		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_address6(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB51&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/create_address6");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall51, cb));
}


/* Unmarshall create_address6 */
void
XrlIfmgrV0p1Client::unmarshall51(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB51		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_address6(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB52&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/delete_address6");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall52, cb));
}


/* Unmarshall delete_address6 */
void
XrlIfmgrV0p1Client::unmarshall52(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB52		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_address_enabled6(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const bool&	enabled, 
	const CB53&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_address_enabled6");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    x.args().add("enabled", enabled);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall53, cb));
}


/* Unmarshall set_address_enabled6 */
void
XrlIfmgrV0p1Client::unmarshall53(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB53		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_get_all_address_enabled6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB54&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_all_address_enabled6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall54, cb));
}


/* Unmarshall get_all_address_enabled6 */
void
XrlIfmgrV0p1Client::unmarshall54(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB54		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_get_configured_address_enabled6(
	const char*	the_tgt, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const CB55&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/get_configured_address_enabled6");
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall55, cb));
}


/* Unmarshall get_configured_address_enabled6 */
void
XrlIfmgrV0p1Client::unmarshall55(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB55		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_set_prefix6(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const uint32_t&	prefix, 
	const CB56&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_prefix6");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    x.args().add("prefix", prefix);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall56, cb));
}


/* Unmarshall set_prefix6 */
void
XrlIfmgrV0p1Client::unmarshall56(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB56		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_endpoint6(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const string&	ifname, 
	const string&	vif, 
	const IPv6&	address, 
	const IPv6&	endpoint, 
	const CB57&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/set_endpoint6");
    x.args().add("tid", tid);
    x.args().add("ifname", ifname);
    x.args().add("vif", vif);
    x.args().add("address", address);
    x.args().add("endpoint", endpoint);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall57, cb));
}


/* Unmarshall set_endpoint6 */
void
XrlIfmgrV0p1Client::unmarshall57(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB57		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_register_client(
	const char*	the_tgt, 
	const string&	clientname, 
	const CB58&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/register_client");
    x.args().add("clientname", clientname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall58, cb));
}


/* Unmarshall register_client */
void
XrlIfmgrV0p1Client::unmarshall58(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB58		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_unregister_client(
	const char*	the_tgt, 
	const string&	clientname, 
	const CB59&	cb
)
{
    Xrl x(the_tgt, "ifmgr/0.1/unregister_client");
    x.args().add("clientname", clientname);
    return _sender->send(x, callback(this, &XrlIfmgrV0p1Client::unmarshall59, cb));
}


/* Unmarshall unregister_client */
void
XrlIfmgrV0p1Client::unmarshall59(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB59		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}
