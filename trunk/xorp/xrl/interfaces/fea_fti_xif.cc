/*
 * Copyright (c) 2002 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by '../scripts/clnt-gen'.
 */

#ident "$XORP: xorp/xrl/interfaces/fea_fti_xif.cc,v 1.2 2003/01/10 00:30:26 hodson Exp $"

#include "fea_fti_xif.hh"

bool
XrlFtiV0p1Client::send_start_transaction(
	const char*	the_tgt, 
	const CB0&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/start_transaction");
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall0, cb));
}


/* Unmarshall start_transaction */
void
XrlFtiV0p1Client::unmarshall0(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB0		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != 1)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t tid;
    try {
	a->get("tid", tid);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &tid);
}

bool
XrlFtiV0p1Client::send_commit_transaction(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const CB1&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/commit_transaction");
    x.args().add("tid", tid);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall1, cb));
}


/* Unmarshall commit_transaction */
void
XrlFtiV0p1Client::unmarshall1(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB1		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_abort_transaction(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const CB2&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/abort_transaction");
    x.args().add("tid", tid);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall2, cb));
}


/* Unmarshall abort_transaction */
void
XrlFtiV0p1Client::unmarshall2(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB2		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_add_entry4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const IPv4Net&	dst, 
	const IPv4&	gateway, 
	const string&	ifname, 
	const string&	vifname, 
	const CB3&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/add_entry4");
    x.args().add("tid", tid);
    x.args().add("dst", dst);
    x.args().add("gateway", gateway);
    x.args().add("ifname", ifname);
    x.args().add("vifname", vifname);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall3, cb));
}


/* Unmarshall add_entry4 */
void
XrlFtiV0p1Client::unmarshall3(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB3		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_delete_entry4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const IPv4Net&	dst, 
	const CB4&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/delete_entry4");
    x.args().add("tid", tid);
    x.args().add("dst", dst);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall4, cb));
}


/* Unmarshall delete_entry4 */
void
XrlFtiV0p1Client::unmarshall4(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB4		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_add_entry6(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const IPv6Net&	dst, 
	const IPv6&	gateway, 
	const string&	ifname, 
	const string&	vifname, 
	const CB5&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/add_entry6");
    x.args().add("tid", tid);
    x.args().add("dst", dst);
    x.args().add("gateway", gateway);
    x.args().add("ifname", ifname);
    x.args().add("vifname", vifname);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall5, cb));
}


/* Unmarshall add_entry6 */
void
XrlFtiV0p1Client::unmarshall5(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB5		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_delete_entry6(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const IPv6Net&	dst, 
	const CB6&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/delete_entry6");
    x.args().add("tid", tid);
    x.args().add("dst", dst);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall6, cb));
}


/* Unmarshall delete_entry6 */
void
XrlFtiV0p1Client::unmarshall6(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB6		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_delete_all_entries(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const CB7&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/delete_all_entries");
    x.args().add("tid", tid);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall7, cb));
}


/* Unmarshall delete_all_entries */
void
XrlFtiV0p1Client::unmarshall7(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB7		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_delete_all_entries4(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const CB8&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/delete_all_entries4");
    x.args().add("tid", tid);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall8, cb));
}


/* Unmarshall delete_all_entries4 */
void
XrlFtiV0p1Client::unmarshall8(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB8		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_delete_all_entries6(
	const char*	the_tgt, 
	const uint32_t&	tid, 
	const CB9&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/delete_all_entries6");
    x.args().add("tid", tid);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall9, cb));
}


/* Unmarshall delete_all_entries6 */
void
XrlFtiV0p1Client::unmarshall9(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB9		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != 0)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFtiV0p1Client::send_lookup_route4(
	const char*	the_tgt, 
	const IPv4&	dst, 
	const CB10&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/lookup_route4");
    x.args().add("dst", dst);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall10, cb));
}


/* Unmarshall lookup_route4 */
void
XrlFtiV0p1Client::unmarshall10(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB10		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != 4)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    IPv4Net netmask;
    IPv4 gateway;
    string ifname;
    string vifname;
    try {
	a->get("netmask", netmask);
	a->get("gateway", gateway);
	a->get("ifname", ifname);
	a->get("vifname", vifname);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &netmask, &gateway, &ifname, &vifname);
}

bool
XrlFtiV0p1Client::send_lookup_entry4(
	const char*	the_tgt, 
	const IPv4Net&	dst, 
	const CB11&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/lookup_entry4");
    x.args().add("dst", dst);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall11, cb));
}


/* Unmarshall lookup_entry4 */
void
XrlFtiV0p1Client::unmarshall11(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB11		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    IPv4 gateway;
    string ifname;
    string vifname;
    try {
	a->get("gateway", gateway);
	a->get("ifname", ifname);
	a->get("vifname", vifname);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &gateway, &ifname, &vifname);
}

bool
XrlFtiV0p1Client::send_lookup_route6(
	const char*	the_tgt, 
	const IPv6&	dst, 
	const CB12&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/lookup_route6");
    x.args().add("dst", dst);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall12, cb));
}


/* Unmarshall lookup_route6 */
void
XrlFtiV0p1Client::unmarshall12(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB12		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != 4)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    IPv6Net netmask;
    IPv6 gateway;
    string ifname;
    string vifname;
    try {
	a->get("netmask", netmask);
	a->get("gateway", gateway);
	a->get("ifname", ifname);
	a->get("vifname", vifname);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &netmask, &gateway, &ifname, &vifname);
}

bool
XrlFtiV0p1Client::send_lookup_entry6(
	const char*	the_tgt, 
	const IPv6Net&	dst, 
	const CB13&	cb
)
{
    Xrl x(the_tgt, "fti/0.1/lookup_entry6");
    x.args().add("dst", dst);
    return _router->send(x, callback(this, &XrlFtiV0p1Client::unmarshall13, cb));
}


/* Unmarshall lookup_entry6 */
void
XrlFtiV0p1Client::unmarshall13(
	const XrlError&	e, 
	XrlArgs*	a, 
	CB13		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != 3)", (uint32_t)a->size());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    IPv6 gateway;
    string ifname;
    string vifname;
    try {
	a->get("gateway", gateway);
	a->get("ifname", ifname);
	a->get("vifname", vifname);
    } catch (const XrlArgs::XrlAtomNotFound&) {
	XLOG_ERROR("Atom not found");
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &gateway, &ifname, &vifname);
}
