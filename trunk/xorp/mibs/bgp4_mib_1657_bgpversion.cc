/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "xorpevents.hh"
#include "bgp4_mib_1657.hh"
#include "bgp4_mib_1657_bgpversion.hh"

/** Initializes the bgp_version_scalar module */
void
init_bgp4_mib_1657_bgpversion (void)
{
    static oid bgpVersion_oid[] = { 1,3,6,1,2,1,15,1, 0 };

    DEBUGMSGTL(("bgp4_mib_1657_bgpversion", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("bgpVersion",
                                         get_bgpVersion,
                                         bgpVersion_oid,
                                         OID_LENGTH(bgpVersion_oid),
                                         HANDLER_CAN_RONLY));
}

void send_get_bgp_version_done(const XrlError& e, const uint32_t* ver)
{
    static const int bgpVerStrMax = 4;
    char bgpVersion[bgpVerStrMax];
    int  bgpVersionLen = snprintf(bgpVersion, bgpVerStrMax, "%d", *ver);

    DEBUGMSGTL(("bgp4_mib_1657_bgpversion", "send_get_bgp_version_done called\n"));
    DEBUGMSGTL(("bgp4_mib_1657_bgpversion", "ver = %ld\n", *ver));

    if (XrlError::OKAY() != e) {
	DEBUGMSGTL(("bgp4_mib_1657_bgpversion", "XrlError: "));
	DEBUGMSGTL(("bgp4_mib_1657_bgpversion", e.error_msg()));
	DEBUGMSGTL(("bgp4_mib_1657_bgpversion", "\n"));
	return;
    }

    BgpMibXrlClient& bgp_mib = BgpMibXrlClient::the_instance();

    netsnmp_request_info *requests;
    netsnmp_agent_request_info *reqinfo;
    netsnmp_delegated_cache * cache = bgp_mib.bgp_version_queue.front();

    cache= netsnmp_handler_check_cache(cache);

    if (!cache) {
        snmp_log(LOG_ERR, "illegal call to return delayed response\n");
        return;
    }

    bgp_mib.bgp_version_queue.pop();

    /*
     * re-establish the previous pointers we are used to having 
     */
    reqinfo = cache->reqinfo;
    requests = cache->requests;

    DEBUGMSGTL((XORP_MODULE_NAME,
                "continuing delayed request, mode = %d\n", cache->reqinfo->mode));

    /*
     * mention that it's no longer delegated, and we've now answered
     * the query (which we'll do down below). 
     */
    requests->delegated = 0;

    switch(reqinfo->mode) {

        case MODE_GET:
	    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				     (unsigned char *) bgpVersion, 
				     bgpVersionLen);
	break;
        default:
            /* we should never get here, so this is a really bad error */
            return;
    }
}


int
get_bgpVersion(netsnmp_mib_handler * handler,
                          netsnmp_handler_registration * reginfo,
                          netsnmp_agent_request_info *  reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    DEBUGMSGTL(("bgp4_mib_1657_bgpversion", "get_bgpVersion called\n"));
    BgpMibXrlClient& bgp_mib = BgpMibXrlClient::the_instance();
    BgpMibXrlClient::CB0 cb0;
    cb0 = callback(send_get_bgp_version_done);
    bgp_mib.send_get_bgp_version("bgp", cb0); 

    requests->delegated = 1;
    bgp_mib.bgp_version_queue.push(netsnmp_create_delegated_cache(handler,
				   reginfo, reqinfo, requests, NULL));
    SnmpEventLoop& eventloop = SnmpEventLoop::the_instance(); 
    eventloop.export_events();
    return SNMP_ERR_NOERROR;
}
