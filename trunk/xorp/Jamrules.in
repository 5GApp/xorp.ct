#
# $XORP: xorp/Jamrules.in,v 1.1 2007/01/11 21:53:47 bms Exp $
#

# TODO: Obey LOCATE_TARGET for building XORP from a directory
# other than the source directory.

NotFile install ;

#
# Stuff obtained from ./configure script.
#
PREFIX		= @prefix@ ;
CC 		= @CC@ ;
C++		= @CXX@ ;
#CPP		= @CPP@ ;	# not used by jam [yet]
#CXXCPP		= @CXXCPP@ ;	# not used by jam [yet]
CCFLAGS		= @CFLAGS@ ;
C++FLAGS	= @CXXFLAGS@ ;
LINKFLAGS	= @LDFLAGS@ ;
PYTHON		= @PYTHON@ ;
CLI_CURSES_LIB	= @CLI_CURSES_LIB@ ;
PYTHON_BUILD 	= @PYTHON_BUILD@ defined
		; # will != defined if commented out.

# failsafe
CLI_CURSES_LIB	?= -lcurses ;
CRYPTO_LIB	?= -lcrypto ;

# top level stuff
HDRS		 = . $(SEARCH_SOURCE) $(TOP) ;
EXEMODE		 = 755 ;
LINKLIBS	+= $(CRYPTO_LIB) $(CLI_CURSES_LIB) ;

# If GNU C++ is used, it must be used as the linker.
if $(C++) = "g++"
{
 LINK = $(C++) ;
}

# Win32 failsafe overrides; only really applicable for mingw gcc.
if $(OS) = "NT"
{
# XXX: -Werror has been removed for now due to spurious warnings
 CCFLAGS =  -g -W -Wall -Wwrite-strings -Wbad-function-cast -Wmissing-prototypes -Wcast-qual -Wmissing-declarations -Wpointer-arith -Wcast-align -Wstrict-prototypes -Wnested-externs -pipe ;
 C++FLAGS = -g -W -Wall -Wwrite-strings -Wcast-qual -Wpointer-arith -Wcast-align -Woverloaded-virtual -ftemplate-depth-25 -pipe ;
#
PYTHON		?= python ;
HDRS		 = . $(SEARCH_SOURCE) $(TOP) /mingw/include ;
DEFINES		 = _NO_OLDNAMES MPR50=1 ;
LINKFLAGS	+= -mconsole ;
CLI_CURSES_LIB	 = ;
CRYPTO_LIB	 = -lcrypto ;
LINKLIBS	+= -lpcreposix -lws2_32 -liphlpapi -lmprapi -ladvapi32 ;
}

# XXX FIXME: MIBS
#NETSNMPCFLAGS = -DINET6 -O2 -fno-strict-aliasing -pipe -Dfreebsd6 -DAPPLLIB_EXP=/usr/local/lib/perl5/5.8.8/BSDPAN -DHAS_FPSETMASK -DHAS_FLOATINGPOINT_H -fno-strict-aliasing -pipe -I/usr/local/include -I/usr/local/lib/perl5/5.8.8/mach/CORE -I. -I/usr/local/include -I.. ;

############################################################################
#
# XORP project custom rules follow.
#
# TODO: Conditionalize this on variable PYTHON_BUILD being set
# to something other than '#'.
# TODO: double check yacc version: $(YACC), not bison, version contingent.
# TODO: double check flex version: $(FLEX), version contingent.

#
# Variables used by XORP custom build.
#
SCRIPT_DIR = $(TOP)/xrl/scripts ;
INTERFACES_DIR = $(TOP)/xrl/interfaces ;
TARGET_DIR = $(TOP)/xrl/targets ;

CLNTGEN_PY = $(SCRIPT_DIR)/clnt-gen ;
TGTGEN_PY = $(SCRIPT_DIR)/tgt-gen ;

XYACC = yacc ;
XFLEX = flex ;

############################################################################
#
# XorpSplitLibrary
# Usage: XorpSplitLibrary libtarget : defs : suffix : sources ;
#
# Build a library from a given set of sources, using the user's
# provided DEFINES, appending 'suffix' to the names of the objects
# to avoid clobbering a library built using different DEFINES.
# 
# The library so built may then be referenced as a Library target
# from elsewhere within the tree.
# This is used to build RIP for IPv4 and IPv6 from the same sources.
#
rule XorpSplitLibrary
{
  local _sufobj ;
  _sufobj = "-$(3)$(SUFOBJ)" ;
  LibraryFromObjects $(1) : $(4:S=$(_sufobj)) ;
  XorpSplitObjects $(2) : $(_sufobj) : $(4) ;
}

############################################################################
#
# XorpSplitObjects
# Usage: XorpSplitObjects defs : sufobj : sources ;
#
# Build a bunch of objects with a given suffix in the filename and
# a given set of DEFINES.
# For internal use only by the XorpSplitLibrary rule.
#
rule XorpSplitObjects
{
  local _i ;

  for _i in [ FGristFiles $(3) ]
  {
    DEFINES on $(_i:S=$(2)) += $(1) ;
    Object $(_i:S=$(2)) : $(_i) ;
    Depends obj : $(_i:S=$(2)) ;
  }
}

############################################################################
#
# XorpXrlXif
# Usage: XorpXrlXif <path!grist>foo.cc <p!g>foo.hh : foo.xif ;
#
# Generate XRL interface stubs.
# Use 'jam xrlclean' to remove generated code.
#
# XXX: TODO: Pass environment variable to clnt-gen under Win32 to
# tell it it's being run from Jam and DTRT with paths.
#
rule XorpXrlXif
{
 local _cc ;
 local _hh ;

 SEARCH on $(>) = $(SEARCH_SOURCE) ;	# source .xif file
 MakeLocate $(<) : $(LOCATE_SOURCE) ;	# generated sources

 _cc = $(<[1]) ;
 _hh = $(<[2]) ;

 Includes $(_cc) : $(_hh) ;
 DEPENDS $(<) : $(>) ;

 Clean reallyclean : $(<) ;
}
actions XorpXrlXif
{
 $(PYTHON) $(CLNTGEN_PY) $(>)
}

############################################################################
#
# XorpXrlTgt
# Usage: XorpXrlTgt <path!grist>foo.cc <p!g>foo.hh <p!g>foo.xrls : foo.tgt ;
#
# Generate XRL target stubs and headers.
# Use 'jam xrlclean' to remove generated code.
#
# XXX: TODO: Pass environment variable to clnt-gen under Win32 to
# tell it it's being run from Jam and DTRT with paths.
#
rule XorpXrlTgt
{
 local _cc ;
 local _hh ;
 local _xrls ;

 SEARCH on $(>) = $(SEARCH_SOURCE) ;	# source .tgt file
 MakeLocate $(<) : $(LOCATE_SOURCE) ;	# generated sources

 _cc = $(<[1]) ;
 _hh = $(<[2]) ;
 _xrls = $(<[3]) ;

 Includes $(_cc) : $(_hh) ;
 DEPENDS $(<) : $(>) ;

 # problems with this on win32:
 #Includes $(_cc) : $(_xrls) ; # lie to squelch warning
 #DEPENDS install : $(_xrls) ; # the correct dependency

 Clean xrlclean : $(<) ;
}
actions XorpXrlTgt
{
 $(PYTHON) $(TGTGEN_PY) -I$(INTERFACES_DIR) $(>)
}

############################################################################
#
# XorpYaccC++
# Usage:  XorpYaccC++ ccfile : hfile : prefix : yaccfile ;
#
# Generate C++ source and headers from a Yacc C++ parser description file.
#
# This rule should be braced within a conditional when used, so as to
# avoid building them automatically.
# Use 'jam reallyclean' to remove generated code.
# An intermediate file rename is needed because of how yacc names its
# output files. The XORP policy code does not perpetuate this kludge.
#
rule XorpYaccC++
{
 local _yy = $(4) ;

 SEARCH on $(_yy) = $(SEARCH_SOURCE) ;		# source .yy file
 MakeLocate $(1) $(2) : $(LOCATE_SOURCE) ;	# generated sources

 XYACCFLAGS on $(<) = "-d -p $(3)" ;
 XorpYaccC++Mv1 $(<) : $(_yy) ;

 Includes $(<) : $(2) ;		# real
 DEPENDS $(<) : $(_yy) ;	# real
 DEPENDS $(3) : $(_yy) ;	# dummy
 DEPENDS $(<) : $(3) ;		# dummy

 Clean reallyclean : $(<) $(2) ;
}
actions XorpYaccC++Mv1
{
 $(XYACC) $(XYACCFLAGS) -o $(<:BS=.c) $(>)
 $(MV) $(<:BS=.c) $(<)
}

############################################################################
#
# XorpFlexC++
# Usage:  XorpFlexC++ ccfile : prefix : lexfile ;
#
# Generate C++ source from a Flex C++ lexer description file (.ll).
# This rule should be braced within a conditional when used, so as to
# avoid building them automatically.
# Use 'jam reallyclean' to remove generated code.
#
rule XorpFlexC++
{
 local _ll = $(3) ;

 SEARCH on $(_ll) = $(SEARCH_SOURCE) ;	# source .ll file
 #MakeLocate $(<) : $(LOCATE_SOURCE) ;	# generated sources

 DEPENDS $(<) : $(_ll) ;	# real
 DEPENDS $(2) : $(_ll) ;	# dummy
 DEPENDS $(<) : $(2) ;		# dummy

 XFLEXFLAGS on $(<) = "-P$(2)" ;
 XorpFlexC++1 $(<) : $(_ll) ;

 Clean reallyclean : $(<) ;
}
actions XorpFlexC++1
{
 $(XFLEX) $(XFLEXFLAGS) -o$(<) $(>)
}

############################################################################
#
# SubIncludeOnce
# Usage: SubIncludeOnce TOP dirname .. dirn ;
#
# This rule should be used to make sure each Jamfile is referenced only
# once from any other part of the tree. This is the magic which makes
# possible Jam's graph-recursive, rather than tree-recursive, builds.
#
rule SubIncludeOnce
{
    local includepath = [ FDirName $(<[2-]) ] ;
    local path = $(includepath:R=$($(<[1]))) ;

    if ! $($(path)-subinclude)
    {
        # not included before, so do it now.
        $(path)-subinclude = TRUE ;
        if $(VERBOSE)
        {
            ECHO "SubInclude: including" $(JAMFILE:D=$(path)) ;
        }
        include $(JAMFILE:D=$(path)) ;
    }
    else
    {
        if $(VERBOSE)
        {
            ECHO "SubInclude: already included" $(JAMFILE:D=$(path)) ;
        }
    }
}

############################################################################
#
# XorpUnitTests
# Usage: XorpUnitTests test_foo .. test_bar ;
#
# Rudimentary support for running regression tests.
# Strictly UNIX only for the time being.
# Use jam -sRUN_CHECK=1 check to use this.
#
rule XorpUnitTests
{
 if $(RUN_CHECK) {
	#NOTFILE check ;

	local thisdir = $(SEARCH_SOURCE) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	#SEARCH on $(<) = $(LOCATE_TARGET) ;	# XXX should really use this

	ECHO "XorpUnitTests: executing tests in" $(thisdir) ;

	DEPENDS check : $(<) ;
	ALWAYS $(<) ;

	for test-file in $(<)
	{
		ECHO "XorpUnitTests: executing" $(test-file) ;
		SEARCH on $(test-file) = $(SEARCH_SOURCE) ;
		XorpUnitTest1 $(test-file) ;
	}
 }
}
actions piecemeal XorpUnitTest1
{
	PATH="$PATH:."
	$(<)
}

############################################################################
#
# GMake
# Usage: GMake gmakefiletarget ;
#
# This is a special rule and action to invoke gmake from within a directory.
# PLEASE AVOID USING GMAKE AS IT CAN POTENTIALLY BREAK PARALLELIZED BUILDS.
# Previously used to build libtecla.
#
#GMAKE ?= gmake ;
#rule GMake
#{
#	if $(GMAKE)
#	{
#		SEARCH on $(<) = $(SEARCH_SOURCE) ;
#		LOCATE on $(<) = $(SEARCH_SOURCE) ;
#		GMake1 $(<) : $(>) ;
#	}
#	# Should print an error if gmake is not found.
#}
#actions GMake1
#{
#	$(GMAKE) -C $(SEARCH) $(>)
#}

############################################################################
#
# With Jam/MR, the UserObject rule may be overridden to extend Jam's
# behaviour. This is Jam's analogue to make's built-in suffix rules.
#
# These are special UserObject rules which allow us to declare dependencies
# directly on the .xrl and .tgt files used to describe the XRLs when
# defining Library targets.
#
# Due to how the UserObject rule works in Jam, the intermediate object
# files which are generated by the suffix rules will not contain the
# _base or _xif suffixes which they did in the Automake-based build.
#
# Unfortunately this makes life difficult if we need to reference the
# objects or source files themselves from outside their subtrees...
# ...but it does make building all the xrl stubs very easy!
#
# Because we need the intermediate nodes on that part of the dependency
# graph from elsewhere in the tree, we don't use UserObject to build
# the XRL stubs; we use custom rules defined elsewhere in this file.
#
#rule UserObject
#{
# switch $(>) {
# case *.xif :	Object $(>:S=_xif.o) : $(<:S=_xif.cc) ;
#		XorpXrlXif $(<:S=_xif.cc) $(<:S=_xif.hh) : $(>) ;
# case *.tgt :	Object $(<) : $(<:S=_base.cc) ;
#		XorpXrlTgt $(<:S=_base.cc) : $(>) ;
# case * :	ECHO "unknown suffix on" $(>) ;
# }
#}
