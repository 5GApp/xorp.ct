#Copyright (c) 2009 XORP, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, Version 2, June
# 1991 as published by the Free Software Foundation. Redistribution
# and/or modification of this program under the terms of any other
# version of the GNU General Public License is not permitted.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. For more details,
# see the GNU General Public License, Version 2, a copy of which can be
# found in the XORP LICENSE.gpl file.
#
# XORP Inc, 2953 Bunker Hill Lane, Suite 204, Santa Clara, CA 95054, USA;
# http://xorp.net

# $ID$

# TODO tone down linker line spamming, -lpcre etc; stage use of LIBS please.
# TODO cross compiles.
# TODO Add separate toolchain test for C99 varargs macros.
# TODO Add separate toolchain test for GNU varargs macros.
# TODO Fix default include/lib paths, pass in from environment.
# TODO Merge scons-unfamiliar syntactic sugar from YHC's sconsfiles.
# TODO conditionalize new directory layout here

gnutoolwarning = """
WARNING: The GNU %s was not detected on your system.
Some combinations of linker or compiler flags, specific to building XORP,
may not function correctly.
"""

# The XRL tgt-gen and clnt-gen scripts use Python 2.3+'s optparse
# class.
EnsurePythonVersion(2, 3)

# SCons 0.98.4 is the earliest release that we have tested.  Earlier
# ones may work.  If so, please submit a Trac issue so the check can
# be relaxed.
EnsureSConsVersion(0, 98, 4)

Help("""
    builddir=<some path> to specify a different build directory.
        Default is "obj/<arch>-<os>-<rel>".
""")

import sys
import os
import string
import subprocess
import fnmatch

import SCons
from SCons.Script.SConscript import SConsEnvironment
import SCons.Action
import SCons.Builder

vars = Variables()

vars.AddVariables(
    BoolVariable('shared', 'build with shared libraries', True),
    BoolVariable('strip',  'strip executables and libraries when installed', False),
    BoolVariable('rtld_origin', 'Use ORIGIN in dynamically linked programs', False),
    BoolVariable('ignore_check_errors', 'Ignore errors when building tests', False),
    BoolVariable('debug_stl',  'Build with checked STL operations', False),
    BoolVariable('debug_msg',  'Build with debug messages', False),
    BoolVariable('debug_fn',  'Build with function names in debug_msg output', False),
    BoolVariable('debug_cb',  'Build with callback debugging', False),
    BoolVariable('debug_xrldb',  'Build with runtime XRL syntax validation in Router Manager', False),
    EnumVariable('debug', 'Build with debug symbols', 'full',
                 allowed_values=('no', 'yes', 'full', 'override'),
                 map={}, ignorecase=2),
    EnumVariable('optimize', 'Build with optimization', 'yes',
                 allowed_values=('no', 'yes', 'full', 'size', 'override'),
                 map={}, ignorecase=2),
    EnumVariable('profile', 'Build with profiling', 'no',
                 allowed_values=('no', 'gprof', 'pprof', 'override'),
                 map={}, ignorecase=2),
    PathVariable('prefix', 'Install prefix',
                 '/usr/local/xorp', PathVariable.PathAccept),
    )

def log_args(afname):
    f = open(afname, 'w')
    for a in ARGUMENTS.iteritems():
        print >>f, "%s=%s" % a,
    print >>f
    f.close()

def tgt_guess():
    p = subprocess.Popen(['./config.guess'], stdout=subprocess.PIPE)
    o = p.communicate()[0]
    if p.returncode != 0:
        Exit(1)
    return o.strip()

def tgt_canonicalize(alias):
    p = subprocess.Popen(['./config.sub', alias], stdout=subprocess.PIPE)
    o = p.communicate()[0]
    if p.returncode != 0:
        Exit(1)
    return o.strip()

build_alias = ARGUMENTS.get('build', None)
if build_alias == None:
    build_alias = tgt_guess()
build = tgt_canonicalize(build_alias)
(build_cpu, build_vendor, build_os) = build.split('-', 2)
    
host_alias = ARGUMENTS.get('host', None)
if host_alias == None:
    host_alias = build_alias
host = tgt_canonicalize(host_alias)
(host_cpu, host_vendor, host_os)  = host.split('-', 2)


sourcedir=Dir(".").abspath
builddir=Dir(ARGUMENTS.get('builddir', '#obj/' + host)).abspath

SConsignFile(builddir + '/.sconsign')

log_args(builddir + '/.scons_build_args')

env = Environment(
		  TOOLS = ['default', 'autotest', 'clntgen', 'tgtgen',
		           'TOOL_SUBST'],
		  ENV = os.environ,
		  BUILDDIR = builddir,
		  CPPPATH=['/usr/sfw/include', '/opt/local/include', '/usr/local/include', '$BUILDDIR'],
		  LIBPATH=['/usr/sfw/lib', '/opt/local/lib', '/usr/local/lib'],
		  variables = vars)

prefix = env['prefix']

print 'Build System Type: ', build
print 'Host System Type:  ', host
print 'Source path:       ', sourcedir
print 'Build path:        ', builddir
print 'Install prefix:    ', prefix

env['DESTDIR'] = ARGUMENTS.get('DESTDIR', '')

# Provide mechanism to override CC, CXX, etc.
if ARGUMENTS.get('CC', None):
    env['CC'] = ARGUMENTS.get('CC')
print 'CC:               ', env['CC']

if ARGUMENTS.get('CXX', None):
    env['CXX'] = ARGUMENTS.get('CXX')
print 'CXX:              ', env['CXX']

env['STRIP'] = ARGUMENTS.get('STRIP', 'strip')
print 'STRIP:            ', env['STRIP']

if env['strip']:
    env['strip'] = True
print 'Strip binaries:   ', env.has_key('strip')

# POSIX strip has no options by the strict letter of the law.
# Assume we have GNU binutils strip until proven otherwise.
gnustrip = True
env['_STRIP_UNNEEDED'] = ""
if gnustrip:
    env['_STRIP_UNNEEDED'] = "--strip-unneeded"

# User can override this. Defaults to gcc's -O1, as this trims
# most of the template fat.
print 'Optimize code:    ', env['optimize']

# Default to disable; wrapper for compiler profiling support.
print 'Profile code:     ', env['profile']

# Most of our shared library tweaks are specific to GNU ld.
# Check if the GNU linker is available, and print a warning if not.
if env['shared']:
    if SCons.Tool.FindTool(['gnulink'], env) is None:
        print gnutoolwarning % 'ld linker'
    env['SHAREDLIBS'] = "defined"
print 'Shared libraries: ', env.has_key('SHAREDLIBS')
print 'Use rtld ORIGIN:  ', env['rtld_origin']

# AUTOTEST_SKIP_ERRORS is SetDefault() by site_scons/site_tools/autotest.py,
# so print its value here.
if env['ignore_check_errors']:
    env['AUTOTEST_SKIP_ERRORS'] = True
print 'Ignore check errors: ', env['AUTOTEST_SKIP_ERRORS']

# NOTE: Enabling debug messages for the whole tree may not be what you want,
# as it can lead to premature timeouts.
# Enabling callback debugging is currently not advised as it does
# inline printfs.
print 'Debug symbols:    ', env['debug']
print 'Debug STL:        ', env['debug_stl']
print 'Debug messages:   ', env['debug_msg']
print 'Debug function names: ', env['debug_fn']
print 'Debug callbacks:  ', env['debug_cb']
print 'Debug XRL syntax: ', env['debug_xrldb']

env['CONFIGURELOG'] = str(builddir) + os.sep + 'config.log'
env['CONFIGUREDIR'] = str(builddir) + os.sep + '.sconf_temp'

SConsEnvironment.Chmod = SCons.Action.ActionFactory(os.chmod,
    lambda dest, mode: 'Chmod("%s", 0%o)' % (dest, mode))

def Symlink(src, link_name):
    try:
        os.unlink(link_name)
    except OSError:
        pass
    os.symlink(src, link_name)
SConsEnvironment.Symlink = SCons.Action.ActionFactory(Symlink,
    lambda src, link_name: 'Symlink("%s", as "%s")' % (src, link_name))

def InstallProgram(env, dest, files, perm = 0755):
    if env.has_key('DESTDIR'):
    	# NB: use simple concatenation
    	dest = env.Dir(env['DESTDIR'] + env.Dir(dest).path)
    obj = env.Install(dest, files)
    for i in obj:
	env.AddPostAction(i, env.Chmod(str(i), perm))
	if env['strip']:
	    env.AddPostAction(i, Action("$STRIP $TARGET"))
    return obj 
SConsEnvironment.InstallProgram = InstallProgram

def InstallScript(env, dest, files, perm = 0555):
    if env.has_key('DESTDIR'):
    	# NB: use simple concatenation
    	dest = env.Dir(env['DESTDIR'] + env.Dir(dest).path)
    obj = env.Install(dest, files)
    for i in obj:
	env.AddPostAction(i, env.Chmod(str(i), perm))
    return obj 
SConsEnvironment.InstallScript = InstallScript

def InstallLibrary(env, dest, files, perm = 0644):
    if env.has_key('DESTDIR'):
    	# NB: use simple concatenation
    	dest = env.Dir(env['DESTDIR'] + env.Dir(dest).path)
    obj = env.Install(dest, files)
    for i in obj:
	env.AddPostAction(i, env.Chmod(str(i), perm))
	if env['strip']:
	    env.AddPostAction(i, Action("$STRIP $_STRIP_UNNEEDED $TARGET"))
    return obj
SConsEnvironment.InstallLibrary = InstallLibrary

def InstallData(env, dest, files, perm = 0644):
    if env.has_key('DESTDIR'):
    	# NB: use simple concatenation
    	dest = env.Dir(env['DESTDIR'] + env.Dir(dest).path)
    obj = env.Install(dest, files)
    for i in obj:
	env.AddPostAction(i, env.Chmod(str(i), perm))
    return obj
SConsEnvironment.InstallData = InstallData

#
# GNU-style package paths.
#
# These are not parsed using PathVariable() above, to avoid confusion
# on the part of the user, as their default values are derived
# from 'prefix'.
# Not all of them are used at the moment.
#
env['exec_prefix'] = ARGUMENTS.get('exec_prefix', '$prefix')
env['sbindir'] = ARGUMENTS.get('sbindir', '$exec_prefix/sbin')
env['libexecdir'] = ARGUMENTS.get('libexecdir', '$exec_prefix/lib')
env['datarootdir'] = ARGUMENTS.get('datarootdir', '$prefix/share')
env['datadir'] = ARGUMENTS.get('datadir', '$datarootdir/xorp')
env['sysconfdir'] = ARGUMENTS.get('sysconfdir', '$prefix/etc')
env['localstatedir'] = ARGUMENTS.get('localstatedir', '$prefix/var')
env['libdir'] = ARGUMENTS.get('libdir', '$exec_prefix/lib')
env['mandir'] = ARGUMENTS.get('mandir', '$datarootdir/man')

#
# XORP internal package paths.
#
# These are the paths actually used to build the package image
# when installed in its destination directory.
# Most of these paths are derived from the GNU-style variables above.
#
# The image layout is intended to be FHS 2.3 compliant, for the benefit
# of 3rd party packagers and distributors.
#
env['xorp_confdir']     = env['sysconfdir']		# path to xorp.conf
env['xorp_libdir']      = env['libdir']  + '/xorp/lib'	# Shared libraries
env['xorp_moduledir']   = env['libdir']  + '/xorp/sbin'	# Protocol modules
env['xorp_sbindir']     = env['sbindir']		# End-user binaries
env['xorp_templatedir'] = env['datadir'] + '/templates'
env['xorp_tooldir']     = env['libdir']  + '/xorp/bin'	# tools/*
env['xorp_xrlsdir']     = env['datadir'] + '/xorp/xrls'	# *.xrls

# XXX needed by scons xrl idl wrappers
# ...and rtrmgr/util.cc
# XXX Push this down...
env['XORP_SOURCEDIR'] = sourcedir
env['XORP_BUILDDIR'] = builddir

# turnoff bgp, olsr for now.
# XXX bgp is always built, olsr never built.
env['WITH_BGP'] = ARGUMENTS.get('enable-bgp', False)
env['WITH_OLSR'] = ARGUMENTS.get('enable-olsr', False)

########## start configure magic

if not env.GetOption('clean') and not env.GetOption('help'):

    env['MISSING_DEPS'] = []
    env['SKIPPED_DEPS'] = []

    from config.endian import CheckEndianness
    from config.member import CheckTypeMember
    from config.sysctl import CheckSysctl
    from config.boost import CheckBoost, CheckBoostLibrary

    my_custom_tests = {
	'CheckBoost'        : CheckBoost,
	'CheckBoostLibrary' : CheckBoostLibrary,
	'CheckEndianness'   : CheckEndianness,
	'CheckTypeMember'   : CheckTypeMember,
	'CheckSysctl'       : CheckSysctl
    }

    conf = env.Configure(config_h = str(builddir) + '/xorp_config.h',
			 log_file = str(builddir) + '/config.log',
			 custom_tests = my_custom_tests) 

    ##########
    # target os

    # friendly name of target
    osname = host_os
    if fnmatch.fnmatch(host_os, 'freebsd*'):
        osname = "FreeBSD"
        conf.Define('HOST_OS_FREEBSD')
        conf.Define('ENABLE_ADVANCED_MULTICAST_API')
    elif fnmatch.fnmatch(host_os, 'linux*'):
        osname = "Linux"
        conf.Define('HOST_OS_LINUX')
        conf.Define('HAVE_PROC_LINUX')
        conf.Define('ENABLE_ADVANCED_MULTICAST_API')
    elif fnmatch.fnmatch(host_os, 'netbsd*'):
	osname = "NetBSD"
	conf.Define('HOST_OS_NETBSD')
        conf.Define('ENABLE_ADVANCED_MULTICAST_API')
    elif fnmatch.fnmatch(host_os, 'sunos*'):
        osname = "Solaris"
        conf.Define('HOST_OS_SOLARIS')
    else:
	osname = sys.platform.upper()
    conf.Define('HOST_OS_NAME', '"' + osname + '"')

    # toolchain
    conf.Define('CPP_SUPPORTS_C99_VA_ARGS')
    conf.Define('CPP_SUPPORTS_GNU_VA_ARGS')

    # Boost
    #env['boost_suffix'] = "-mt"		# Not for FreeBSD
    #conf.CheckBoost(require_version='1.39')
    #conf.CheckBoostLibrary('system')
    #conf.CheckBoostLibrary('date_time')
    #conf.CheckBoostLibrary('iostreams')

    # Additional Boost libraries
    #conf.CheckBoostLibrary('filesystem')
    #conf.CheckBoostLibrary('program_options')
    #conf.CheckBoostLibrary('regex')
    #conf.CheckBoostLibrary('signals')
    #conf.CheckBoostLibrary('thread')

    # Big ball of mud.
    from config.allconfig import DoAllConfig
    DoAllConfig(env, conf, host_os)

    # Note: hard-coded paths pushed down to rtrmgr/util.cc environment.

    # Print warnings about missing/skipped dependencies.
    if env['MISSING_DEPS']:
        print '\nRequired dependencies not found, exiting:\n   - %s' % '\n   - '.join(env['MISSING_DEPS'])
        if env['SKIPPED_DEPS']:
            print 'Optional dependencies not found:\n   - %s' % '\n   - '.join(env['SKIPPED_DEPS'])
        Exit(1)

    if env['SKIPPED_DEPS']:
        print 'Optional dependencies not found:\n   - %s' % '\n   - '.join(env['SKIPPED_DEPS'])

    conf.Finish()

########## end configure magic

if SCons.Tool.FindTool(['gcc'], env) is None or \
   SCons.Tool.FindTool(['g++'], env) is None:
    print gnutoolwarning % 'gcc or g++ compiler'

env.AppendUnique( CFLAGS = Split(ARGUMENTS.get('CFLAGS', '')) )
env.AppendUnique( CXXFLAGS = Split(ARGUMENTS.get('CXXFLAGS', '')) )
env.AppendUnique( LINKFLAGS = Split(ARGUMENTS.get('LINKFLAGS', '')) )

# If the user didn't override our default optimization, then
# sanitize user's CFLAGS/CXXFLAGS to not contain optimization options,
# and map to an appropriate GCC flag.
if not env['optimize'] == 'override':
    env.Replace( CFLAGS = filter(lambda s: not s.startswith('-O'),
                                 Split(env['CFLAGS'])))
    env.Replace( CXXFLAGS = filter(lambda s: not s.startswith('-O'),
                                   Split(env['CXXFLAGS'])))
    bigodict = { 'no': '-O0', 'yes': '-O1', 'full': '-O2', 'size': '-Os' }
    bigoflag = bigodict[env['optimize']]
    if not env['optimize'] == 'no':
        env.AppendUnique(CFLAGS = [ bigoflag ])
        env.AppendUnique(CXXFLAGS = [ bigoflag ])

# Do the same for the flags which control debug symbols.
if not env['debug'] == 'override':
    env.Replace( CFLAGS = filter(lambda s: not s.startswith('-g'),
                                 Split(env['CFLAGS'])))
    env.Replace( CXXFLAGS = filter(lambda s: not s.startswith('-g'),
                                   Split(env['CXXFLAGS'])))
    gdict = { 'no': '', 'yes': '-g', 'full': '-g3' }
    gflag = gdict[env['debug']]
    if not env['debug'] == 'no':
        env.AppendUnique(CFLAGS = [ gflag ])
        env.AppendUnique(CXXFLAGS = [ gflag ])

# Do the same for the flags which control code profiling.
if not env['profile'] == 'override':
    if env['profile'] == 'gprof' and env.has_key('SHAREDLIBS'):
        print """
WARNING: You have requested GNU gprof style profiling
and shared libraries. This is UNSUPPORTED, and probably will not link.
"""
    strip_pg_flags = [ '-pg', '-finstrument-functions', '-fno-omit-frame-pointer', '-fno-optimize-sibling-calls' ]
    env.Replace( CFLAGS = filter(
	lambda s: not s.startswith(tuple(strip_pg_flags)),
	Split(env['CFLAGS']))
    )
    env.Replace( CXXFLAGS = filter(
	lambda s: not s.startswith(tuple(strip_pg_flags)),
	Split(env['CXXFLAGS']))
    )
    # Full use of profiling may require more than one flag, so Split() them.
    pgdict = {'no': '',
              'gprof': '-pg',
              'pprof': '',
    }
    pgflag = pgdict[env['profile']]
    if not env['profile'] == 'no':
        pgflags = pgflag + ' -fno-omit-frame-pointer -fno-optimize-sibling-calls'
        env.AppendUnique( CFLAGS = Split(pgflags))
        env.AppendUnique( CXXFLAGS = Split(pgflags) )
        # Using gprof requires we link with the '-pg' option.
        if env['profile'] == 'gprof':
            env.AppendUnique( LINKFLAGS = Split(pgflag) )
        # Using pprof requires we link with the '-lprofiler' library
        # from the Google Performance Tools package. To avoid having
        # to insert calls to the profiler, use the environment
        # variable CPUPROFILE when running the program.
        # If you do insert calls, please bracket them with WITH_PPROF.
        if env['profile'] == 'pprof':
            env.AppendUnique( LIBS = [ 'profiler' ] )
            #env.AppendUnique( CPPDEFINES = [ 'WITH_PPROF' ] )

env.AppendUnique(CPPDEFINES = [
    ( '_FORTIFY_SOURCE', 0 ),
    ])

# NOTE: gcc specific flags.
env.AppendUnique(CFLAGS = [
    '-Werror',
    '-W',
    '-Wall',
    '-Wwrite-strings',
    '-Wbad-function-cast',
    '-Wmissing-prototypes',
    '-Wcast-qual',
    '-Wmissing-declarations',
    '-Wpointer-arith',
    '-Wcast-align',
    '-Wstrict-prototypes',
    '-Wnested-externs',
    '-pipe',
    ])

env.AppendUnique(CXXFLAGS = [
    '-Werror',
    '-W',
    '-Wall',
    '-Wwrite-strings',
    '-Wcast-qual',
    '-Wpointer-arith',
    '-Wcast-align',
    '-Woverloaded-virtual',
    '-ftemplate-depth-25',
    '-pipe',
    ])

# NOTE: For GNU STL only at this time.
if env['debug_stl']:
    env.AppendUnique(CXXFLAGS = [
        '-D_GLIBCXX_DEBUG',
        '-D_GLIBCXX_DEBUG_PEDANTIC',
    ])

# NOTE: DEBUG_LOGGING_GLOBAL currently a no-op.
if env['debug_msg']:
    env.AppendUnique(CFLAGS = [
        '-DDEBUG_LOGGING',
    ])
    env.AppendUnique(CXXFLAGS = [
        '-DDEBUG_LOGGING',
    ])

if env['debug_fn']:
    env.AppendUnique(CFLAGS = [
        '-DDEBUG_PRINT_FUNCTION_NAME',
    ])
    env.AppendUnique(CXXFLAGS = [
        '-DDEBUG_PRINT_FUNCTION_NAME',
    ])

if env['debug_cb']:
    env.AppendUnique(CFLAGS = [
        '-DDEBUG_CALLBACKS',
    ])
    env.AppendUnique(CXXFLAGS = [
        '-DDEBUG_CALLBACKS',
    ])

#
# Fixup shared library paths.
# Shared libraries are installed in $xorp_libdir by default.
#
# If rtld_origin is True, the linker will be passed a relative RPATH.
# This allows the package itself to be relocated in the filesystem
# as a whole.
#
if env.has_key('SHAREDLIBS'):
    if env['rtld_origin']:
	# Build a subdirectory for holding symlinks to libraries upfront, so
	# that binaries about to be built can be run from inside the BUILDDIR.
	# Build a further alias for the benefit of entities installed
	# in $xorp_sbindir.
	Execute(Mkdir(builddir + '/lib'))
	Execute(Mkdir(builddir + '/lib/xorp'))
	Execute(env.Symlink(builddir + '/lib', builddir + '/lib/xorp/lib'))

	# Tell rtld to turn on $ORIGIN processing by default.
	# NOTE: GNU ld specific flag.
	env.PrependUnique( LINKFLAGS = [ '-Wl,-z,origin' ] )

	#
	# Now fixup the RPATH.
	# FIXME This is not correct for all binaries. Some
	# get installed in locations other than $bindir.
	# The RPATH actually needs to get re-evaluated on each
	# binary target, depending on how far down they get installed.
	#
	#rellibdir = os.path.relpath(env.Dir('$libdir').abspath,
	#			    env.Dir('$bindir').abspath)
	rellibdir = '../lib'
	env.AppendUnique(RPATH = [
	    env.Literal(os.path.join('\\$$ORIGIN', rellibdir))
	])
    else:
	# Hardcode the RPATH to our final destination.
	# Developers will need to set LD_LIBRARY_PATH until they install.
	env.AppendUnique(RPATH = [
	    #'$xorp_libdir',
	    '$libdir',
	])

# Export global symbols as dynamic in executables for runtime backtraces
# w/o GDB or corefiles in production deployments.
# NOTE: GNU ld specific flag.
env.AppendUnique(LINKFLAGS = [
    '-rdynamic',
    ])

env.SConscript(['SConscript'], variant_dir='$BUILDDIR', exports='env', duplicate=0)

env.Help(vars.GenerateHelpText(env))
