%
% $XORP: xorp/docs/design_arch/error_handling.tex,v 1.17 2003/04/16 00:25:22 jcardona Exp $
%

\documentclass[11pt]{article}
\usepackage{xspace}
\usepackage{times}
\usepackage{psfig}
\usepackage{amsmath}
\usepackage{graphicx}
\newcommand{\xorp} {{\em XORP}\@\xspace}
\newcommand{\module} {{\em module}\@\xspace}
\newcommand{\modules} {{\em modules}\@\xspace}
\newcommand{\finder} {{\em Finder}\@\xspace}
\newcommand{\xorpsh} {{\em Xorpsh}\@\xspace}
\newcommand{\cm} {{\em CM}\@\xspace}
\newcommand{\xrl} {{\em XRL}\@\xspace}
\newcommand{\rtrmgr} {{\em rtrmgr}\@\xspace}

\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}

\textwidth 6.5in
\topmargin 0.0in
\textheight 8.5in
\headheight 0in
\headsep 0in
\oddsidemargin 0in
%\date{}
\title{Error Handling in XORP}
%\author{Atanu Ghosh}
%\twocolumn
\begin{document}
\parsep 0ex
\parskip 1.0ex
\parindent 0em
\noindent
\maketitle                            
\section{Introduction}

A \xorp router is made up of a number of processes that communicate
via XRLs \cite{xorp:xrl} (a messaging system developed for \xorp). In
this document we will focus on how to deal with errors that are
generated directly or indirectly by \xrl calls, and discuss how to
handle process failures and the subsequent restart of failed
processes.  Of course, in an ideal world processes would not fail, but
when they do fail, our goals are to keep as much router
functionality working as possible, to avoid permanent inconsistencies
at all costs, and for the remainder of the functionality to be
restored as quickly as possible.

Many \xorp processes share routing state that must remain
synchronised. For example, the BGP process sends the result of its
routing decisions to the RIB process, which passes these routes on to
the FEA and hence to the forwarding engine's Forwarding Information
Base (FIB). If the RIB process fails then BGP would lose the ability
to manipulate the FIB, and forwarding would not match the BGP routing
table.  Thus BGP should withdraw all routes that it told its peers, or
more catastrophically it might drop all peerings until the RIB has
successfully restarted.

A critical component if the system is the router manager process
(\rtrmgr) which is responsible for starting and stopping routing
processes. When a process is started by the \rtrmgr or dies, that
process's XRL client library ensures that the \finder is notified. If
a process has an interest in the status of another process it can
register interest with the \finder.

In any complex system such as a \xorp router errors can occur. These
errors can range from a \xorp process simply failing, to an attempt to
install a route into the forwarding engine that already exists. Errors
will occur and need to be dealt with in a consistent manner. The types
of error that may occur are categorised below.

The first type of error is {\em Process failure}.

The second type of error is {\em Communication Error}. At the most
basic level an attempt to send an \xrl has failed. The process that
was the recipient of the \xrl may have failed or be slow to respond.
The message that was being sent may have been lost in transit.

The third type of error, {\em Execution Error}, is when an XRL call
returns an error due to some underlying interaction failure. The most
fundamental example of this type of error is a route add failing. The
attempt to add a route may fail for many reasons. The route may
already be present or a different route may be installed. The error
may occur due to a bug in the router code or because routing state has
been manipulated by non \xorp processes.

The fourth type of error, {\em Type Error}, is when an XRL call fails
because the arguments passed to an XRL are invalid. This error will
most likely be due to a version mismatch between \xorp processes. If
all the processes in a \xorp router have been built from the same
source tree this error should not occur. As we are building an
extensible router it may be the case that a process built from a
different source tree may encounter compatibility problems.

\section{\label{pfailure}Process Failure}

A \xorp router is made up of a number of distinct processes. There are
dependencies between these processes. We define the critical
dependencies and what action to take on detecting failure.

The most critical component of a \xorp router is the \rtrmgr/\finder
process. One of the functions of this component is to start/re-start
processes. If process A is dependent on the status (alive, dead,
restarted) of process B, then process A registers this interest with
the \finder. This dependency on the \rtrmgr/\finder for managing and
monitoring process state means that a \xorp router cannot survive the
failure of this process. A \xorp process that detects the loss of the
\finder must exit. There is one exception to this rule, the \xorpsh
process, that will be discussed later in section \ref{xorpsh}.

Each process in a \xorp router is described with how it should behave
when another process in the system fails. Processes can explicitly
register interest in the status of other processes through the
\finder. If process A is dependent on the state of process B then
process A must register interest in process B.

The only mechanism that a process should use to determine another
process's failure is notification from the \finder.

It is conceivable that the \finder could restart and, in the same time
window, another monitored process could restart, in which case the
restarting of the monitored process could be missed. To guard against
this possible race, if the \finder fails or restarts, all processes
should exit. The assumption is that the \finder failing is a very low
probability event.

\subsection{Implementing process failure detection}

The \finder process will send keepalive messages to all processes at
thirty second intervals. If a process does not respond to a keepalive
it is considered dead. The keepalive messages are sent over a reliable
transport such as TCP. A process dying should therefore be easy to
detect. The \rtrmgr, if it detects that a process has died, will send a
hint to the \finder, which will immediately try and send a keepalive.
Again if the process has died it should be easy to detect.

If a process is not responding to keepalives but it is still alive, it
will be marked as dead and all interested processes will be notified.
Most importantly, the \rtrmgr will be notified and it will kill the
running process and start a new process.

\subsection{Actions to take on detecting process failure}

Table \ref{failure_table} indicates what action a process should take
on detecting failure in other processes. The ``(G)'' denotes that the
process should attempt to exit gracefully. Figure \ref{failure_fig}
shows the relationship between the various processes. The thick arrows
should be modelled as a signal sent from a process dying to its
dependent processes.

\begin{figure}
  \begin{center}
    \includegraphics[width=0.9\textwidth]{figs/error_dependency.eps}
    \caption{Process relationship on failure}
    \label{failure_fig}
  \end{center}
\end{figure}

\begin{table}[ht]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
Process fails   &                 &          &      &      &      &         &      &      &      &         \\\hline
                & \rtrmgr/        & FEA      & MFEA & RIB  & IGMP & PIM     & BGP  & RIP  & OSPF & \xorpsh \\
                & \finder         &          &      &      &      &         &      &      &      &         \\\hline
\rtrmgr/        & /               & Withdraw & Exit & Exit & Exit & Exit    & Exit & Exit & Exit & Report  \\
\finder         &                 & All      &      &      &      &         &      &      &      & Problem \\
                &                 & Unicast  &      &      &      &         &      &      &      & Wait    \\
                &                 & Routes   &      &      &      &         &      &      &      &         \\
                &                 & Exit     &      &      &      &         &      &      &      &         \\\hline
FEA             &  Restart        & /        & Exit & Exit & Exit & Exit    & Exit & Exit & Exit & -       \\\hline
MFEA            &  Restart        & -        & /    & -    & Exit & Exit    & -    & -    & -    & -       \\\hline
RIB             &  Restart        & Withdraw & /    & -    & Exit & Exit    & Exit & Exit & Exit & -       \\
                &                 & All      &      &      & (G)  & (G)     & (G)  & (G)  & (G)  &         \\
                &                 & Unicast  &      &      &      &         &      &      &      &         \\
                &                 & Routes   &      &      &      &         &      &      &      &         \\\hline
IGMP            &  Restart        & -        & -    & -    & /    & Delete  & -    & -    & -    & -       \\
                &                 &          &      &      &      & Local   &      &      &      &         \\
                &                 &          &      &      &      & Members &      &      &      &         \\
                &                 &          &      &      &      & After   &      &      &      &         \\
                &                 &          &      &      &      & Timeout &      &      &      &         \\\hline
PIM             &  Restart        & -        & -    & -    & -    & /       & -    & -    & -    & -       \\\hline
BGP             &  Restart        & -        & -    & -    & -    & -       & /    & -    & -    & -       \\\hline
BGP             &  Restart        & -        & -    & -    & -    & -       & /    & -    & -    & -       \\\hline
RIP             &  Restart        & -        & -    & -    & -    & -       & -    & /    & -    & -       \\\hline
OSPF            &  Restart        & -        & -    & -    & -    & -       & -    & -    & /    & -       \\\hline
\xorpsh         &  Restart        & -        & -    & -    & -    & -       & -    & -    & -    & /       \\\hline
\end{tabular}
\end{center}
\caption{\label{failure_table}Action to take on detecting process failure}
\end{table}

\subsubsection{\rtrmgr/\finder - Router manager}

If the \rtrmgr/\finder dies then all bets are off and all processes
should exit apart from the \xorpsh.

If a \xorp process exits unexpectedly the \rtrmgr/\finder should
attempt to restart the process.

\subsubsection{FEA - Forwarding Engine Abstraction}

The FEA primarily accepts routes from the RIB and places them in the
kernel. The FEA should tag all routes that it has installed in the
kernel. The FEA on restart should remove all routes that a previous
incarnation of the FEA has placed in the kernel. When an FEA is
exiting it should attempt to remove all routes that it has installed in
the kernel.

The FEA process should register interest in the RIB. If the RIB fails
the FEA should withdraw all routes that the RIB has sent to it.

\subsubsection{MFEA - Multicast Forwarding Engine Abstraction}

The MFEA is multicast analogue to the unicast FEA. If should be noted
that the MFEA and FEA are currently being merged.

Similar to the FEA, on restart or exit the MFEA should remove all
multicast forwarding entries that were installed in the kernel. Note
that the MFEA does not contain copy of the multicast forwarding entries
that were installed in the kernel, therefore it should utilize a
mechanism that removes all multicast forwarding entries at once. E.g, in
case of UNIX-based systems, closing the multicast routing socket will
automatically remove all entries.

If the multicast routing process that has installed the
multicast forwarding entries exits, then the MFEA should remove all
multicast forwarding entries from the kernel. Currently, PIM is the only
multicast routing process. In the future, XORP multicast routing
architecture may contain a special coordinator among all multicast
routing protocol instances. If that coordinator exits, the MFEA should
remove all multicast forwarding entries from the kernel.

\subsubsection{RIB - Routing Information Base}

Routes from the routing processes are sent to the RIB; the winners are
sent to the FEA.

The RIB should register interest in the FEA. If the FEA fails the RIB
should exit. All routing processes that interact with the RIB should,
on detecting the shutdown of the RIB, also terminate gracefully.

\subsubsection{IGMP/MLD}

If the FEA/MFEA process exits then this process should exit.

\subsubsection{PIM}

If the RIB or FEA/MFEA exits then this process should exit.

\subsubsection{BGP}

Currently the only other process in the system that BGP interacts
with is the RIB. If the BGP process detects that the RIB has died then
it should gracefully terminate its sessions and exit.

In the future the TCP connections that BGP makes will be mediated
through FEA, at which time the BGP process should also register
interest in the state of the FEA. If the BGP process detects the death
of the FEA it should exit immediately.

\subsubsection{RIP}

The RIP process should register interest in the FEA and the RIB. If
the RIB dies then the RIP process should attempt to exit gracefully.
If the FEA dies the RIP process should exit immediately.

\subsubsection{IS-IS}

The IS-IS process should register interest in the FEA and the RIB. If
the RIB dies then the IS-IS process should attempt to exit gracefully.
If the FEA dies the IS-IS process should exit immediately.

\subsubsection{OSPF}

The OSPF process should register interest in the FEA and the RIB. If
the RIB dies then the OSPF process should attempt to exit gracefully.
If the FEA dies the OSPF process should exit immediately.

\subsubsection{\label{xorpsh}\xorpsh}

The \xorpsh provides a command line interface to the XORP router.
Other processes in the system exiting should never cause it to
exit. The \rtrmgr/\finder process exiting should generate
warning output to the user and then the \xorpsh should wait for the
router to restart.

\section{XRL Communication Error}
Interprocess communication in \xorp is achieved using XRLs. In this
section we will consider what should be done when an XRL call fails
due to a communication error.

XRLs can be sent over unreliable transports such as UDP or reliable
transports such as TCP. The type of transport that should be used will
be specified when defining the interface. In the case of reliable
transport, the XRL library and transport mechanism together mask certain
errors, reducing the error cases that must be handled by the application.
The cost is generally higher latency and less flexibility.

All XRL calls will ultimately get a response. In the normal case the
response returns the status of the call (good or bad). In addition to
error responses produced by the application, the XRL library can also
return the following error responses:

\begin{itemize}

\item NO\_FINDER -- This error occurs when a \xorp process cannot find the
\finder. This error always indicates a serious problem with the router. The
application MAY treat this error as fatal.

\item TARGET\_FAILED -- This error occurs when a \xorp process tries to
communicate with another process that does not exist, or has not yet
initialized itself. The XRL library will, by default, hide transient
TARGET\_FAILED errors through a limited retransmission policy, in which
case TARGET\_FAILED errors indicate serious problems with the router. The
application MAY control this policy by changing the maximum retransmission
time, in order to handle any necessary retransmissions itself.

\item RESOLVE\_FAILED -- This error occurs when a \xorp process tries to
communicate with a nonexistent interface on another process. That is, the
XRL's target process does exist, but the target does not implement the
requested interface. RESOLVE\_FAILED generally indicates a version mismatch
between two processes. This error may be considered fatal, or (for example)
the application might react by trying to access an older version of the
interface. The application can expect, however, that RESOLVE\_FAILED errors
are not transient: If an XRL access gets a RESOLVE\_FAILED error, then that
XRL will always result in a RESOLVE\_FAILED error, at least until the
target process restarts.

\item SEND\_FAILED -- This error occurs when the XRL library temporarily
cannot send a particular XRL. Usually, this will be because of congestion
or a slow receiver: the kernel has run out of buffer space. Note that the
XRL library performs some buffering itself, to ensure that XRL requests are
either completely transmitted or not transmitted at all. (There's no such
thing as a SEND\_PARTIALLY\_FAILED error.)

\item REPLY\_TIMED\_OUT -- This error occurs in unreliable transmit only.
It happens when the XRL library's timeout for a given request has expired.
Possible reasons include network congestion, peer failure, network
interface failure, and so on. As in all network communications, when a
timeout occurs we don't know if the last unacknowledged XRL request was
received and processed by the peer.

\item FATAL\_TRANSPORT\_ERROR -- This error occurs when the XRL library's
connection to the relevant endpoint fails. For example, the TCP connection
has been reset, or a UDP connection gets a port-unreachable message. The
expectation is that no further communication with the specific endpoint
will succeed.

The XRL library MAY hide certain REPLY\_TIMED\_OUT and
FATAL\_TRANSPORT\_ERROR errors for class targets (that is, targets that do
not specify a particular process). These XRLs are used when any matching
process suffices. When communication with a particular instance of the
target fails, the XRL library thus MAY search for another instance by
contacting the \finder. The XRL library MUST NOT perform this
retransmission, however, unless it can guarantee that the request was not
acted on by any instance. (This rules out most unreliable transports.) If
it cannot guarantee this, or if retransmission fails, the XRL will get an
error -- either REPLY\_TIMED\_OUT, FATAL\_TRANSPORT\_ERROR, NO\_FINDER, or
TARGET\_FAILED.

\end{itemize}

NO\_FINDER, TARGET\_FAILED, and to some extent RESOLVE\_FAILED generally
represent serious problems with the router. FATAL\_TRANSPORT\_ERROR
represents a serious problem with the target, such as that an instance of
the target has died; this problem may or may not be transient. SEND\_FAILED
and REPLY\_TIMED\_OUT are potentially common errors, and should be handled
by the application. However, the likelihood of SEND\_FAILED can often be
reduced, making it a ``fatal'' error from the application's point of view,
by limiting the rate at which requests are sent.

The first four errors, NO\_FINDER, TARGET\_FAILED, RESOLVE\_FAILED, and
SEND\_FAILED, occur when there is no chance that the relevant XRL was
communicated to its target. They are therefore called \emph{send failures}.
The other two errors, REPLY\_TIMED\_OUT and FATAL\_TRANSPORT\_ERROR, may be
generated even if the target received the request. They are therefore
called \emph{receive failures}.

If a peer dies, we will receive notification of this explicitly and will
deal with it as specified in section \ref{pfailure}. Thus most XRL
transport errors SHOULD NOT be taken as an indication that the peer is
definitely dead. If an application cares that the peer has died or
restarted, it SHOULD register with the finder to receive notifications of
process restarts. Thus, a process SHOULD assume that an XRL transport
problem will be transient until it receives an explicit confirmation that
the destination has failed, particularly when the XRL interface is
unreliable.

In addition to an XRL interface being reliable or unreliable, the way
the application uses an XRL interface can by pipelined or
non-pipelined.  In the pipelined case, multiple requests can be
outstanding simultaneously; in the non-pipelined case at most one
request can be outstanding at a time.

It is useful for us to categorise XRL interfaces along these two axes:
reliable/unreliable and pipelined/non-pipelined. 

\subsection*{Unreliable, Non-pipelined}

If an XRL send failure occurs, the sending application MAY choose to
retransmit the XRL, or ignore the failure as it sees fit.  

In an XRL receive failure occurs, the sending application MAY also choose
to retransmit the XRL, or ignore the failure as it sees fit. However, if
the application chooses to re-send the XRL, the interface MUST be written
in such a way that the receipt of a duplicate request will not damage the
system. (XXX Isn't this true anyway? Network duplicates?)

\subsection*{Reliable, Non-pipelined}

If a SEND\_FAILED error occurs, the sending application MAY retransmit the
XRL.

FATAL\_TRANSPORT\_ERROR,  NO\_FINDER, and most TARGET\_FAILED and
RESOLVE\_FAILED errors are unrecoverable.
The application should cause this XRL interface to go dormant, in the
expectation that it will authoritatively discover from the finder that
the target has died.

REPLY\_TIMED\_OUT cannot happen on reliable interfaces.

\subsection*{Unreliable, Pipelined}

The same issues apply as with unreliable, non-pipelined, but the
situation is more complicated.  An interface that uses unreliable
transport and pipelining is one that explicitly permits loss \emph{and
re-ordering} of requests.  It is up to the application to choose
whether to retransmit XRLs that return SEND\_FAILED or REPLY\_TIMED\_OUT, but
the application must only do so if it is certain that the re-ordering
caused by retransmission will not be a problem.

\subsection*{Reliable, Pipelined}

The XRL library ensures that pipelined messages sent to a reliable target
are delivered in order. In particular, if a request $R$ to a given target
gets an error, then no \emph{outstanding} requests to that target
\emph{registered later than $R$} will successfully complete -- they will
all get the same error, and none of them will be delivered to the receiving
application. Once the error is delivered, this error state is wiped out,
and later requests to the target may succeed -- perhaps because the target
was restarted.

Again, FATAL\_TRANSPORT\_ERROR, NO\_FINDER, and most TARGET\_FAILED and
RESOLVE\_FAILED errors are unrecoverable.
The application SHOULD cause this XRL interface to go dormant, in the
expectation that it will authoritatively discover from the finder that
the target has died.

\section{Execution Error}

A XORP router is partitioned into many processes; most of the operating
system specific interactions are performed by the FEA. In a router the
most frequent operation will be the adding and deleting of routes.
Consider BGP adding a route. First the BGP process will send the route
to the RIB, then the route may be sent to FEA. If the addition of the
route from the RIB to the FEA fails, then there is no way of
propagating this failure back to the BGP process due to the
asynchronous nature of XRLs. If adding/deleting a route fails a very
drastic way of propagating this failure back to the BGP process would
be for either or both the FEA and RIB processes to exit, in which case
the process failure responses already described would be used and BGP
would exit. Process exit is an extreme response to failing
to add a route, but at least the error handling code for process exit
exists already. It is important though not
to mask over implementation problems by ignoring errors. In the rest
of this section we will outline how to deal with a number of common
errors.

\subsection{Adding/Deleting route failures}

As stated above, a highly likely error is failures when adding or
deleting routes. Typically the interaction will occur between the RIB
and FEA. When an error occurs it should be logged by the FEA and the
cause returned to the RIB. The RIB can be configured with policy on
how to react to different errors.

Adding a route will typically fail because a route already exists.
Firstly, if a route already exists it is either the same or different
to the one that we attempted to add. Secondly, either the FEA
installed the route or a third party installed it. Therefore when
adding a route fails the FEA should return if the current route is the
same or different to the one we attempted to add, as well as who
installed the route originally. The RIB on receiving the error state
from the FEA can decide as a matter of policy how to proceed. If an
attempt to add a route fails because a different route exists the RIB
could choose to delete the old route and add the new route.

The most common reason for a route deletion to fail would be that the
route is no longer present. The FEA should log that it has been asked
to delete a route that doesn't exist. The RIB should decide if this
problem should be considered fatal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     BIBLIOGRAPHY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{../tex/xorp}
\bibliographystyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
