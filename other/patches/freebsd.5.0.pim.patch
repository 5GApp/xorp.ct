Index: sys/conf/options
===================================================================
RCS file: /home/xorpc/u2/freebsd/src/sys/conf/options,v
retrieving revision 1.363
diff -u -r1.363 options
--- sys/conf/options	13 Nov 2002 09:42:25 -0000	1.363
+++ sys/conf/options	22 Nov 2002 00:53:04 -0000
@@ -316,6 +316,7 @@
 ETHER_8022		opt_ef.h
 ETHER_SNAP		opt_ef.h
 MROUTING		opt_mrouting.h
+PIM			opt_mrouting.h
 INET			opt_inet.h
 INET6			opt_inet6.h
 IPSEC			opt_ipsec.h
Index: sys/netgraph/ng_ksocket.c
===================================================================
RCS file: /home/xorpc/u2/freebsd/src/sys/netgraph/ng_ksocket.c,v
retrieving revision 1.34
diff -u -r1.34 ng_ksocket.c
--- sys/netgraph/ng_ksocket.c	14 Sep 2002 08:56:10 -0000	1.34
+++ sys/netgraph/ng_ksocket.c	22 Nov 2002 01:19:17 -0000
@@ -148,6 +148,7 @@
 	{ "swipe",	IPPROTO_SWIPE,		PF_INET		},
 	{ "encap",	IPPROTO_ENCAP,		PF_INET		},
 	{ "divert",	IPPROTO_DIVERT,		PF_INET		},
+	{ "pim",	IPPROTO_PIM,		PF_INET		},
 	{ "ddp",	ATPROTO_DDP,		PF_APPLETALK	},
 	{ "aarp",	ATPROTO_AARP,		PF_APPLETALK	},
 	{ NULL,		-1					},
Index: sys/netinet/in.h
===================================================================
RCS file: /home/xorpc/u2/freebsd/src/sys/netinet/in.h,v
retrieving revision 1.73
diff -u -r1.73 in.h
--- sys/netinet/in.h	29 Oct 2002 16:46:13 -0000	1.73
+++ sys/netinet/in.h	22 Nov 2002 01:05:13 -0000
@@ -430,6 +430,7 @@
  */
 #define	IPPROTO_MAXID	(IPPROTO_AH + 1)	/* don't list to IPPROTO_MAX */
 
+#if 0 /* XXX these should be nuked */
 #define	CTL_IPPROTO_NAMES { \
 	{ "ip", CTLTYPE_NODE }, \
 	{ "icmp", CTLTYPE_NODE }, \
@@ -484,6 +485,7 @@
 	{ 0, 0 }, \
 	{ "ipsec", CTLTYPE_NODE }, \
 }
+#endif
 
 /*
  * Names for IP sysctl objects
Index: sys/netinet/in_proto.c
===================================================================
RCS file: /home/xorpc/u2/freebsd/src/sys/netinet/in_proto.c,v
retrieving revision 1.62
diff -u -r1.62 in_proto.c
--- sys/netinet/in_proto.c	8 Nov 2002 23:37:50 -0000	1.62
+++ sys/netinet/in_proto.c	22 Nov 2002 02:51:52 -0000
@@ -38,6 +38,7 @@
 #include "opt_ipx.h"
 #include "opt_ipsec.h"
 #include "opt_inet6.h"
+#include "opt_mrouting.h"
 
 #include <sys/param.h>
 #include <sys/kernel.h>
@@ -56,6 +57,7 @@
 #include <netinet/ip_var.h>
 #include <netinet/ip_icmp.h>
 #include <netinet/igmp_var.h>
+#include <netinet/pim_var.h>
 #include <netinet/tcp.h>
 #include <netinet/tcp_timer.h>
 #include <netinet/tcp_var.h>
@@ -130,6 +132,14 @@
   igmp_init,	igmp_fasttimo,	igmp_slowtimo,	0,
   &rip_usrreqs
 },
+#ifdef PIM
+{ SOCK_RAW,	&inetdomain,	IPPROTO_PIM,	PR_ATOMIC|PR_ADDR|PR_LASTHDR,
+  pim_input,	0,		0,		rip_ctloutput,
+  0,
+  0,		0,		0,		0,
+  &rip_usrreqs
+},
+#endif
 { SOCK_RAW,	&inetdomain,	IPPROTO_RSVP,	PR_ATOMIC|PR_ADDR|PR_LASTHDR,
   rsvp_input,	0,		0,		rip_ctloutput,
   0,
@@ -272,4 +282,6 @@
 #ifdef IPDIVERT
 SYSCTL_NODE(_net_inet, IPPROTO_DIVERT,	divert,	CTLFLAG_RW, 0,	"DIVERT");
 #endif
-
+#ifdef PIM
+SYSCTL_NODE(_net_inet, IPPROTO_PIM,	pim,	CTLFLAG_RW, 0,	"PIM");
+#endif
Index: sys/netinet/ip_mroute.c
===================================================================
RCS file: /home/xorpc/u2/freebsd/src/sys/netinet/ip_mroute.c,v
retrieving revision 1.83
diff -u -r1.83 ip_mroute.c
--- sys/netinet/ip_mroute.c	15 Nov 2002 22:53:52 -0000	1.83
+++ sys/netinet/ip_mroute.c	22 Nov 2002 01:10:52 -0000
@@ -7,15 +7,26 @@
  * Modified by Van Jacobson, LBL, January 1993
  * Modified by Ajit Thyagarajan, PARC, August 1993
  * Modified by Bill Fenner, PARC, April 1995
+ * Modified by Ahmed Helmy, SGI, June 1996
+ * Modified by George Edmond Eddy (Rusty), ISI, February 1998
+ * Modified by Pavlin Radoslavov, USC/ISI, May 1998, August 1999, October 2000
+ * Modified by Hitoshi Asaeda, WIDE, August 2000
+ * Modified by Pavlin Radoslavov, ICSI, October 2002
  *
  * MROUTING Revision: 3.5
- * $FreeBSD: src/sys/netinet/ip_mroute.c,v 1.83 2002/11/15 22:53:52 luigi Exp $
+ * and PIM-SMv2 and PIM-DM support, advanced API support,
+ * bandwidth metering and signaling
+ * $FreeBSD$
  */
 
 #include "opt_mac.h"
 #include "opt_mrouting.h"
 #include "opt_random_ip_id.h"
 
+#ifdef PIM
+#define _PIM_VT 1
+#endif /* PIM */
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/lock.h>
@@ -42,6 +53,8 @@
 #include <netinet/ip_encap.h>
 #include <netinet/ip_mroute.h>
 #include <netinet/ip_var.h>
+#include <netinet/pim.h>
+#include <netinet/pim_var.h>
 #include <netinet/udp.h>
 #include <machine/in_cksum.h>
 
@@ -56,6 +69,7 @@
 #define		DEBUG_FORWARD	0x04
 #define		DEBUG_EXPIRE	0x08
 #define		DEBUG_XMIT	0x10
+#define		DEBUG_PIM	0x20
 
 #define M_HASCL(m)	((m)->m_flags & M_EXT)
 
@@ -112,6 +126,80 @@
 };
 
 /*
+ * Bandwidth meter variables and constants
+ */
+static MALLOC_DEFINE(M_BWMETER, "bwmeter", "multicast upcall bw meters");
+/*
+ * Pending timeouts are stored in a hash table, the key being the
+ * expiration time. Periodically, the entries are analysed and processed.
+ */
+#define BW_METER_BUCKETS	1024
+static struct bw_meter *bw_meter_timers[BW_METER_BUCKETS];
+static struct callout_handle bw_meter_ch;
+#define BW_METER_PERIOD (hz)		/* periodical handling of bw meters */
+
+/*
+ * Pending upcalls are stored in a vector which is flushed when
+ * full, or periodically
+ */
+static struct bw_upcall	bw_upcalls[BW_UPCALLS_MAX];
+static u_int	bw_upcalls_n; /* # of pending upcalls */
+static struct callout_handle bw_upcalls_ch;
+#define BW_UPCALLS_PERIOD (hz)		/* periodical flush of bw upcalls */
+
+#ifdef PIM
+static struct pimstat pimstat;
+SYSCTL_STRUCT(_net_inet_pim, PIMCTL_STATS, stats, CTLFLAG_RD,
+    &pimstat, pimstat,
+    "PIM Statistics (struct pimstat, netinet/pim_var.h)");
+
+/*
+ * Note: the PIM Register encapsulation adds the following in front of a
+ * data packet:
+ *
+ * struct pim_encap_hdr {
+ *    struct ip ip;
+ *    struct pim_encap_pimhdr  pim;
+ * }
+ *
+ */
+
+struct pim_encap_pimhdr {
+	struct pim pim;
+	uint32_t   flags;
+};
+
+static struct ip pim_encap_iphdr = {
+#if BYTE_ORDER == LITTLE_ENDIAN
+	sizeof(struct ip) >> 2,
+	IPVERSION,
+#else
+	IPVERSION,
+	sizeof(struct ip) >> 2,
+#endif /* !LITTLE_ENDIAN */
+	0,			/* tos */
+	sizeof(struct ip),	/* total length */
+	0,			/* id */
+	0,			/* frag offset */ 
+	ENCAP_TTL,
+	IPPROTO_PIM,
+	0,			/* checksum */
+};
+
+static struct pim_encap_pimhdr pim_encap_pimhdr = {
+    {
+	PIM_MAKE_VT(PIM_VERSION, PIM_REGISTER), /* PIM vers and message type */
+	0,			/* reserved */
+	0,			/* checksum */
+    },
+    0				/* flags */
+};
+
+static struct ifnet multicast_register_if;
+static vifi_t reg_vif_num = (vifi_t) -1;
+#endif /* PIM */
+
+/*
  * Private variables.
  */
 static vifi_t	   numvifs;
@@ -138,8 +226,9 @@
 static int ip_mrouter_init(struct socket *, int);
 static int add_vif(struct vifctl *);
 static int del_vif(vifi_t);
-static int add_mfc(struct mfcctl *);
-static int del_mfc(struct mfcctl *);
+static int add_mfc(struct mfcctl2 *);
+static int del_mfc(struct mfcctl2 *);
+static int set_api_config(uint32_t *); /* chose API capabilities */
 static int socket_send(struct socket *, struct mbuf *, struct sockaddr_in *);
 static int set_assert(int);
 static void expire_upcalls(void *);
@@ -156,6 +245,32 @@
 static int priority(struct vif *, struct ip *);
 
 /*
+ * Bandwidth monitoring
+ */
+static void free_bw_list(struct bw_meter *list);
+static int add_bw_upcall(struct bw_upcall *);
+static int del_bw_upcall(struct bw_upcall *);
+static void bw_meter_receive_packet(struct bw_meter *x, int plen,
+		struct timeval *nowp);
+static void bw_meter_prepare_upcall(struct bw_meter *x, struct timeval *nowp);
+static void bw_upcalls_send(void);
+static void schedule_bw_meter(struct bw_meter *x, struct timeval *nowp);
+static void unschedule_bw_meter(struct bw_meter *x);
+static void bw_meter_process(void);
+static void expire_bw_upcalls_send(void *);
+static void expire_bw_meter_process(void *);
+
+#ifdef PIM
+static int pim_register_send(struct ip *, struct vif *,
+		struct mbuf *, struct mfc *);
+static int pim_register_send_rp(struct ip *, struct vif *,
+		struct mbuf *, struct mfc *);
+static int pim_register_send_upcall(struct ip *, struct vif *,
+		struct mbuf *, struct mfc *);
+static struct mbuf *pim_register_prepare(struct ip *, struct mbuf *);
+#endif /* PIM */
+
+/*
  * whether or not special PIM assert processing is enabled.
  */
 static int pim_assert;
@@ -165,6 +280,17 @@
 #define ASSERT_MSG_TIME		3000000
 
 /*
+ * Kernel multicast routing API capabilities and setup.
+ * If more API capabilities are added to the kernel, they should be
+ * recorded in `mrt_api_support'.
+ */
+static uint32_t mrt_api_support = ( MRT_MFC_FLAGS_DISABLE_WRONGVIF
+					| MRT_MFC_FLAGS_BORDER_VIF
+					| MRT_MFC_RP
+					| MRT_MFC_BW_UPCALL );
+static uint32_t mrt_api_config = 0;
+
+/*
  * Hash function for a source, group entry
  */
 #define MFCHASH(a, g) MFCHASHMOD(((a) >> 20) ^ ((a) >> 10) ^ (a) ^ \
@@ -198,13 +324,13 @@
 	if ((xxs = (a).tv_sec - (b).tv_sec)) {			\
 		switch (xxs) {					\
 		case 2:						\
-		      delta += 1000000;				\
-		      /* FALLTHROUGH */				\
+			delta += 1000000;			\
+			/* FALLTHROUGH */			\
 		case 1:						\
-		      delta += 1000000;				\
-		      break;					\
+			delta += 1000000;			\
+			break;					\
 		default:					\
-		      delta += (1000000 * xxs);			\
+			delta += (1000000 * xxs);		\
 		}						\
 	}							\
 }
@@ -221,7 +347,9 @@
     int	error, optval;
     vifi_t	vifi;
     struct	vifctl vifc;
-    struct	mfcctl mfc;
+    struct	mfcctl2 mfc;
+    struct	bw_upcall bw_upcall;
+    uint32_t	i;
 
     if (so != ip_mrouter && sopt->sopt_name != MRT_INIT)
 	return EPERM;
@@ -255,7 +383,16 @@
 
     case MRT_ADD_MFC:
     case MRT_DEL_MFC:
-	error = sooptcopyin(sopt, &mfc, sizeof mfc, sizeof mfc);
+	bzero((caddr_t)&mfc, sizeof(mfc)); /* zero out all fields */
+	/*
+	 * select data size depending on API version.
+	 */
+	if (sopt->sopt_name == MRT_ADD_MFC &&
+		mrt_api_config & MRT_API_FLAGS_ALL)
+	    i = sizeof(struct mfcctl2);
+	else
+	    i = sizeof(struct mfcctl);
+	error = sooptcopyin(sopt, &mfc, i, i);
 	if (error)
 	    break;
 	if (sopt->sopt_name == MRT_ADD_MFC)
@@ -271,6 +408,26 @@
 	set_assert(optval);
 	break;
 
+    case MRT_API_CONFIG:
+	error = sooptcopyin(sopt, &i, sizeof i, sizeof i);
+	if (!error)
+	    error = set_api_config(&i);
+	if (!error)
+	    error = sooptcopyout(sopt, &i, sizeof i);
+	break;
+
+    case MRT_ADD_BW_UPCALL:
+    case MRT_DEL_BW_UPCALL:
+	error = sooptcopyin(sopt, &bw_upcall, sizeof bw_upcall,
+				sizeof bw_upcall);
+	if (error)
+	    break;
+	if (sopt->sopt_name == MRT_ADD_BW_UPCALL)
+	    error = add_bw_upcall(&bw_upcall);
+	else
+	    error = del_bw_upcall(&bw_upcall);
+	break;
+
     default:
 	error = EOPNOTSUPP;
 	break;
@@ -296,6 +453,14 @@
 	error = sooptcopyout(sopt, &pim_assert, sizeof pim_assert);
 	break;
 
+    case MRT_API_SUPPORT:
+	error = sooptcopyout(sopt, &mrt_api_support, sizeof mrt_api_support);
+	break;
+
+    case MRT_API_CONFIG:
+	error = sooptcopyout(sopt, &mrt_api_config, sizeof mrt_api_config);
+	break;
+
     default:
 	error = EOPNOTSUPP;
 	break;
@@ -396,6 +561,13 @@
 
     expire_upcalls_ch = timeout(expire_upcalls, NULL, EXPIRE_TIMEOUT);
 
+    bw_upcalls_n = 0;
+    bzero((caddr_t)bw_meter_timers, sizeof(bw_meter_timers));
+    bw_upcalls_ch = timeout(expire_bw_upcalls_send, NULL, BW_UPCALLS_PERIOD);
+    bw_meter_ch = timeout(expire_bw_meter_process, NULL, BW_METER_PERIOD);
+
+    mrt_api_config = 0;
+
     if (mrtdebug)
 	log(LOG_DEBUG, "ip_mrouter_init\n");
 
@@ -424,7 +596,7 @@
      */
     for (vifi = 0; vifi < numvifs; vifi++) {
 	if (viftable[vifi].v_lcl_addr.s_addr != 0 &&
-		!(viftable[vifi].v_flags & VIFF_TUNNEL)) {
+		!(viftable[vifi].v_flags & (VIFF_TUNNEL | VIFF_REGISTER) )) {
 	    struct sockaddr_in *so = (struct sockaddr_in *)&(ifr.ifr_addr);
 
 	    so->sin_len = sizeof(struct sockaddr_in);
@@ -441,6 +613,11 @@
 
     untimeout(expire_upcalls, NULL, expire_upcalls_ch);
 
+    mrt_api_config = 0;
+    bw_upcalls_n = 0;
+    untimeout(expire_bw_upcalls_send, NULL, bw_upcalls_ch);
+    untimeout(expire_bw_meter_process, NULL, bw_meter_ch);
+
     /*
      * Free all multicast forwarding cache entries.
      */
@@ -458,20 +635,28 @@
 	    free(rt, M_MRTABLE);
 	    rt = nr;
 	}
+
+	free_bw_list(rt->mfc_bw_meter);
     }
 
     bzero((caddr_t)mfctable, sizeof(mfctable));
 
+    bzero(bw_meter_timers, sizeof(bw_meter_timers));
+
     /*
      * Reset de-encapsulation cache
      */
     last_encap_src = INADDR_ANY;
     last_encap_vif = NULL;
+#ifdef PIM
+    reg_vif_num = (vifi_t) -1;
+#endif /* PIM */
+
     if (encap_cookie) {
 	encap_detach(encap_cookie);
 	encap_cookie = NULL;
     }
-
+ 
     ip_mrouter = NULL;
 
     splx(s);
@@ -497,6 +682,42 @@
 }
 
 /*
+ * Configure API capabilities
+ */
+int
+set_api_config(uint32_t *apival)
+{
+    int i;
+
+    /*
+     * We can set the API capabilities only if it is the first operation
+     * after MRT_INIT. I.e.:
+     *  - there are no vifs installed
+     *  - pim_assert is not enabled
+     *  - the MFC table is empty
+     */
+    if (numvifs > 0) {
+	*apival = 0;
+	return EPERM;
+    }
+    if (pim_assert) {
+	*apival = 0;
+	return EPERM;
+    }
+    for (i = 0; i < MFCTBLSIZ; i++) {
+	if (mfctable[i] != NULL) {
+	    *apival = 0;
+	    return EPERM;
+	}
+    }
+
+    mrt_api_config = *apival & mrt_api_support;
+    *apival = mrt_api_config;
+
+    return 0;
+}
+
+/*
  * Decide if a packet is from a tunnelled peer.
  * Return 0 if not, 64 if so.  XXX yuck.. 64 ???
  */
@@ -594,11 +815,23 @@
 	return EADDRNOTAVAIL;
 
     /* Find the interface with an address in AF_INET family */
-    sin.sin_addr = vifcp->vifc_lcl_addr;
-    ifa = ifa_ifwithaddr((struct sockaddr *)&sin);
-    if (ifa == NULL)
-	return EADDRNOTAVAIL;
-    ifp = ifa->ifa_ifp;
+#ifdef PIM
+    if ((vifcp->vifc_flags & VIFF_REGISTER)) {
+	/*
+	 * XXX: Because VIFF_REGISTER does not really need a valid
+	 * local interface (e.g. it could be 127.0.0.2), we don't
+	 * check its address.
+	 */
+	ifp = NULL;
+    } else
+#endif /* PIM */
+    {
+	sin.sin_addr = vifcp->vifc_lcl_addr;
+	ifa = ifa_ifwithaddr((struct sockaddr *)&sin);
+	if (ifa == NULL)
+	    return EADDRNOTAVAIL;
+	ifp = ifa->ifa_ifp;
+    }
 
     if (vifcp->vifc_flags & VIFF_TUNNEL) {
 	if ((vifcp->vifc_flags & VIFF_SRCRT) == 0) {
@@ -633,6 +866,20 @@
 	    log(LOG_ERR, "source routed tunnels not supported\n");
 	    return EOPNOTSUPP;
 	}
+#ifdef PIM
+    } else if (vifcp->vifc_flags & VIFF_REGISTER) {
+	ifp = &multicast_register_if;
+	if (mrtdebug)
+	    log(LOG_DEBUG, "Adding a register vif, ifp: %p\n",
+		    (void *)&multicast_register_if);
+	if (reg_vif_num == (vifi_t)-1) {
+	    multicast_register_if.if_name = "register_vif";
+	    multicast_register_if.if_unit = 0;
+	    multicast_register_if.if_flags = IFF_LOOPBACK;
+	    bzero(&vifp->v_route, sizeof(vifp->v_route));
+	    reg_vif_num = vifcp->vifc_vifi;
+	}
+#endif /* PIM */
     } else {		/* Make sure the interface supports multicast */
 	if ((ifp->if_flags & IFF_MULTICAST) == 0)
 	    return EOPNOTSUPP;
@@ -702,7 +949,7 @@
 
     s = splnet();
 
-    if (!(vifp->v_flags & VIFF_TUNNEL))
+    if (!(vifp->v_flags & (VIFF_TUNNEL | VIFF_REGISTER) ))
 	if_allmulti(vifp->v_ifp, 0);
 
     if (vifp == last_encap_vif) {
@@ -720,6 +967,11 @@
 	m_freem(m);
     }
 
+#ifdef PIM
+    if (vifp->v_flags & VIFF_REGISTER)
+	reg_vif_num = (vifi_t) -1;
+#endif /* PIM */
+
     bzero((caddr_t)vifp->v_tbf, sizeof(*(vifp->v_tbf)));
     bzero((caddr_t)vifp, sizeof (*vifp));
 
@@ -741,20 +993,28 @@
  * update an mfc entry without resetting counters and S,G addresses.
  */
 static void
-update_mfc_params(struct mfc *rt, struct mfcctl *mfccp)
+update_mfc_params(struct mfc *rt, struct mfcctl2 *mfccp)
 {
     int i;
 
     rt->mfc_parent = mfccp->mfcc_parent;
-    for (i = 0; i < numvifs; i++)
+    for (i = 0; i < numvifs; i++) {
 	rt->mfc_ttls[i] = mfccp->mfcc_ttls[i];
+	rt->mfc_flags[i] = mfccp->mfcc_flags[i] & mrt_api_config &
+	    MRT_MFC_FLAGS_ALL;
+    }
+    /* set the RP address */
+    if (mrt_api_config & MRT_MFC_RP)
+	rt->mfc_rp = mfccp->mfcc_rp;
+    else
+	rt->mfc_rp.s_addr = INADDR_ANY;
 }
 
 /*
  * fully initialize an mfc entry from the parameter.
  */
 static void
-init_mfc_params(struct mfc *rt, struct mfcctl *mfccp)
+init_mfc_params(struct mfc *rt, struct mfcctl2 *mfccp)
 {
     rt->mfc_origin     = mfccp->mfcc_origin;
     rt->mfc_mcastgrp   = mfccp->mfcc_mcastgrp;
@@ -773,7 +1033,7 @@
  * Add an mfc entry
  */
 static int
-add_mfc(struct mfcctl *mfccp)
+add_mfc(struct mfcctl2 *mfccp)
 {
     struct mfc *rt;
     u_long hash;
@@ -869,7 +1129,8 @@
 	    init_mfc_params(rt, mfccp);
 	    rt->mfc_expire     = 0;
 	    rt->mfc_stall      = NULL;
-	    
+
+	    rt->mfc_bw_meter = NULL;
 	    /* insert new entry at head of hash chain */
 	    rt->mfc_next = mfctable[hash];
 	    mfctable[hash] = rt;
@@ -883,7 +1144,7 @@
  * Delete an mfc entry
  */
 static int
-del_mfc(struct mfcctl *mfccp)
+del_mfc(struct mfcctl2 *mfccp)
 {
     struct in_addr 	origin;
     struct in_addr 	mcastgrp;
@@ -891,6 +1152,7 @@
     struct mfc	 	**nptr;
     u_long 		hash;
     int s;
+    struct bw_meter *list;
 
     origin = mfccp->mfcc_origin;
     mcastgrp = mfccp->mfcc_mcastgrp;
@@ -913,10 +1175,19 @@
     }
 
     *nptr = rt->mfc_next;
+
+    /*
+     * free the bw_meter entries
+     */
+    list = rt->mfc_bw_meter;
+    rt->mfc_bw_meter = NULL;
+
     free(rt, M_MRTABLE);
 
     splx(s);
 
+    free_bw_list(list);
+
     return 0;
 }
 
@@ -966,7 +1237,7 @@
 		((u_char *)(ip + 1))[1] != IPOPT_LSRR ) {
 	/*
 	 * Packet arrived via a physical interface or
-	 * an encapsulated tunnel.
+	 * an encapsulated tunnel or a register_vif.
 	 */
     } else {
 	/*
@@ -1051,7 +1322,7 @@
 	    splx(s);
 	    return ENOBUFS;
 	}
-	mb0 = m_copy(m, 0, M_COPYALL);
+	mb0 = m_copypacket(m, M_DONTWAIT);
 	if (mb0 && (M_HASCL(mb0) || mb0->m_len < hlen))
 	    mb0 = m_pullup(mb0, hlen);
 	if (mb0 == NULL) {
@@ -1081,7 +1352,7 @@
 	     */
 	    for (vifi=0; vifi<numvifs && viftable[vifi].v_ifp != ifp; vifi++)
 		;
-            if (vifi >= numvifs)	/* vif not found, drop packet */
+	    if (vifi >= numvifs)		/* vif not found, drop packet */
 		goto non_fatal;
 
 	    /* no upcall, so make a new entry */
@@ -1123,10 +1394,16 @@
 	    rt->mfc_mcastgrp.s_addr   = ip->ip_dst.s_addr;
 	    rt->mfc_expire	      = UPCALL_EXPIRE;
 	    nexpire[hash]++;
-	    for (i = 0; i < numvifs; i++)
+	    for (i = 0; i < numvifs; i++) {
 		rt->mfc_ttls[i] = 0;
+		rt->mfc_flags[i] = 0;
+	    }
 	    rt->mfc_parent = -1;
 
+	    rt->mfc_rp.s_addr = INADDR_ANY; /* clear the RP address */
+
+	    rt->mfc_bw_meter = NULL;
+
 	    /* link into table */
 	    rt->mfc_next   = mfctable[hash];
 	    mfctable[hash] = rt;
@@ -1210,6 +1487,16 @@
 		++mrtstat.mrts_cache_cleanups;
 		nexpire[i]--;
 
+		/*
+		 * free the bw_meter entries
+		 */
+		while (mfc->mfc_bw_meter != NULL) {
+		    struct bw_meter *x = mfc->mfc_bw_meter;
+
+		    mfc->mfc_bw_meter = x->mfc_next;
+		    free(x, M_BWMETER);
+		}
+
 		*nptr = mfc->mfc_next;
 		free(mfc, M_MRTABLE);
 	    } else {
@@ -1236,11 +1523,11 @@
  * input, they shouldn't get counted on output, so statistics keeping is
  * separate.
  */
-#define MC_SEND(ip,vifp,m) {                             \
-                if ((vifp)->v_flags & VIFF_TUNNEL)  	 \
-                    encap_send((ip), (vifp), (m));       \
-                else                                     \
-                    phyint_send((ip), (vifp), (m));      \
+#define MC_SEND(ip,vifp,m) {				\
+		if ((vifp)->v_flags & VIFF_TUNNEL)	\
+		    encap_send((ip), (vifp), (m));	\
+		else					\
+		    phyint_send((ip), (vifp), (m));	\
 }
 
     /*
@@ -1249,6 +1536,11 @@
      * (since vifi_t is u_short, -1 becomes MAXUSHORT, which > numvifs.)
      */
     if (xmt_vif < numvifs) {
+#ifdef PIM
+	if (viftable[xmt_vif].v_flags & VIFF_REGISTER)
+	    pim_register_send(ip, viftable + xmt_vif, m, rt);
+        else
+#endif
 	MC_SEND(ip, viftable + xmt_vif, m);
 	return 1;
     }
@@ -1265,16 +1557,31 @@
 	++mrtstat.mrts_wrong_if;
 	++rt->mfc_wrong_if;
 	/*
-	 * If we are doing PIM assert processing, and we are forwarding
-	 * packets on this interface, and it is a broadcast medium
-	 * interface (and not a tunnel), send a message to the routing daemon.
-	 */
-	if (pim_assert && rt->mfc_ttls[vifi] &&
-		(ifp->if_flags & IFF_BROADCAST) &&
-		!(viftable[vifi].v_flags & VIFF_TUNNEL)) {
+	 * If we are doing PIM assert processing, send a message
+	 * to the routing daemon.
+	 *
+	 * XXX: A PIM-SM router needs the WRONGVIF detection so it
+	 * can complete the SPT switch, regardless of the type
+	 * of the iif (broadcast media, GRE tunnel, etc).
+	 */
+	if (pim_assert && (vifi < numvifs) && viftable[vifi].v_ifp) {
 	    struct timeval now;
 	    u_long delta;
 
+#ifdef PIM
+	    if (ifp == &multicast_register_if)
+		pimstat.pims_rcv_registers_wrongiif++;
+#endif /* PIM */
+
+	    /* Get vifi for the incoming packet */
+	    for (vifi=0; vifi<numvifs && viftable[vifi].v_ifp != ifp; vifi++)
+		;
+	    if (vifi >= numvifs)
+		return 0;	/* iif not found: ignore the packet */
+
+	    if (rt->mfc_flags[vifi] & MRT_MFC_FLAGS_DISABLE_WRONGVIF)
+		return 0;	/* WRONGVIF disabled: ignore the packet */
+
 	    GET_TIME(now);
 
 	    TV_DELTA(rt->mfc_last_assert, now, delta);
@@ -1299,6 +1606,8 @@
 
 		k_igmpsrc.sin_addr = im->im_src;
 
+		mrtstat.mrts_upcalls++;
+
 		if (socket_send(ip_mrouter, mm, &k_igmpsrc) < 0) {
 		    log(LOG_WARNING,
 			"ip_mforward: ip_mrouter socket queue full\n");
@@ -1331,9 +1640,26 @@
 	if ((rt->mfc_ttls[vifi] > 0) && (ip->ip_ttl > rt->mfc_ttls[vifi])) {
 	    viftable[vifi].v_pkt_out++;
 	    viftable[vifi].v_bytes_out += plen;
+#ifdef PIM
+	    if (viftable[vifi].v_flags & VIFF_REGISTER)
+		pim_register_send(ip, viftable + vifi, m, rt);
+	    else
+#endif
 	    MC_SEND(ip, viftable+vifi, m);
 	}
 
+    /*
+     * Perform upcall-related bw measuring.
+     */
+    if (rt->mfc_bw_meter != NULL) {
+	struct bw_meter *x;
+	struct timeval now;
+
+	GET_TIME(now);
+	for (x = rt->mfc_bw_meter; x != NULL; x = x->mfc_next)
+	    bw_meter_receive_packet(x, plen, &now);
+    }
+
     return 0;
 }
 
@@ -1369,7 +1695,7 @@
      * the IP header is actually copied, not just referenced,
      * so that ip_output() only scribbles on the copy.
      */
-    mb_copy = m_copy(m, 0, M_COPYALL);
+    mb_copy = m_copypacket(m, M_DONTWAIT);
     if (mb_copy && (M_HASCL(mb_copy) || mb_copy->m_len < hlen))
 	mb_copy = m_pullup(mb_copy, hlen);
     if (mb_copy == NULL)
@@ -1412,7 +1738,7 @@
     mb_copy->m_data += max_linkhdr;
     mb_copy->m_len = sizeof(multicast_encap_iphdr);
 
-    if ((mb_copy->m_next = m_copy(m, 0, M_COPYALL)) == NULL) {
+    if ((mb_copy->m_next = m_copypacket(m, M_DONTWAIT)) == NULL) {
 	m_freem(mb_copy);
 	return;
     }
@@ -1869,6 +2195,1029 @@
     splx(s);
 }
 
+/*
+ * Code for bandwidth monitors
+ */
+
+/*
+ * Define common interface for timeval-related methods
+ */
+#define	BW_TIMEVALCMP(tvp, uvp, cmp) timevalcmp((tvp), (uvp), cmp)
+#define	BW_TIMEVALDECR(vvp, uvp) timevalsub((vvp), (uvp))
+#define	BW_TIMEVALADD(vvp, uvp) timevaladd((vvp), (uvp))
+
+static uint32_t
+compute_bw_meter_flags(struct bw_upcall *req)
+{
+    uint32_t flags = 0;
+
+    if (req->flags & BW_UPCALL_UNIT_PACKETS)
+	flags |= BW_METER_UNIT_PACKETS;
+    if (req->flags & BW_UPCALL_UNIT_BYTES)
+	flags |= BW_METER_UNIT_BYTES;
+    if (req->flags & BW_UPCALL_GEQ)
+	flags |= BW_METER_GEQ;
+    if (req->flags & BW_UPCALL_LEQ)
+	flags |= BW_METER_LEQ;
+    
+    return flags;
+}
+ 
+/*
+ * Add a bw_meter entry
+ */
+static int
+add_bw_upcall(struct bw_upcall *req)
+{
+    struct mfc *mfc;
+    struct timeval delta = { BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC,
+		BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC };
+    struct timeval now;
+    struct bw_meter *x;
+    uint32_t flags;
+    int s;
+    
+    if (! (mrt_api_config & MRT_MFC_BW_UPCALL))
+	return EOPNOTSUPP;
+    
+    /* Test if the flags are valid */
+    if (! (req->flags & (BW_UPCALL_UNIT_PACKETS | BW_UPCALL_UNIT_BYTES)))
+	return EINVAL;
+    if (! (req->flags & (BW_UPCALL_GEQ | BW_UPCALL_LEQ)))
+	return EINVAL;
+    if ((req->flags & (BW_UPCALL_GEQ | BW_UPCALL_LEQ))
+	    == (BW_UPCALL_GEQ | BW_UPCALL_LEQ))
+	return EINVAL;
+    
+    /* Test if the threshold time interval is valid */
+    if (BW_TIMEVALCMP(&req->threshold.time, &delta, <))
+	return EINVAL;
+    
+    flags = compute_bw_meter_flags(req);
+
+    /*
+     * Find if we have already same bw_meter entry
+     */
+    s = splnet();
+    mfc = mfc_find(req->src.s_addr, req->dst.s_addr);
+    if (mfc == NULL) {
+	splx(s);
+	return EADDRNOTAVAIL;
+    }
+    for (x = mfc->mfc_bw_meter; x != NULL; x = x->mfc_next) {
+	if ((BW_TIMEVALCMP(&x->threshold.time, &req->threshold.time, ==))
+		    && (x->threshold.packets == req->threshold.packets)
+		    && (x->threshold.bytes == req->threshold.bytes)
+		    && (x->flags & BW_METER_USER_FLAGS) == flags )  {
+	    splx(s);
+	    return 0;		/* XXX Already installed */
+	}
+    }
+    splx(s);
+    
+    /* Allocate the new bw_meter entry */
+    x = (struct bw_meter *)malloc(sizeof(*x), M_BWMETER, M_NOWAIT);
+    if (x == NULL)
+	return ENOBUFS;
+    
+    /* Set the new bw_meter entry */
+    x->threshold.time = req->threshold.time;
+    GET_TIME(now);
+    x->start_time = now;
+    x->threshold.packets = req->threshold.packets;
+    x->threshold.bytes = req->threshold.bytes;
+    x->measured.packets = 0;
+    x->measured.bytes = 0;
+    x->flags = flags;
+    x->time_next = NULL;
+    x->time_hash = BW_METER_BUCKETS;
+    
+    /* Add the new bw_meter entry to the front of entries for this MFC */
+    s = splnet();
+    x->mfc = mfc;
+    x->mfc_next = mfc->mfc_bw_meter;
+    mfc->mfc_bw_meter = x;
+    schedule_bw_meter(x, &now);
+    splx(s);
+    
+    return 0;
+}
+
+static void
+free_bw_list(struct bw_meter *list)
+{
+    while (list != NULL) {
+	struct bw_meter *x = list;
+
+	list = list->mfc_next;
+	unschedule_bw_meter(x);
+	free(x, M_BWMETER);
+    }
+}
+
+/*
+ * Delete one or multiple bw_meter entries
+ */
+static int
+del_bw_upcall(struct bw_upcall *req)
+{
+    struct mfc *mfc;
+    struct bw_meter *x;
+    int s;
+    
+    if (! (mrt_api_config & MRT_MFC_BW_UPCALL))
+	return EOPNOTSUPP;
+    
+    s = splnet();
+    /* Find the corresponding MFC entry */
+    mfc = mfc_find(req->src.s_addr, req->dst.s_addr);
+    if (mfc == NULL) {
+	splx(s);
+	return EADDRNOTAVAIL;
+    } else if (req->flags & BW_UPCALL_DELETE_ALL) {
+	/*
+	 * Delete all bw_meter entries for this mfc
+	 */
+	struct bw_meter *list;
+	
+	list = mfc->mfc_bw_meter;
+	mfc->mfc_bw_meter = NULL;
+	splx(s);
+	free_bw_list(list);
+	return 0;
+    } else {			/* Delete a single bw_meter entry */
+	struct bw_meter *prev;
+	uint32_t flags = 0;
+
+	flags = compute_bw_meter_flags(req);
+
+	/* Find the bw_meter entry to delete */
+	for (prev = NULL, x = mfc->mfc_bw_meter; x != NULL; x = x->mfc_next) {
+	    if ((BW_TIMEVALCMP(&x->threshold.time, &req->threshold.time, ==))
+			&& (x->threshold.packets == req->threshold.packets)
+			&& (x->threshold.bytes == req->threshold.bytes)
+			&& (x->flags & BW_METER_USER_FLAGS) == flags)
+		break;
+	}
+	if (x != NULL) { /* Delete entry from the list for this MFC */
+	    if (prev != NULL)
+		prev->mfc_next = x->mfc_next;	/* remove from middle of list */
+	    else
+		x->mfc->mfc_bw_meter = x->mfc_next; /* new head of list */
+	    splx(s);
+
+	    unschedule_bw_meter(x);
+	    /* Free the bw_meter entry */
+	    free(x, M_BWMETER);
+	    return 0;
+	} else {
+	    splx(s);
+	    return EINVAL;
+	}
+    }
+    return EINVAL; /* NOTREACHED */
+}
+
+/*
+ * Perform bandwidth measurement processing that may result in an upcall
+ */
+static void
+bw_meter_receive_packet(struct bw_meter *x, int plen, struct timeval *nowp)
+{
+    struct timeval delta;
+    int s;
+    
+    s = splnet();
+    delta = *nowp;
+    BW_TIMEVALDECR(&delta, &x->start_time);
+    
+    if (x->flags & BW_METER_GEQ) {
+	/*
+	 * Processing for ">=" type of bw_meter entry
+	 */
+	if (BW_TIMEVALCMP(&delta, &x->threshold.time, >)) {
+	    /* Reset the bw_meter entry */
+	    x->start_time = *nowp;
+	    x->measured.packets = 0;
+	    x->measured.bytes = 0;
+	    x->flags &= ~BW_METER_UPCALL_DELIVERED;
+	}
+	
+	/* Record that a packet is received */
+	x->measured.packets++;
+	x->measured.bytes += plen;
+	
+	/*
+	 * Test if we should deliver an upcall
+	 */
+	if (! (x->flags & BW_METER_UPCALL_DELIVERED)) {	
+	    if (((x->flags & BW_UPCALL_UNIT_PACKETS)
+		 && (x->measured.packets >= x->threshold.packets))
+		|| ((x->flags & BW_UPCALL_UNIT_BYTES)
+		    && (x->measured.packets >= x->threshold.bytes))) {
+		/* Prepare an upcall for delivery */
+		bw_meter_prepare_upcall(x, nowp);
+		x->flags |= BW_METER_UPCALL_DELIVERED;
+	    }
+	}
+    } else if (x->flags & BW_METER_LEQ) {
+	/*
+	 * Processing for "<=" type of bw_meter entry
+	 */
+	if (BW_TIMEVALCMP(&delta, &x->threshold.time, >)) {
+	    /*
+	     * We are behind time with the multicast forwarding table
+	     * scanning for "<=" type of bw_meter entries, so test now
+	     * if we should deliver an upcall.
+	     */
+	    if (((x->flags & BW_UPCALL_UNIT_PACKETS)
+		 && (x->measured.packets <= x->threshold.packets))
+		|| ((x->flags & BW_UPCALL_UNIT_BYTES)
+		    && (x->measured.bytes <= x->threshold.bytes))) {
+		/* Prepare an upcall for delivery */
+		bw_meter_prepare_upcall(x, nowp);
+	    }
+	    /* Reschedule the bw_meter entry */
+	    unschedule_bw_meter(x);
+	    schedule_bw_meter(x, nowp);
+	}
+	
+	/* Record that a packet is received */
+	x->measured.packets++;
+	x->measured.bytes += plen;
+	
+	/*
+	 * Test if we should restart the measuring interval
+	 */
+	if (	(x->flags & BW_UPCALL_UNIT_PACKETS &&
+		 x->measured.packets <= x->threshold.packets) ||
+		(x->flags & BW_UPCALL_UNIT_BYTES   &&
+		 x->measured.bytes <= x->threshold.bytes) ) {
+	    /* Don't restart the measuring interval */
+	} else {
+	    /* Do restart the measuring interval */
+	    /*
+	     * XXX: note that we don't unschedule and schedule, because this
+	     * might be too much overhead per packet. Instead, when we process
+	     * all entries for a given timer hash bin, we check whether it is
+	     * really a timeout. If not, we reschedule at that time.
+	     */
+	    x->start_time = *nowp;
+	    x->measured.packets = 0;
+	    x->measured.bytes = 0;
+	    x->flags &= ~BW_METER_UPCALL_DELIVERED;
+	}
+    }
+    splx(s);
+}
+
+/*
+ * Prepare a bandwidth-related upcall
+ */
+static void
+bw_meter_prepare_upcall(struct bw_meter *x, struct timeval *nowp)
+{
+    struct timeval delta;
+    struct bw_upcall *u;
+    int s;
+    
+    s = splnet();
+    
+    /*
+     * Compute the measured time interval 
+     */
+    delta = *nowp;
+    BW_TIMEVALDECR(&delta, &x->start_time);
+    
+    /*
+     * If there are too many pending upcalls, deliver them now
+     */
+    if (bw_upcalls_n >= BW_UPCALLS_MAX)
+	bw_upcalls_send();
+    
+    /*
+     * Set the bw_upcall entry
+     */
+    u = &bw_upcalls[bw_upcalls_n++];
+    u->src = x->mfc->mfc_origin;
+    u->dst = x->mfc->mfc_mcastgrp;
+    u->threshold.time = x->threshold.time;
+    u->threshold.packets = x->threshold.packets;
+    u->threshold.bytes = x->threshold.bytes;
+    u->measured.time = delta;
+    u->measured.packets = x->measured.packets;
+    u->measured.bytes = x->measured.bytes;
+    u->flags = 0;
+    if (x->flags & BW_METER_UNIT_PACKETS)
+	u->flags |= BW_UPCALL_UNIT_PACKETS;
+    if (x->flags & BW_METER_UNIT_BYTES)
+	u->flags |= BW_UPCALL_UNIT_BYTES;
+    if (x->flags & BW_METER_GEQ)
+	u->flags |= BW_UPCALL_GEQ;
+    if (x->flags & BW_METER_LEQ)
+	u->flags |= BW_UPCALL_LEQ;
+    
+    splx(s);
+}
+
+/*
+ * Send the pending bandwidth-related upcalls
+ */
+static void
+bw_upcalls_send(void)
+{
+    struct mbuf *m;
+    int len = bw_upcalls_n * sizeof(bw_upcalls[0]);
+    struct sockaddr_in k_igmpsrc = { sizeof k_igmpsrc, AF_INET };
+    static struct igmpmsg igmpmsg = { 0,		/* unused1 */
+				      0,		/* unused2 */
+				      IGMPMSG_BW_UPCALL,/* im_msgtype */
+				      0,		/* im_mbz  */
+				      0,		/* im_vif  */
+				      0,		/* unused3 */
+				      { 0 },		/* im_src  */
+				      { 0 } };		/* im_dst  */
+    
+    if (bw_upcalls_n == 0)
+	return;			/* No pending upcalls */
+
+    bw_upcalls_n = 0;
+    
+    /*
+     * Allocate a new mbuf, initialize it with the header and
+     * the payload for the pending calls.
+     */
+    MGETHDR(m, M_DONTWAIT, MT_HEADER);
+    if (m == NULL) {
+	log(LOG_WARNING, "bw_upcalls_send: cannot allocate mbuf\n");
+	return;
+    }
+    
+    m->m_len = m->m_pkthdr.len = 0;
+    m_copyback(m, 0, sizeof(struct igmpmsg), (caddr_t)&igmpmsg);
+    m_copyback(m, sizeof(struct igmpmsg), len, (caddr_t)&bw_upcalls[0]);
+    
+    /*
+     * Send the upcalls
+     * XXX do we need to set the address in k_igmpsrc ?
+     */
+    mrtstat.mrts_upcalls++;
+    if (socket_send(ip_mrouter, m, &k_igmpsrc) < 0) {
+	log(LOG_WARNING, "bw_upcalls_send: ip_mrouter socket queue full\n");
+	++mrtstat.mrts_upq_sockfull;
+    }
+}
+
+/*
+ * Compute the timeout hash value for the bw_meter entries
+ */
+#define	BW_METER_TIMEHASH(bw_meter, hash)				\
+    do {								\
+	struct timeval next_timeval = (bw_meter)->start_time;		\
+									\
+	BW_TIMEVALADD(&next_timeval, &(bw_meter)->threshold.time);	\
+	(hash) = next_timeval.tv_sec;					\
+	if (next_timeval.tv_usec)					\
+	    (hash)++; /* XXX: make sure we don't timeout early */	\
+	(hash) %= BW_METER_BUCKETS;					\
+    } while (0)
+
+/*
+ * Schedule a timer to process periodically bw_meter entry of type "<="
+ * by linking the entry in the proper hash bucket.
+ */
+static void
+schedule_bw_meter(struct bw_meter *x, struct timeval *nowp)
+{
+    int time_hash, s;
+    
+    if (! (x->flags & BW_METER_LEQ))
+	return;		/* XXX: we schedule timers only for "<=" entries */
+    
+    /*
+     * Reset the bw_meter entry
+     */
+    s = splnet();
+    x->start_time = *nowp;
+    x->measured.packets = 0;
+    x->measured.bytes = 0;
+    x->flags &= ~BW_METER_UPCALL_DELIVERED;
+    splx(s);
+    
+    /*
+     * Compute the timeout hash value and insert the entry
+     */
+    BW_METER_TIMEHASH(x, time_hash);
+    x->time_next = bw_meter_timers[time_hash];
+    bw_meter_timers[time_hash] = x;
+    x->time_hash = time_hash;
+}
+
+/*
+ * Unschedule the periodic timer that processes bw_meter entry of type "<="
+ * by removing the entry from the proper hash bucket.
+ */
+static void
+unschedule_bw_meter(struct bw_meter *x)
+{
+    int time_hash;
+    struct bw_meter *prev, *tmp;
+    
+    if (! (x->flags & BW_METER_LEQ))
+	return;		/* XXX: we schedule timers only for "<=" entries */
+    
+    /*
+     * Compute the timeout hash value and delete the entry
+     */
+    time_hash = x->time_hash;
+    if (time_hash >= BW_METER_BUCKETS)
+	return;		/* Entry was not scheduled */
+    
+    for (prev = NULL, tmp = bw_meter_timers[time_hash];
+	     tmp != NULL; prev = tmp, tmp = tmp->time_next)
+	if (tmp == x)
+	    break;
+    
+    if (tmp == NULL)
+	panic("unschedule_bw_meter: bw_meter entry not found");
+    
+    if (prev != NULL)
+	prev->time_next = x->time_next;
+    else
+	bw_meter_timers[time_hash] = x->time_next;
+    
+    x->time_next = NULL;
+    x->time_hash = BW_METER_BUCKETS;
+}
+
+
+/*
+ * Process all "<=" type of bw_meter that should be processed now,
+ * and for each entry prepare an upcall if necessary. Each processed
+ * entry is rescheduled again for the (periodic) processing.
+ *
+ * This is run periodically (once per second normally). On each round,
+ * all the potentially matching entries are in the hash slot that we are
+ * looking at.
+ */
+static void
+bw_meter_process()
+{
+    static uint32_t last_tv_sec;	/* last time we processed this */
+
+    uint32_t loops;
+    int i, s;
+    struct timeval now, process_endtime;
+    
+    GET_TIME(now);
+    if (last_tv_sec == now.tv_sec)
+	return;		/* nothing to do */
+
+    s = splnet();
+    loops = now.tv_sec - last_tv_sec;
+    last_tv_sec = now.tv_sec;
+    if (loops > BW_METER_BUCKETS)
+	loops = BW_METER_BUCKETS;
+
+    /*
+     * Process all bins of bw_meter entries from the one after the last
+     * processed to the current one. On entry, i points to the last bucket
+     * visited, so we need to increment i at the beginning of the loop.
+     */
+    for (i = (now.tv_sec - loops + 1) % BW_METER_BUCKETS; loops > 0; loops--) {
+	struct bw_meter *x, *tmp_list;
+	
+	if (++i >= BW_METER_BUCKETS)
+	    i = 0;
+	
+	tmp_list = bw_meter_timers[i];
+	bw_meter_timers[i] = NULL;
+	
+	while (tmp_list != NULL) {
+	    x = tmp_list;
+	    tmp_list = tmp_list->time_next;
+	    
+	    /* Test if the time interval is over */
+	    process_endtime = x->start_time;
+	    BW_TIMEVALADD(&process_endtime, &x->threshold.time);
+	    if (BW_TIMEVALCMP(&process_endtime, &now, >)) {
+		/* Not yet: reschedule, but don't reset */
+		int time_hash;
+		
+		BW_METER_TIMEHASH(x, time_hash);
+		x->time_next = bw_meter_timers[time_hash];
+		bw_meter_timers[time_hash] = x;
+		x->time_hash = time_hash;
+		continue;
+	    }
+	    
+	    /*
+	     * Test if we should deliver an upcall
+	     */
+	    if (((x->flags & BW_UPCALL_UNIT_PACKETS)
+		 && (x->measured.packets <= x->threshold.packets))
+		|| ((x->flags & BW_UPCALL_UNIT_BYTES)
+		    && (x->measured.bytes <= x->threshold.bytes))) {
+		/* Prepare an upcall for delivery */
+		bw_meter_prepare_upcall(x, &now);
+	    }
+	    
+	    /*
+	     * Reschedule for next processing
+	     */
+	    schedule_bw_meter(x, &now);
+	}
+    }
+    splx(s);
+    
+    /* Send all upcalls that are pending delivery */
+    bw_upcalls_send();
+}
+
+/*
+ * A periodic function for sending all upcalls that are pending delivery
+ */
+static void
+expire_bw_upcalls_send(void *unused)
+{
+    bw_upcalls_send();
+    
+    bw_upcalls_ch = timeout(expire_bw_upcalls_send, NULL, BW_UPCALLS_PERIOD);
+}
+
+/*
+ * A periodic function for periodic scanning of the multicast forwarding
+ * table for processing all "<=" bw_meter entries.
+ */
+static void
+expire_bw_meter_process(void *unused)
+{
+    if (mrt_api_config & MRT_MFC_BW_UPCALL)
+	bw_meter_process();
+    
+    bw_meter_ch = timeout(expire_bw_meter_process, NULL, BW_METER_PERIOD);
+}
+
+/*
+ * End of bandwidth monitoring code
+ */
+
+#ifdef PIM
+/*
+ * Send the packet up to the user daemon, or eventually do kernel encapsulation
+ *
+ */
+static int
+pim_register_send(struct ip *ip, struct vif *vifp,
+	struct mbuf *m, struct mfc *rt)
+{
+    struct mbuf *mb_copy, *mm;
+    
+    if (mrtdebug & DEBUG_PIM)
+        log(LOG_DEBUG, "pim_register_send: ");
+    
+    mb_copy = pim_register_prepare(ip, m);
+    if (mb_copy == NULL)
+	return ENOBUFS;
+    
+    /*
+     * Send all the fragments. Note that the mbuf for each fragment
+     * is freed by the sending machinery.
+     */
+    for (mm = mb_copy; mm; mm = mb_copy) {
+	mb_copy = mm->m_nextpkt;
+	mm->m_nextpkt = 0;
+	mm = m_pullup(mm, sizeof(struct ip));
+	if (mm != NULL) {
+	    ip = mtod(mm, struct ip *);
+	    if ((mrt_api_config & MRT_MFC_RP)
+		&& (rt->mfc_rp.s_addr != INADDR_ANY)) {
+		pim_register_send_rp(ip, vifp, mm, rt);
+	    } else {
+		pim_register_send_upcall(ip, vifp, mm, rt);
+	    }
+	}
+    }
+    
+    return 0;
+}
+
+/*
+ * Return a copy of the data packet that is ready for PIM Register
+ * encapsulation.
+ * XXX: Note that in the returned copy the IP header is a valid one.
+ */
+static struct mbuf *
+pim_register_prepare(struct ip *ip, struct mbuf *m)
+{
+    struct mbuf *mb_copy = NULL;
+    int mtu;
+    
+    /*
+     * XXX: take care of delayed checksums.
+     * XXX: if network interfaces are capable of computing checksum for
+     * encapsulated multicast data packets, we need to reconsider this.
+     */
+    if (m->m_pkthdr.csum_flags & CSUM_DELAY_DATA) {
+	in_delayed_cksum(m);
+	m->m_pkthdr.csum_flags &= ~CSUM_DELAY_DATA;
+    }
+    
+    /*
+     * Copy the old packet & pullup its IP header into the
+     * new mbuf so we can modify it.
+     */
+    mb_copy = m_copypacket(m, M_DONTWAIT);
+    if (mb_copy == NULL)
+	return NULL;
+    mb_copy = m_pullup(mb_copy, ip->ip_hl << 2);
+    if (mb_copy == NULL)
+	return NULL;
+    
+    /* take care of the TTL */
+    ip = mtod(mb_copy, struct ip *);
+    --ip->ip_ttl;
+    
+    /* Compute the MTU after the PIM Register encapsulation */
+    mtu = 0xffff - sizeof(pim_encap_iphdr) - sizeof(pim_encap_pimhdr);
+    /*
+     * XXX if we do not have ip_fragment, just make sure that the
+     * size is allowable
+     */
+    if (ip_fragment(ip, &mb_copy, mtu, 0, 0) != 0) {
+	m_freem(mb_copy);
+	return NULL;
+    }
+    return mb_copy;
+}
+
+/*
+ * Send an upcall with the data packet to the user-level process.
+ */
+static int
+pim_register_send_upcall(struct ip *ip, struct vif *vifp,
+	struct mbuf *mb_copy, struct mfc *rt)
+{
+    struct mbuf *mb_first;
+    int len = ntohs(ip->ip_len);
+    struct igmpmsg *im;
+    struct sockaddr_in k_igmpsrc = { sizeof k_igmpsrc, AF_INET };
+    
+    /*
+     * Add a new mbuf with an upcall header
+     */
+    MGETHDR(mb_first, M_DONTWAIT, MT_HEADER);
+    if (mb_first == NULL) {
+	m_freem(mb_copy);
+	return ENOBUFS;
+    }
+    mb_first->m_data += max_linkhdr;
+    mb_first->m_pkthdr.len = len + sizeof(struct igmpmsg);
+    mb_first->m_len = sizeof(struct igmpmsg);
+    mb_first->m_next = mb_copy;
+    
+    /* Send message to routing daemon */
+    im = mtod(mb_first, struct igmpmsg *);
+    im->im_msgtype	= IGMPMSG_WHOLEPKT;
+    im->im_mbz		= 0;
+    im->im_vif		= vifp - viftable;
+    im->im_src		= ip->ip_src;
+    im->im_dst		= ip->ip_dst;
+    
+    k_igmpsrc.sin_addr	= ip->ip_src;
+    
+    mrtstat.mrts_upcalls++;
+    
+    if (socket_send(ip_mrouter, mb_first, &k_igmpsrc) < 0) {
+	if (mrtdebug & DEBUG_PIM)
+	    log(LOG_WARNING,
+		"mcast: pim_register_send_upcall: ip_mrouter socket queue full");
+	++mrtstat.mrts_upq_sockfull;
+	return ENOBUFS;
+    }
+    
+    /* Keep statistics */
+    pimstat.pims_snd_registers_msgs++;
+    pimstat.pims_snd_registers_bytes += len;
+    
+    return 0;
+}
+
+/*
+ * Encapsulate the data packet in PIM Register message and send it to the RP.
+ */
+static int
+pim_register_send_rp(struct ip *ip, struct vif *vifp,
+	struct mbuf *mb_copy, struct mfc *rt)
+{
+    struct mbuf *mb_first;
+    struct ip *ip_outer;
+    struct pim_encap_pimhdr *pimhdr;
+    int len = ntohs(ip->ip_len);
+    vifi_t vifi = rt->mfc_parent;
+    
+    if ((vifi >= numvifs) || (viftable[vifi].v_lcl_addr.s_addr == 0)) {
+	m_freem(mb_copy);
+	return EADDRNOTAVAIL;		/* The iif vif is invalid */
+    }
+    
+    /*
+     * Add a new mbuf with the encapsulating header
+     */
+    MGETHDR(mb_first, M_DONTWAIT, MT_HEADER);
+    if (mb_first == NULL) {
+	m_freem(mb_copy);
+	return ENOBUFS;
+    }
+    mb_first->m_data += max_linkhdr;
+    mb_first->m_len = sizeof(pim_encap_iphdr) + sizeof(pim_encap_pimhdr);
+    mb_first->m_next = mb_copy;
+
+    mb_first->m_pkthdr.len = len + mb_first->m_len;
+    
+    /*
+     * Fill in the encapsulating IP and PIM header
+     */
+    ip_outer = mtod(mb_first, struct ip *);
+    *ip_outer = pim_encap_iphdr;
+#ifdef RANDOM_IP_ID
+    ip_outer->ip_id = ip_randomid();
+#else
+    ip_outer->ip_id = htons(ip_id++);
+#endif
+    ip_outer->ip_len = len + sizeof(pim_encap_iphdr) + sizeof(pim_encap_pimhdr);
+    ip_outer->ip_src = viftable[vifi].v_lcl_addr;
+    ip_outer->ip_dst = rt->mfc_rp;
+    /*
+     * Copy the inner header TOS to the outer header, and take care of the
+     * IP_DF bit.
+     */
+    ip_outer->ip_tos = ip->ip_tos;
+    if (ntohs(ip->ip_off) & IP_DF)
+	ip_outer->ip_off |= IP_DF;
+    pimhdr = (struct pim_encap_pimhdr *)((caddr_t)ip_outer
+					 + sizeof(pim_encap_iphdr));
+    *pimhdr = pim_encap_pimhdr;
+    /* If the iif crosses a border, set the Border-bit */
+    if (rt->mfc_flags[vifi] & MRT_MFC_FLAGS_BORDER_VIF & mrt_api_config)
+	pimhdr->flags |= htonl(PIM_BORDER_REGISTER);
+    
+    mb_first->m_data += sizeof(pim_encap_iphdr);
+    pimhdr->pim.pim_cksum = in_cksum(mb_first, sizeof(pim_encap_pimhdr));
+    mb_first->m_data -= sizeof(pim_encap_iphdr);
+    
+    if (vifp->v_rate_limit == 0)
+	tbf_send_packet(vifp, mb_first);
+    else
+	tbf_control(vifp, mb_first, ip, ip_outer->ip_len);
+    
+    /* Keep statistics */
+    pimstat.pims_snd_registers_msgs++;
+    pimstat.pims_snd_registers_bytes += len;
+    
+    return 0;
+}
+
+/*
+ * PIM-SMv2 and PIM-DM messages processing.
+ * Receives and verifies the PIM control messages, and passes them
+ * up to the listening socket, using rip_input().
+ * The only message with special processing is the PIM_REGISTER message
+ * (used by PIM-SM): the PIM header is stripped off, and the inner packet
+ * is passed to if_simloop().
+ */
+void
+pim_input(struct mbuf *m, int off)
+{
+    struct ip *ip = mtod(m, struct ip *);
+    struct pim *pim;
+    int minlen;
+    int datalen = ip->ip_len;
+    int dosum;
+    int ip_tos;
+    int iphlen = off;
+    
+    /* Keep statistics */
+    pimstat.pims_rcv_total_msgs++;
+    pimstat.pims_rcv_total_bytes += datalen;
+    
+    /*
+     * Validate lengths
+     */
+    if (datalen < PIM_MINLEN) {
+	pimstat.pims_rcv_tooshort++;
+	log(LOG_ERR, "pim_input: packet size too small %d from %lx\n",
+	    datalen, (u_long)ip->ip_src.s_addr);
+	m_freem(m);
+	return;
+    }
+    
+    /*
+     * If the packet is at least as big as a REGISTER, go agead
+     * and grab the PIM REGISTER header size, to avoid another
+     * possible m_pullup() later.
+     * 
+     * PIM_MINLEN       == pimhdr + u_int32_t == 4 + 4 = 8
+     * PIM_REG_MINLEN   == pimhdr + reghdr + encap_iphdr == 4 + 4 + 20 = 28
+     */
+    minlen = iphlen + (datalen >= PIM_REG_MINLEN ? PIM_REG_MINLEN : PIM_MINLEN);
+    /*
+     * Get the IP and PIM headers in contiguous memory, and
+     * possibly the PIM REGISTER header.
+     */
+    if ((m->m_flags & M_EXT || m->m_len < minlen) &&
+	(m = m_pullup(m, minlen)) == 0) {
+	log(LOG_ERR, "pim_input: m_pullup failure\n");
+	return;
+    }
+    /* m_pullup() may have given us a new mbuf so reset ip. */
+    ip = mtod(m, struct ip *);
+    ip_tos = ip->ip_tos;
+    
+    /* adjust mbuf to point to the PIM header */
+    m->m_data += iphlen;
+    m->m_len  -= iphlen;
+    pim = mtod(m, struct pim *);
+    
+    /*
+     * Validate checksum. If PIM REGISTER, exclude the data packet.
+     *
+     * XXX: some older PIMv2 implementations don't make this distinction,
+     * so for compatibility reason perform the checksum over part of the
+     * message, and if error, then over the whole message.
+     */
+    if (PIM_VT_T(pim->pim_vt) == PIM_REGISTER)
+	dosum = in_cksum(m, PIM_MINLEN);
+    else
+	dosum = 1;
+    if (dosum)
+	dosum = in_cksum(m, datalen);
+    if (dosum) {
+	pimstat.pims_rcv_badsum++;
+	if (mrtdebug & DEBUG_PIM)
+	    log(LOG_DEBUG, "pim_input: invalid checksum");
+	m_freem(m);
+	return;
+    }
+    
+    /* PIM version check */
+    if (PIM_VT_V(pim->pim_vt) < PIM_VERSION) {
+	pimstat.pims_rcv_badversion++;
+	log(LOG_ERR, "pim_input: incorrect version %d, expecting %d\n",
+	    PIM_VT_V(pim->pim_vt), PIM_VERSION);
+	m_freem(m);
+	return;
+    }
+    
+    /* restore mbuf back to the outer IP */
+    m->m_data -= iphlen;
+    m->m_len  += iphlen;
+    
+    if (PIM_VT_T(pim->pim_vt) == PIM_REGISTER) {
+	/*
+	 * Since this is a REGISTER, we'll make a copy of the register
+	 * headers ip + pim + u_int32 + encap_ip, to be passed up to the
+	 * routing daemon.
+	 */
+	struct sockaddr_in dst = { sizeof(dst), AF_INET };
+	struct mbuf *mcp;
+	struct ip *encap_ip;
+	u_int32_t *reghdr;
+	
+	if ((reg_vif_num >= numvifs) || (reg_vif_num == (vifi_t) -1)) {
+	    if (mrtdebug & DEBUG_PIM)
+		log(LOG_DEBUG,
+		    "pim_input: register vif not set: %d\n", reg_vif_num);
+	    m_freem(m);
+	    return;
+	}
+	
+	/*
+	 * Validate length
+	 */
+	if (datalen < PIM_REG_MINLEN) {
+	    pimstat.pims_rcv_tooshort++;
+	    pimstat.pims_rcv_badregisters++;
+	    log(LOG_ERR,
+		"pim_input: register packet size too small %d from %lx\n",
+		datalen, (u_long)ip->ip_src.s_addr);
+	    m_freem(m);
+	    return;
+	}
+	
+	reghdr = (u_int32_t *)(pim + 1);
+	encap_ip = (struct ip *)(reghdr + 1);
+	
+	if (mrtdebug & DEBUG_PIM) {
+	    log(LOG_DEBUG,
+		"pim_input[register], encap_ip: %lx -> %lx, encap_ip len %d\n",
+		(u_long)ntohl(encap_ip->ip_src.s_addr),
+		(u_long)ntohl(encap_ip->ip_dst.s_addr),
+		ntohs(encap_ip->ip_len));
+	}
+	
+	/* verify the version number of the inner packet */
+	if (encap_ip->ip_v != IPVERSION) {
+	    pimstat.pims_rcv_badregisters++;
+	    if (mrtdebug & DEBUG_PIM) {
+		log(LOG_DEBUG, "pim_input: invalid IP version (%d) "
+		    "of the inner packet\n", encap_ip->ip_v);
+	    }
+	    m_freem(m);
+	    return;
+	}
+	
+	/* verify the inner packet is destined to a mcast group */
+	if (!IN_MULTICAST(ntohl(encap_ip->ip_dst.s_addr))) {
+	    pimstat.pims_rcv_badregisters++;
+	    if (mrtdebug & DEBUG_PIM)
+		log(LOG_DEBUG,
+		    "pim_input: inner packet of register is not "
+		    "multicast %lx\n",
+		    (u_long)ntohl(encap_ip->ip_dst.s_addr));
+	    m_freem(m);
+	    return;
+	}
+	
+	/*
+	 * Copy the TOS from the outer IP header to the inner IP header.
+	 */
+	if (encap_ip->ip_tos != ip_tos) {
+	    /* Outer TOS -> inner TOS */
+	    encap_ip->ip_tos = ip_tos;
+	    /* Recompute the inner header checksum. Sigh... */
+	    
+	    /* adjust mbuf to point to the inner IP header */
+	    m->m_data += (iphlen + PIM_MINLEN);
+	    m->m_len  -= (iphlen + PIM_MINLEN);
+	    
+	    encap_ip->ip_sum = 0;
+	    encap_ip->ip_sum = in_cksum(m, encap_ip->ip_hl << 2);
+	    
+	    /* restore mbuf to point back to the outer IP header */
+	    m->m_data -= (iphlen + PIM_MINLEN);
+	    m->m_len  += (iphlen + PIM_MINLEN);
+	}
+	
+	/* If a NULL_REGISTER, pass it to the daemon */
+	if ((ntohl(*reghdr) & PIM_NULL_REGISTER))
+	    goto pim_input_to_daemon;
+	
+	/*
+	 * Decapsulate the inner IP packet and loopback to forward it
+	 * as a normal multicast packet. Also, make a copy of the 
+	 *     outer_iphdr + pimhdr + reghdr + encap_iphdr
+	 * to pass to the daemon later, so it can take the appropriate
+	 * actions (e.g., send back PIM_REGISTER_STOP).
+	 * XXX: here m->m_data points to the outer IP header.
+	 */
+	mcp = m_copy(m, 0, iphlen + PIM_REG_MINLEN);
+	if (mcp == NULL) {
+	    log(LOG_ERR,
+		"pim_input: pim register: could not copy register head\n");
+	    m_freem(m);
+	    return;
+	}
+	
+	/* Keep statistics */
+	/* XXX: registers_bytes include only the encap. mcast pkt */
+	pimstat.pims_rcv_registers_msgs++;
+	pimstat.pims_rcv_registers_bytes += ntohs(encap_ip->ip_len);
+	
+	/*
+	 * forward the inner ip packet; point m_data at the inner ip.
+	 */
+	m_adj(m, iphlen + PIM_MINLEN);
+	
+	if (mrtdebug & DEBUG_PIM) {
+	    log(LOG_DEBUG,
+		"pim_input: forwarding decapsulated register: "
+		"src %lx, dst %lx, vif %d\n",
+		(u_long)ntohl(encap_ip->ip_src.s_addr),
+		(u_long)ntohl(encap_ip->ip_dst.s_addr),
+		reg_vif_num);
+	}
+	if_simloop(viftable[reg_vif_num].v_ifp, m, dst.sin_family, 0);
+	
+	/* prepare the register head to send to the mrouting daemon */
+	m = mcp;
+    }
+
+pim_input_to_daemon:    
+    /*
+     * Pass the PIM message up to the daemon; if it is a Register message,
+     * pass the 'head' only up to the daemon. This includes the
+     * outer IP header, PIM header, PIM-Register header and the
+     * inner IP header.
+     * XXX: the outer IP header pkt size of a Register is not adjust to
+     * reflect the fact that the inner multicast data is truncated.
+     */
+    rip_input(m, iphlen);
+
+    return;
+}
+#endif /* PIM */
+
 static int
 ip_mroute_modevent(module_t mod, int type, void *unused)
 {
@@ -1905,7 +3254,7 @@
 	ip_rsvp_vif = NULL;
 	legal_vif_num = NULL;
 	mrt_ioctl = NULL;
-	rsvp_input_p = NULL;
+	rsvp_input_p = NULL; 
 	splx(s);
 	break;
     }
Index: sys/netinet/ip_mroute.h
===================================================================
RCS file: /home/xorpc/u2/freebsd/src/sys/netinet/ip_mroute.h,v
retrieving revision 1.20
diff -u -r1.20 ip_mroute.h
--- sys/netinet/ip_mroute.h	15 Nov 2002 22:53:52 -0000	1.20
+++ sys/netinet/ip_mroute.h	22 Nov 2002 01:06:32 -0000
@@ -35,7 +35,7 @@
  * SUCH DAMAGE.
  *
  *	@(#)ip_mroute.h	8.1 (Berkeley) 6/10/93
- * $FreeBSD: src/sys/netinet/ip_mroute.h,v 1.20 2002/11/15 22:53:52 luigi Exp $
+ * $FreeBSD$
  */
 
 #ifndef _NETINET_IP_MROUTE_H_
@@ -48,8 +48,12 @@
  * Modified by Steve Deering, Stanford, February 1989.
  * Modified by Ajit Thyagarajan, PARC, August 1993.
  * Modified by Ajit Thyagarajan, PARC, August 1994.
+ * Modified by Ahmed Helmy, SGI, June 1996.
+ * Modified by Pavlin Radoslavov, ICSI, October 2002.
  *
  * MROUTING Revision: 3.3.1.3
+ * and PIM-SMv2 and PIM-DM support, advanced API support,
+ * bandwidth metering and signaling
  */
 
 
@@ -63,7 +67,13 @@
 #define MRT_ADD_MFC	104	/* insert forwarding cache entry */
 #define MRT_DEL_MFC	105	/* delete forwarding cache entry */
 #define MRT_VERSION	106	/* get kernel version number */
-#define MRT_ASSERT      107     /* enable PIM assert processing */
+#define MRT_ASSERT	107	/* enable assert processing */
+#define MRT_PIM		MRT_ASSERT	/* enable PIM processing XXX */
+#define	MRT_API_SUPPORT	109	/* supported MRT API */
+#define	MRT_API_CONFIG	110	/* config MRT API */
+#define	MRT_ADD_BW_UPCALL 111	/* create bandwidth monitor */
+#define	MRT_DEL_BW_UPCALL 112	/* delete bandwidth monitor */
+
 
 
 #define GET_TIME(t)	microtime(&t)
@@ -99,57 +109,144 @@
 
 #define	VIFF_TUNNEL	0x1		/* vif represents a tunnel end-point */
 #define VIFF_SRCRT	0x2		/* tunnel uses IP source routing */
+#define VIFF_REGISTER	0x4		/* used for PIM Register encap/decap */
 
 /*
  * Argument structure for MRT_ADD_MFC and MRT_DEL_MFC
- * (mfcc_tos to be added at a future point)
+ * XXX if you change this, make sure to change mfcctl2 as well.
  */
 struct mfcctl {
-    struct in_addr  mfcc_origin;		/* ip origin of mcasts       */
-    struct in_addr  mfcc_mcastgrp; 		/* multicast group associated*/
-    vifi_t	    mfcc_parent;   		/* incoming vif              */
-    u_char	    mfcc_ttls[MAXVIFS]; 	/* forwarding ttls on vifs   */
+	struct in_addr	mfcc_origin;		/* ip origin of mcasts       */
+	struct in_addr	mfcc_mcastgrp; 		/* multicast group associated*/
+	vifi_t		mfcc_parent;   		/* incoming vif              */
+	u_char		mfcc_ttls[MAXVIFS]; 	/* forwarding ttls on vifs   */
+};
+
+/*
+ * The new argument structure for MRT_ADD_MFC and MRT_DEL_MFC overlays
+ * and extends the old struct mfcctl.
+ */
+struct mfcctl2 {
+	/* the mfcctl fields */
+	struct in_addr	mfcc_origin;		/* ip origin of mcasts       */
+	struct in_addr	mfcc_mcastgrp; 		/* multicast group associated*/
+	vifi_t		mfcc_parent;   		/* incoming vif              */
+	u_char		mfcc_ttls[MAXVIFS]; 	/* forwarding ttls on vifs   */
+
+	/* extension fields */
+	uint8_t		mfcc_flags[MAXVIFS];	/* the MRT_MFC_FLAGS_* flags */
+	struct in_addr	mfcc_rp;		/* the RP address            */
+};
+#define	MRT_MFC_FLAGS_DISABLE_WRONGVIF	(1 << 0) /* disable WRONGVIF signals */
+#define	MRT_MFC_FLAGS_BORDER_VIF	(1 << 1) /* border vif */
+#define MRT_MFC_RP			(1 << 8) /* enable RP address */
+#define MRT_MFC_BW_UPCALL		(1 << 9) /* enable bw upcalls */
+
+#define MRT_MFC_FLAGS_ALL	( MRT_MFC_FLAGS_DISABLE_WRONGVIF	\
+				| MRT_MFC_FLAGS_BORDER_VIF )
+
+#define MRT_API_FLAGS_ALL	( MRT_MFC_FLAGS_ALL			\
+				| MRT_MFC_RP				\
+				| MRT_MFC_BW_UPCALL )
+
+/*
+ * Structure for installing or delivering an upcall if the
+ * measured bandwidth is above or below a threshold.
+ *
+ * User programs (e.g. daemons) may have a need to know when the
+ * bandwidth used by some data flow is above or below some threshold.
+ * This interface allows the userland to specify the threshold (in
+ * bytes and/or packets) and the measurement interval. Flows are
+ * all packet with the same source and destination IP address.
+ * At the moment the code is only used for multicast destinations
+ * but there is nothing that prevents its use for unicast.
+ *
+ * The measurement interval cannot be shorter than some Tmin (3s currently),
+ * the threshold is set in packets and/or bytes per_interval.
+ *
+ * Measurement works as follows:
+ * For >= measurements: 
+ * the first packet marks the start of a measurement interval.
+ * During an interval we count packets and bytes, and when we
+ * pass the threshold we deliver an upcall and we are done.
+ * The first packet after the end of the interval resets the
+ * count and restarts the measurement.
+ *
+ * For <= measurement:
+ * we start a timer to fire at the end of the interval, and
+ * then for each incoming packet we count packets and bytes.
+ * When the timer fires, we compare the value with the threshold,
+ * schedule an upcall if we are below, and restart the measurement
+ * (reschedule timer and zero counters).
+ *
+ */
+
+struct bw_data {
+	struct timeval	time;
+	uint64_t	packets;
+	uint64_t	bytes;
+};
+
+struct bw_upcall {
+	struct in_addr	src;			/* source address            */
+	struct in_addr	dst;			/* destination address       */
+	uint32_t	flags;			/* misc flags (see below)    */
+#define BW_UPCALL_UNIT_PACKETS   (1 << 0)	/* threshold (in packets)    */
+#define BW_UPCALL_UNIT_BYTES     (1 << 1)	/* threshold (in bytes)      */
+#define BW_UPCALL_GEQ            (1 << 2)	/* upcall if bw >= threshold */
+#define BW_UPCALL_LEQ            (1 << 3)	/* upcall if bw <= threshold */
+#define BW_UPCALL_DELETE_ALL     (1 << 4)	/* delete all upcalls for s,d*/
+
+	struct bw_data	threshold;
+	struct bw_data	measured;
 };
 
+/* max. number of upcalls to deliver together */
+#define BW_UPCALLS_MAX				128
+/* min. threshold time interval for bandwidth measurement */
+#define BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC	3
+#define BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC	0
+
+
 /*
  * The kernel's multicast routing statistics.
  */
 struct mrtstat {
-    u_long	mrts_mfc_lookups;	/* # forw. cache hash table hits   */
-    u_long	mrts_mfc_misses;	/* # forw. cache hash table misses */
-    u_long	mrts_upcalls;		/* # calls to mrouted              */
-    u_long	mrts_no_route;		/* no route for packet's origin    */
-    u_long	mrts_bad_tunnel;	/* malformed tunnel options        */
-    u_long	mrts_cant_tunnel;	/* no room for tunnel options      */
-    u_long	mrts_wrong_if;		/* arrived on wrong interface	   */
-    u_long	mrts_upq_ovflw;		/* upcall Q overflow		   */
-    u_long	mrts_cache_cleanups;	/* # entries with no upcalls 	   */
-    u_long  	mrts_drop_sel;     	/* pkts dropped selectively        */
-    u_long  	mrts_q_overflow;    	/* pkts dropped - Q overflow       */
-    u_long  	mrts_pkt2large;     	/* pkts dropped - size > BKT SIZE  */
-    u_long	mrts_upq_sockfull;	/* upcalls dropped - socket full */
+	u_long	mrts_mfc_lookups;	/* # forw. cache hash table hits   */
+	u_long	mrts_mfc_misses;	/* # forw. cache hash table misses */
+	u_long	mrts_upcalls;		/* # calls to mrouted              */
+	u_long	mrts_no_route;		/* no route for packet's origin    */
+	u_long	mrts_bad_tunnel;	/* malformed tunnel options        */
+	u_long	mrts_cant_tunnel;	/* no room for tunnel options      */
+	u_long	mrts_wrong_if;		/* arrived on wrong interface	   */
+	u_long	mrts_upq_ovflw;		/* upcall Q overflow		   */
+	u_long	mrts_cache_cleanups;	/* # entries with no upcalls 	   */
+	u_long  mrts_drop_sel;     	/* pkts dropped selectively        */
+	u_long  mrts_q_overflow;    	/* pkts dropped - Q overflow       */
+	u_long  mrts_pkt2large;     	/* pkts dropped - size > BKT SIZE  */
+	u_long	mrts_upq_sockfull;	/* upcalls dropped - socket full */
 };
 
 /*
  * Argument structure used by mrouted to get src-grp pkt counts
  */
 struct sioc_sg_req {
-    struct in_addr src;
-    struct in_addr grp;
-    u_long pktcnt;
-    u_long bytecnt;
-    u_long wrong_if;
+	struct in_addr	src;
+	struct in_addr	grp;
+	u_long		pktcnt;
+	u_long		bytecnt;
+	u_long		wrong_if;
 };
 
 /*
  * Argument structure used by mrouted to get vif pkt counts
  */
 struct sioc_vif_req {
-    vifi_t vifi;		/* vif number				*/
-    u_long icount;		/* Input packet count on vif		*/
-    u_long ocount;		/* Output packet count on vif		*/
-    u_long ibytes;		/* Input byte count on vif		*/
-    u_long obytes;		/* Output byte count on vif		*/
+	vifi_t	vifi;		/* vif number				*/
+	u_long	icount;		/* Input packet count on vif		*/
+	u_long	ocount;		/* Output packet count on vif		*/
+	u_long	ibytes;		/* Input byte count on vif		*/
+	u_long	obytes;		/* Output byte count on vif		*/
 };
     
 
@@ -157,20 +254,20 @@
  * The kernel's virtual-interface structure.
  */
 struct vif {
-    u_char   		v_flags;     	/* VIFF_ flags defined above         */
-    u_char   		v_threshold;	/* min ttl required to forward on vif*/
-    u_int      		v_rate_limit; 	/* max rate			     */
-    struct tbf 	       *v_tbf;       	/* token bucket structure at intf.   */
-    struct in_addr 	v_lcl_addr;   	/* local interface address           */
-    struct in_addr 	v_rmt_addr;   	/* remote address (tunnels only)     */
-    struct ifnet       *v_ifp;	     	/* pointer to interface              */
-    u_long		v_pkt_in;	/* # pkts in on interface            */
-    u_long		v_pkt_out;	/* # pkts out on interface           */
-    u_long		v_bytes_in;	/* # bytes in on interface	     */
-    u_long		v_bytes_out;	/* # bytes out on interface	     */
-    struct route	v_route;	/* cached route if this is a tunnel */
-    u_int		v_rsvp_on;	/* RSVP listening on this vif */
-    struct socket      *v_rsvpd;	/* RSVP daemon socket */
+	u_char   	v_flags;	/* VIFF_ flags defined above         */
+	u_char   	v_threshold;	/* min ttl required to forward on vif*/
+	u_int      	v_rate_limit;	/* max rate			     */
+	struct tbf	*v_tbf;       	/* token bucket structure at intf.   */
+	struct in_addr	v_lcl_addr;	/* local interface address           */
+	struct in_addr	v_rmt_addr;	/* remote address (tunnels only)     */
+	struct ifnet	*v_ifp;		/* pointer to interface              */
+	u_long		v_pkt_in;	/* # pkts in on interface            */
+	u_long		v_pkt_out;	/* # pkts out on interface           */
+	u_long		v_bytes_in;	/* # bytes in on interface	     */
+	u_long		v_bytes_out;	/* # bytes out on interface	     */
+	struct route	v_route;	/* cached route if this is a tunnel  */
+	u_int		v_rsvp_on;	/* RSVP listening on this vif        */
+	struct socket	*v_rsvpd;	/* RSVP daemon socket                */
 };
 
 /*
@@ -179,17 +276,20 @@
  * at a future point)
  */
 struct mfc {
-    struct in_addr  mfc_origin;	 		/* IP origin of mcasts   */
-    struct in_addr  mfc_mcastgrp;  		/* multicast group associated*/
-    vifi_t	    mfc_parent; 		/* incoming vif              */
-    u_char	    mfc_ttls[MAXVIFS]; 		/* forwarding ttls on vifs   */
-    u_long	    mfc_pkt_cnt;		/* pkt count for src-grp     */
-    u_long	    mfc_byte_cnt;		/* byte count for src-grp    */
-    u_long	    mfc_wrong_if;		/* wrong if for src-grp	     */
-    int		    mfc_expire;			/* time to clean entry up    */
-    struct timeval  mfc_last_assert;		/* last time I sent an assert*/
-    struct rtdetq  *mfc_stall;			/* q of packets awaiting mfc */
-    struct mfc     *mfc_next;			/* next mfc entry            */
+	struct in_addr	mfc_origin;		/* IP origin of mcasts       */
+	struct in_addr	mfc_mcastgrp;		/* multicast group associated*/
+	vifi_t		mfc_parent;		/* incoming vif              */
+	u_char		mfc_ttls[MAXVIFS];	/* forwarding ttls on vifs   */
+	u_long		mfc_pkt_cnt;		/* pkt count for src-grp     */
+	u_long		mfc_byte_cnt;		/* byte count for src-grp    */
+	u_long		mfc_wrong_if;		/* wrong if for src-grp	     */
+	int		mfc_expire;		/* time to clean entry up    */
+	struct timeval	mfc_last_assert;	/* last time I sent an assert*/
+	struct rtdetq	*mfc_stall;		/* q of packets awaiting mfc */
+	struct mfc	*mfc_next;		/* next mfc entry            */
+	uint8_t		mfc_flags[MAXVIFS];	/* the MRT_MFC_FLAGS_* flags */
+	struct in_addr	mfc_rp;			/* the RP address            */
+	struct bw_meter	*mfc_bw_meter;		/* list of bandwidth meters  */
 };
 
 /*
@@ -197,25 +297,27 @@
  * note the convenient similarity to an IP packet
  */
 struct igmpmsg {
-    u_long	    unused1;
-    u_long	    unused2;
-    u_char	    im_msgtype;			/* what type of message	    */
-#define IGMPMSG_NOCACHE		1
-#define IGMPMSG_WRONGVIF	2
-    u_char	    im_mbz;			/* must be zero		    */
-    u_char	    im_vif;			/* vif rec'd on		    */
-    u_char	    unused3;
-    struct in_addr  im_src, im_dst;
+	u_long	    unused1;
+	u_long	    unused2;
+	u_char	    im_msgtype;			/* what type of message	    */
+#define IGMPMSG_NOCACHE		1	/* no MFC in the kernel */
+#define IGMPMSG_WRONGVIF	2	/* packet came from wrong interface */
+#define	IGMPMSG_WHOLEPKT	3	/* PIM pkt for user level encap. */
+#define	IGMPMSG_BW_UPCALL	4	/* BW monitoring upcall	*/
+	u_char	    im_mbz;			/* must be zero		    */
+	u_char	    im_vif;			/* vif rec'd on		    */
+	u_char	    unused3;
+	struct in_addr  im_src, im_dst;
 };
 
 /*
  * Argument structure used for pkt info. while upcall is made
  */
 struct rtdetq {
-    struct mbuf 	*m;		/* A copy of the packet		    */
-    struct ifnet	*ifp;		/* Interface pkt came in on	    */
-    vifi_t		xmt_vif;	/* Saved copy of imo_multicast_vif  */
-    struct rtdetq	*next;		/* Next in list of packets          */
+	struct mbuf 	*m;		/* A copy of the packet		    */
+	struct ifnet	*ifp;		/* Interface pkt came in on	    */
+	vifi_t		xmt_vif;	/* Saved copy of imo_multicast_vif  */
+	struct rtdetq	*next;		/* Next in list of packets          */
 };
 
 #define MFCTBLSIZ	256
@@ -238,12 +340,36 @@
  */
 struct tbf
 {
-    struct timeval tbf_last_pkt_t; /* arr. time of last pkt 	*/
-    u_long tbf_n_tok;      	/* no of tokens in bucket 	*/
-    u_long tbf_q_len;    	/* length of queue at this vif	*/
-    u_long tbf_max_q_len;	/* max. queue length		*/
-    struct mbuf *tbf_q;		/* Packet queue			*/
-    struct mbuf *tbf_t;		/* tail-insertion pointer	*/
+	struct timeval	tbf_last_pkt_t;		/* arr. time of last pkt */
+	u_long		tbf_n_tok;      	/* # of tokens in bucket */
+	u_long		tbf_q_len;		/* length of queue	 */
+	u_long		tbf_max_q_len;		/* max. queue length	 */
+	struct		mbuf *tbf_q;		/* queue head		 */
+	struct		mbuf *tbf_t;		/* queue tail		 */
+};
+
+/*
+ * Structure for measuring the bandwidth and sending an upcall if the
+ * measured bandwidth is above or below a threshold.
+ */
+struct bw_meter {
+	struct bw_meter	*mfc_next;		/* next bw meter (same mfc)  */
+	struct bw_meter	*time_next;		/* next bw meter (same time) */
+	uint32_t	time_hash;		/* the time hash value       */
+	struct mfc	*mfc;			/* the corresponding mfc     */
+	uint32_t	flags;			/* misc flags (see below)    */
+#define BW_METER_UNIT_PACKETS	(1 << 0)	/* threshold (in packets)    */
+#define BW_METER_UNIT_BYTES	(1 << 1)	/* threshold (in bytes)      */
+#define BW_METER_GEQ		(1 << 2)	/* upcall if bw >= threshold */
+#define BW_METER_LEQ		(1 << 3)	/* upcall if bw <= threshold */
+#define BW_METER_USER_FLAGS 		\
+    (BW_METER_UNIT_PACKETS | BW_METER_UNIT_BYTES | BW_METER_GEQ | BW_METER_LEQ)
+
+#define BW_METER_UPCALL_DELIVERED (1 << 24)	/* upcall was delivered      */
+
+	struct bw_data	threshold;
+	struct bw_data	measured;		/* here, t is unused */
+	struct timeval	start_time;
 };
 
 #ifdef _KERNEL
Index: sys/netinet/raw_ip.c
===================================================================
RCS file: /home/xorpc/u2/freebsd/src/sys/netinet/raw_ip.c,v
retrieving revision 1.107
diff -u -r1.107 raw_ip.c
--- sys/netinet/raw_ip.c	20 Nov 2002 19:00:54 -0000	1.107
+++ sys/netinet/raw_ip.c	2 Dec 2002 18:44:55 -0000
@@ -373,6 +373,10 @@
 		case MRT_DEL_MFC:
 		case MRT_VERSION:
 		case MRT_ASSERT:
+		case MRT_API_SUPPORT:
+		case MRT_API_CONFIG:
+		case MRT_ADD_BW_UPCALL:
+		case MRT_DEL_BW_UPCALL:
 			error = ip_mrouter_get ? ip_mrouter_get(so, sopt) :
 				EOPNOTSUPP;
 			break;
@@ -438,6 +442,10 @@
 		case MRT_DEL_MFC:
 		case MRT_VERSION:
 		case MRT_ASSERT:
+		case MRT_API_SUPPORT:
+		case MRT_API_CONFIG:
+		case MRT_ADD_BW_UPCALL:
+		case MRT_DEL_BW_UPCALL:
 			error = ip_mrouter_set ? ip_mrouter_set(so, sopt) :
 					EOPNOTSUPP;
 			break;
--- /dev/null	Mon Dec  2 14:34:20 2002
+++ sys/netinet/pim.h	Thu Nov 21 17:04:12 2002
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 1996-2000
+ * University of Southern California/Information Sciences Institute.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _NETINET_PIM_H_
+#define _NETINET_PIM_H_
+
+/*
+ * Protocol Independent Multicast (PIM) definitions.
+ * RFC 2362, June 1998.
+ *
+ * Written by Ahmed Helmy, USC/SGI, July 1996.
+ * Modified by George Edmond Eddy (Rusty), ISI, February 1998.
+ * Modified by Pavlin Radoslavov, USC/ISI, May 1998, October 2000.
+ */
+
+
+#ifndef _PIM_VT
+#ifndef BYTE_ORDER
+# error BYTE_ORDER is not defined!
+#endif
+#if (BYTE_ORDER != BIG_ENDIAN) && (BYTE_ORDER != LITTLE_ENDIAN)
+# error BYTE_ORDER must be defined to either BIG_ENDIAN or LITTLE_ENDIAN
+#endif
+#endif /* ! _PIM_VT */
+
+/*
+ * PIM packet header
+ */
+struct pim {
+#ifdef _PIM_VT
+	uint8_t		pim_vt;		/* PIM version and message type	*/
+#else /* ! _PIM_VT   */
+#if BYTE_ORDER == BIG_ENDIAN
+	u_int		pim_vers:4,	/* PIM protocol version		*/
+			pim_type:4;	/* PIM message type		*/
+#endif
+#if BYTE_ORDER == LITTLE_ENDIAN
+	u_int		pim_type:4,	/* PIM message type		*/
+			pim_vers:4;	/* PIM protocol version		*/
+#endif
+#endif /* ! _PIM_VT  */
+	uint8_t		pim_reserved;	/* Reserved			*/
+	uint16_t	pim_cksum;	/* IP-style checksum		*/
+};
+/* KAME-related name backward compatibility */
+#define pim_ver pim_vers
+#define pim_rsv pim_reserved
+
+#ifdef _PIM_VT
+#define PIM_MAKE_VT(v, t)	(0xff & (((v) << 4) | (0x0f & (t))))
+#define PIM_VT_V(x)		(((x) >> 4) & 0x0f)
+#define PIM_VT_T(x)		((x) & 0x0f)
+#endif /* _PIM_VT */
+
+#define PIM_VERSION		2
+#define PIM_MINLEN		8	/* PIM message min. length	*/
+#define PIM_REG_MINLEN	(PIM_MINLEN+20)	/* PIM Register hdr + inner IPv4 hdr */
+#define PIM6_REG_MINLEN	(PIM_MINLEN+40)	/* PIM Register hdr + inner IPv6 hdr */
+
+/*
+ * PIM message types
+ */
+#define PIM_HELLO		0x0	/* PIM-SM and PIM-DM		*/
+#define PIM_REGISTER		0x1	/* PIM-SM only			*/
+#define PIM_REGISTER_STOP	0x2	/* PIM-SM only			*/
+#define PIM_JOIN_PRUNE		0x3	/* PIM-SM and PIM-DM		*/
+#define PIM_BOOTSTRAP		0x4	/* PIM-SM only			*/
+#define PIM_ASSERT		0x5	/* PIM-SM and PIM-DM		*/
+#define PIM_GRAFT		0x6	/* PIM-DM only			*/
+#define PIM_GRAFT_ACK		0x7	/* PIM-DM only			*/
+#define PIM_CAND_RP_ADV		0x8	/* PIM-SM only			*/
+#define PIM_ALL_DF_ELECTION	0xa	/* Bidir-PIM-SM only		*/
+
+/*
+ * PIM-Register message flags
+ */
+#define PIM_BORDER_REGISTER 0x80000000U	/* The Border bit (host-order)	*/
+#define PIM_NULL_REGISTER   0x40000000U	/* The Null-Register bit (host-order)*/
+
+/*
+ * All-PIM-Routers IPv4 and IPv6 multicast addresses
+ */
+#define INADDR_ALLPIM_ROUTERS_GROUP	(uint32_t)0xe000000dU  /* 224.0.0.13 */
+#define IN6ADDR_LINKLOCAL_ALLPIM_ROUTERS	"ff02::d"
+#define IN6ADDR_LINKLOCAL_ALLPIM_ROUTERS_INIT				\
+	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		\
+	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d }}}
+
+#endif /* _NETINET_PIM_H_ */
--- /dev/null	Mon Dec  2 14:34:20 2002
+++ sys/netinet/pim_var.h	Thu Nov 21 17:04:33 2002
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 1998-2000
+ * University of Southern California/Information Sciences Institute.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _NETINET_PIM_VAR_H_
+#define _NETINET_PIM_VAR_H_
+
+/*
+ * Protocol Independent Multicast (PIM),
+ * kernel variables and implementation-specific definitions.
+ *
+ * Written by George Edmond Eddy (Rusty), ISI, February 1998.
+ * Modified by Pavlin Radoslavov, USC/ISI, May 1998, Aug 1999, October 2000.
+ * Modified by Hitoshi Asaeda, WIDE, August 1998.
+ */
+
+/*
+ * PIM statistics kept in the kernel
+ */
+struct pimstat {
+	u_quad_t pims_rcv_total_msgs;	   /* total PIM messages received    */
+	u_quad_t pims_rcv_total_bytes;	   /* total PIM bytes received	     */
+	u_quad_t pims_rcv_tooshort;	   /* rcvd with too few bytes	     */
+	u_quad_t pims_rcv_badsum;	   /* rcvd with bad checksum	     */
+	u_quad_t pims_rcv_badversion;	   /* rcvd bad PIM version	     */
+	u_quad_t pims_rcv_registers_msgs;  /* rcvd regs. msgs (data only)    */
+	u_quad_t pims_rcv_registers_bytes; /* rcvd regs. bytes (data only)   */
+	u_quad_t pims_rcv_registers_wrongiif; /* rcvd regs. on wrong iif     */
+	u_quad_t pims_rcv_badregisters;	   /* rcvd invalid registers	     */
+	u_quad_t pims_snd_registers_msgs;  /* sent regs. msgs (data only)    */
+	u_quad_t pims_snd_registers_bytes; /* sent regs. bytes (data only)   */
+};
+
+/*
+ * Names for PIM sysctl objects
+ */
+#define PIMCTL_STATS		1	/* statistics (read-only) */
+#define PIMCTL_MAXID		2
+
+#define PIMCTL_NAMES {			\
+	{ 0, 0 },			\
+	{ "stats", CTLTYPE_STRUCT },	\
+}
+
+#if (defined(KERNEL)) || (defined(_KERNEL))
+extern struct pimstat pimstat;
+
+void pim_input(struct mbuf *, int);
+SYSCTL_DECL(_net_inet_pim);
+#endif /* KERNEL */
+
+#endif /* _NETINET_PIM_VAR_H_ */
